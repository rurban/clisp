# Mensajes en español para GNU clisp 2.49.60
# Copyright (C) 2017 Free Software Foundation, Inc.
# This file is distributed under the same license as the clisp package.
# Carlos Linares López <clinares@delicias.dia.fi.upm.es>, 1997.
# Santiago Vila Doncel
# Leonardo Sarasúa García
# Francisco Javier Serrador <serrador@tecknolabs.com>\n
#
# Han contribuido a esta traducción:
#
# cll - Carlos Linares López 	(Traducción)
# sv  - Santiago Vila Doncel	(Revisión)
# lsg - Leonardo Sarasúa García	(Traducción y Revisión)
#
# Agradecimientos especiales a:
#
# Bruno Haible
# Marcus Daniels	(Programadores de CLisp)
# Enrique Melero	(Coordinador de Spanish GNU)
#
# Por haber atendido siempre mis preguntas y por mostrar tanto interés
# en esta traducción.
#
# Muchísimas gracias, Leo. Te debo la cerveza más grande del mundo, ...
#
# Asimismo, quisiera expresar mi agradecimiento a las siguientes
# personas, por responder pacientemente todas mis preguntas: Joerg
# Hoehle (traductor de la versión francesa) y Juan Jordana.
#
# Por último, a toda la lista de Spanish GNU Translation Team
# (es@es.li.org) por sus sugerencias.
#
# NOTAS.
#
# * Los mensajes en los que se han realizado anotaciones de interés,
# bien porque haya alguna duda, bien porque contenga notas importantes
# relativas a las traducciones tienen la palabra `Duda:' al principio de
# su comentario.
#
# * Por favor, si alguien realiza alguna modificación a este archivo que
# ponga sus iniciales al final del comentario explicando el cambio y el
# motivo. Si su nombre no está en esta cabecera que lo añada poniendo
# las iniciales.
#
# * Todas las líneas que comienzan con #~S son mensajes obsoletos que no
# hace falta revisar. En cualquier caso, intentaré normalmente
# eliminarlas.
#
# Revision 1.25  2007/10/12 19:24:51  sds
# regenerated for 2.41.1 pretest
#
# Revision 1.24  2006/10/13 04:10:53  sds
# clisp 2.41 release (Friday the 13th!)
#
# Revision 1.23  2006/10/01 16:13:06  sds
# regenerated for 2.40 (2006-09-23)
#
# Revision 1.22  2006/07/14 15:45:47  sds
# regenerated for 2.39
#
# Revision 1.21  2006/01/24 15:55:42  sds
# regenerated for clisp 2.38 release
#
# Revision 1.20  2006/01/02 17:09:36  sds
# regenerated for 2.37 (2006-01-02)
#
# Revision 1.19  2005/12/04 22:37:32  sds
# regenerated for clisp 2.36 release
#
# Revision 1.18  2005/08/29 18:18:56  sds
# regenerated
#
# Revision 1.17  2005/08/28 16:27:17  sds
# regenerated
#
# Revision 1.16  2005/07/20 23:58:29  sds
# clisp 2.34 (2005-07-20)
#
# Revision 1.15  2005/07/13 19:11:34  sds
# regenerated for 2.33.84
#
# Revision 1.14  2005/07/06 17:05:52  sds
# regenerated
#
# Revision 1.13  2005/06/27 15:30:42  sds
# regenerated
#
# Revision 1.12  2005/03/17 23:14:48  sds
# regenerated
#
# Revision 1.11  2005/02/16 22:30:56  haible
# Regenerated.
#
# Revision 1.10  2004/12/10 16:11:18  sds
# GNU CLISP 2.33.80 (2004-11-27)
#
# Revision 1.9  2004/03/31 12:48:41  haible
# Update after change of format string convention: '~' -> '~S', '$' -> '~C'.
#
# Revision 1.8  2004/03/31 12:07:14  haible
# msgmerged.
#
# Revision 1.7  2004/03/31 11:52:39  haible
# Update for removal of leading and trailing newlines.
#
# Revision 1.6  2004/03/30 20:38:21  haible
# msgmerged.
#
# Revision 1.5  2004/03/17 20:47:07  sds
# regenerated for 2.33
#
# Revision 1.4  2004/03/14 17:27:54  sds
# regenerated for 2.32.94
#
# Revision 1.3  2004/03/12 19:22:47  sds
# regenerated for 2.32.93
#
# Revision 1.2  2002/09/13 15:00:36  sds
# regenerated for 2.30
#
# Revision 1.1  2002/05/18 14:27:46  sds
# kill src/gettext; POs are now in src/po
#
# Revision 1.1  2002/05/18 14:27:46  sds
# kill src/gettext; POs are now in src/po
#
# Revision 1.10  1998/09/07 18:21:38  clinares
# Traducción de todos los mensajes para la versión del 29-8-1998. Estos
# cambios, sin embargo, serán publicados en alguna nueva versión de
# septiembre de este mismo año.
#
# Revision 1.9  1997/09/18 13:36:38  clinares
# He incluído nuevas modificaciones de Leo Sarasúa.
#
# Entre las más representativas está el hecho de haber modificado
# `trama' por `marco' y `# macro carácter' por `macro carácter
# secundario'. Nuevamente gracias, Leo, ...
#
# Revision 1.8  1997/09/05 17:23:30  clinares
# He introducido todas las modificaciones propuestas por Santiago Vila a
# la versión 1.6. Además, las he adaptado para el nuevo .pot que se
# empleó en la versión 1.7.
#
# Entre los cambios más importantes está: `command' es `orden', no
# `comando'; `warning' es, preferiblemente, `atención' y, en otro caso,
# propongo que sea `advertencia', en vez de `aviso'.
#
# Revision 1.7  1997/09/03 17:51:44  clinares
# He modificado la traducción de las directivas ~SP, puesto que nunca se
# escribirán versiones en español de ellas, ya que el estándar Common
# Lisp - The Language es muy específico: solo en inglés. Ni en alemán,
# ni francés, ni español, ...
#
# Además, he adaptado los cambios del POT de la versión 1.6
# (POT-Creation-Date: 1997-05-04) a la última versión que existe
# actualmente (POT-Creation-Date: 1997-09-02). Para ello, he traducido 9
# mensajes nuevos, he corregido los mensajes difusos y he borrado todos
# los obsoletos.
#
# Revision 1.6  1997/08/30 14:04:08  clinares
# El 100% de los mensajes están traducidos :)
# En total, 9 meses de trabajo (es decir, aha sido un parto!! :)
#
# Revision 1.5  1997/08/27 00:48:46  clinares
# Esta es la traducción que resulta de programar todos los cambios
# propuestos por lsg (Leonardo Sarasúa García). En total, aalrededor de
# 800 líneas!!, ahí es nada :)
#
#
msgid ""
msgstr ""
"Project-Id-Version: GNU clisp 2.49.60\n"
"Report-Msgid-Bugs-To: clisp-devel@lists.sourceforge.net\n"
"POT-Creation-Date: 2017-06-25 11:29:01+0200\n"
"PO-Revision-Date: 2017-12-26 17:22+0100\n"
"Last-Translator: Francisco Javier Serrador <serrador@tecknolabs.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"X-Generator: Poedit 1.8.7.1\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Poedit-SourceCharset: UTF-8\n"

# "*** - desbordamiento de la pila del programa - REINICIALIZANDO" - lsg
#
# En mi opinión, RESET debe traducirse como un imperativo - cll
#
#: spvw.d:909
msgid "*** - Program stack overflow. RESET"
msgstr "*** - Sobredesbordamiento de la pila del programa. REINICIE"

# ¡ Toma puntilloso que soy! Lisp debería escribirse con mayúscula.
# "*** - desbordamiento de la pila de Lisp - REINICIALIZANDO" - lsg
#
# No, no, nada de REINICIALIZANDO. Debe ser un imperativo: REINICIE.
# Por ejemplo, si durante una sesión con CLisp haces:
#
# > (defun foo (a) (foo (1- a)))
# FOO
# > (foo 2)
#
# *** - Desbordamiento de la pila de Lisp. REINICIE
# >
#
# ..., pero el intérprete se queda esperando a que tú sigas tecleando,
# es decir, él solo no se pone a reiniciar nada, ...
#
# Por otra parte, tienes toda la razón, Lisp debe ir con mayúsculas :) - cll
#
#: spvw.d:924
msgid "*** - Lisp stack overflow. RESET"
msgstr "*** - Sobredesbordamiento de la pila de Lisp. REINICIE"

#: spvw.d:1089
#, lisp-format
msgid "~S: malloc() failed"
msgstr "~S: malloc() ha fallado"

#: spvw.d:1100
#, lisp-format
msgid "~S: realloc() failed"
msgstr "~S: realloc() ha fallado"

#
# Muy bueno el apunte sobre ese acento en "cómo". Gracias, Santiago - cll
#
#: spvw.d:1136
#, lisp-format
msgid ""
"Internal error: statement in file ~S, line ~S has been reached!!\n"
"Please see <http://clisp.org/impnotes/faq.html#faq-bugs> for bug reporting instructions."
msgstr ""
"Error interno: ¡¡sentencia del fichero ~S, línea ~S ha sido alcanzada!!\n"
"¡Por favor, vea para más estados defectuosos."

# ß¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:1190
msgid "Unknown FSUBR signature: %d %d %d\n"
msgstr ""
"Firma desconocida FSUBR: %d %d %d\n"
"\n"

# ß¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:1298
msgid "Unknown SUBR signature: %d %d %d %d"
msgstr "Firma desconocida SUBR: %d %d %d %d"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:2022
msgid "module '%s' requires package %s.\n"
msgstr "un módulo “%s” requiere un paquete %s.\n"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:2032
msgid "module '%s' redefines symbol "
msgstr "un módulo “%s” redefine un símbolo "

#: spvw.d:2034
msgid " in the locked package "
msgstr " dentro del paquete bloqueado "

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: spvw.d:2036
msgid ""
"\n"
"old definition: "
msgstr ""
"\n"
"definición anterior: "

#: spvw.d:2073
msgid "is an ANSI Common Lisp implementation."
msgstr "es una implementación ANSI Common Lisp."

#: spvw.d:2075
msgid ""
"This image does not process the usual command line arguments.\n"
"To create a normal image \"myclisp\", please do\n"
"%s --clisp-x '(ext:saveinitmem \"myclisp\" :executable t :init-function nil)'\n"
msgstr ""
"Esta imagen no procesa los argumentos de líneas de órdenes usuales.\n"
"Para crear una imagen común “myclisp”, por favor haga\n"
"%s --clisp-x '(ext:saveinitmem \"myclisp\" :executable t :init-function nil)'\n"

#: spvw.d:2080
msgid ""
"Usage:  %s [options] [lispfile [argument ...]]\n"
" When 'lispfile' is given, it is loaded and '*ARGS*' is set\n"
" to the list of argument strings. Otherwise, an interactive\n"
" read-eval-print loop is entered.\n"
msgstr ""
"Empleo:  %s [opciones] [lispfile [argumento ...]]\n"
" Cuando 'lispfile' está dado, cargado y '*ARGS*' establecido\n"
" para la lista de cadenas de argumentos. En otro caso, se\n"
" introduce un bucle read-eval-print.\n"

#: spvw.d:2084
msgid "Informative output:"
msgstr "Salida informativa:"

#: spvw.d:2085
msgid " -h, --help    - print this help and exit"
msgstr "  -h,  --help    - enseña esta ayuda y finaliza"

#: spvw.d:2086
msgid " --version     - print the version information"
msgstr " --version       - enseña la información de la versión"

#: spvw.d:2087
msgid " --license     - print the licensing information"
msgstr " --license \t- enseña la información de la licencia"

#: spvw.d:2088
msgid " -help-image   - print image-specific help and exit"
msgstr " -help-image  - enseña la ayuda de imagen específica y termina"

#: spvw.d:2089
msgid "Memory image selection:"
msgstr "Seleccione la imagen de memoria:"

#: spvw.d:2090
msgid " -B lisplibdir - set the installation directory"
msgstr " -B lisplibdir - establece el directorio de la instalación"

#: spvw.d:2092
msgid " -K linkingset - use this executable and memory image"
msgstr " -K linkingset - emplee este ejecutable y memoria de imagen"

#: spvw.d:2094
msgid " -M memfile    - use this memory image"
msgstr " -M fichmem   - emplee esta imagen de memoria"

#: spvw.d:2095
msgid " -m size       - memory size (size = nB or nKB or nMB)"
msgstr " -m tamaño   - tamaño de memoria (tamaño = nB o nKB o nMB)"

#: spvw.d:2096
msgid "Internationalization:"
msgstr "Internacionalización:"

#: spvw.d:2097
msgid " -L language   - set user language"
msgstr " -L idioma      - establece el idioma del usuario"

#: spvw.d:2098
msgid " -N nlsdir     - NLS catalog directory"
msgstr "-N nlsdir       - directorio de catalogo NLS"

#: spvw.d:2099
msgid " -Edomain encoding - set encoding"
msgstr " -Edomain codificación - establece la codificación"

#: spvw.d:2100
msgid "Interoperability:"
msgstr "Interoperatividad:"

#: spvw.d:2101
msgid ""
" -q, --quiet, --silent, -v, --verbose - verbosity level:\n"
"     affects banner, *LOAD-VERBOSE*/*COMPILE-VERBOSE*,\n"
"     and *LOAD-PRINT*/*COMPILE-PRINT*"
msgstr ""
" -q, --quiet, --silent, -v, --verbose - nivel verboso:\n"
"      afecta banderas, *LOAD-VERBOSE*/*COMPILE-VERBOSE*,\n"
"     y *LOAD-PRINT*/*COMPILE-PRINT*"

#: spvw.d:2104
msgid " -w            - wait for a keypress after program termination"
msgstr " -w            - espera para una pulsación de tecla después de terminar el programa"

#: spvw.d:2105
msgid " -I            - be ILISP-friendly"
msgstr " -l             - ser ILISP-compatible"

#: spvw.d:2106
msgid " -disable-readline - do not use the gnu readline library"
msgstr " -disable-readline - no emplear la biblioteca readline de gnu"

#: spvw.d:2107
msgid "Startup actions:"
msgstr "Operaciones de inicio:"

#: spvw.d:2108
msgid " -ansi         - more ANSI CL compliance"
msgstr " -ansi        - más compatibilidad con ANSI CL"

#: spvw.d:2109
msgid " -traditional  - traditional (undoes -ansi)"
msgstr " -traditional  - tradicional (deshace -ansi)"

#: spvw.d:2110
msgid " -modern       - start in a case-sensitive lowercase-preferring package"
msgstr " -modern        - comienza en un paquete mayúsculas distinguibles prefiriendo minúsculas"

#: spvw.d:2111
msgid " -p package    - start in the package"
msgstr " -p paquete     - comienza en el paquete"

#: spvw.d:2112
msgid " -C            - set *LOAD-COMPILING* to T"
msgstr " -C            - establece *LOAD-COMPILING* a T"

#: spvw.d:2113
msgid " -norc         - do not load the user ~/.clisprc file"
msgstr " -norc         - no cargar el fichero del usuario ~/.clisprc"

#: spvw.d:2114
msgid " -lp dir       - add dir to *LOAD-PATHS* (can be repeated)"
msgstr " -lp dir       - añadir directorio a *LOAD-PATHS* (puede repetirse)"

#: spvw.d:2115
msgid " -i file       - load initfile (can be repeated)"
msgstr " -i file       - carga fichero de inicialización initfile (puede repetirse)"

#: spvw.d:2116
msgid "Actions:"
msgstr "Acciones:"

#: spvw.d:2117
msgid " -c [-l] lispfile [-o outputfile] - compile lispfile"
msgstr " -c [-l] ficherolisp [-o ficherosalida] - complila fichero de lisp"

#: spvw.d:2118
msgid " -x expressions - execute the expressions, then exit"
msgstr " -x expresiones - ejecuta las expresiones, después termina"

#: spvw.d:2119
msgid " Depending on the image, positional arguments can mean:"
msgstr " Dependiendo en la imagen, argumentos posicionales pueden significar:"

#: spvw.d:2120
msgid "   lispscript [argument ...] - load script, then exit"
msgstr "    listscript [argumento ...] - carga script, después termina"

#: spvw.d:2121
msgid "   [argument ...]            - run the init-function"
msgstr "   [argumento ...]           - ejecuta la función init-function"

#: spvw.d:2122
msgid "  arguments are placed in EXT:*ARGS* as strings."
msgstr "  argumentos son colocados en EXT:*ARGS* como cadenas."

#: spvw.d:2123
msgid "These actions put CLISP into a batch mode, which is overridden by"
msgstr "Estas acciones ponen a CLISP dentro de un modo de batch, el cual es sobreconducido por"

#: spvw.d:2124
msgid " -on-error action - action can be one of debug, exit, abort, appease"
msgstr " -on-error acción - acción puede ser una de depuración, salida, aborto, agrego"

#: spvw.d:2125
msgid " -repl            - enter the interactive read-eval-print loop when done"
msgstr " -repl            - introduce el bucle interactivo read-eval-print cuando termine"

#: spvw.d:2126
msgid "Default action is an interactive read-eval-print loop."
msgstr "Operación predeterminada es un bucle interactivo read-eval-print."

#: spvw.d:2135
msgid "%s: use '-h' for help"
msgstr "%s: emplee ‘-h’ para ayuda                         Escribe esta ayuda, después finaliza"

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# a¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#: spvw.d:2139
msgid "invalid argument"
msgstr "argumento no válido"

#: spvw.d:2281
msgid "Welcome to"
msgstr "Bienvenido a"

#: spvw.d:2287
msgid "Type :h and hit Enter for context help."
msgstr "Teclee :h y pulse Intro para ayuda contextual."

#: spvw.d:2450
msgid "Syntax for %s: nnnnnnn or nnnnKB or nMB"
msgstr "Sintaxis de %s: nnnnnnn o nnnnKB o nMB"

#: spvw.d:2456
msgid "warning: %s %lu too small, using %lu instead"
msgstr "advertencia: %s %lu demasiado pequeño, empleando %lu en su lugar"

#: spvw.d:2462
msgid "warning: %s %lu too large, using %lu instead"
msgstr "advertencia: %s %lu demasiado largo, empleando en su lugar %lu"

#: spvw.d:2618
msgid "memory size"
msgstr "tamaño de memoria"

#: spvw.d:2644
msgid "multiple -B"
msgstr "-B múltiple"

#: spvw.d:2652
msgid "This option requires an argument"
msgstr "Esta opción requiere un argumento"

#: spvw.d:2689
msgid "-E requires an argument"
msgstr "-E requiere un argumento"

#: spvw.d:2924
msgid "-l without -c is invalid"
msgstr "-l sin -c no es válido"

# Duda: En este mensaje, el primer "~S" se sustituye por el nombre de una
# función y el segundo "~S" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: spvw.d:2930
msgid "-x with -c is invalid"
msgstr "-x con -c es no válido"

#: spvw.d:2935
msgid "-x with lisp-file is invalid"
msgstr "-x con fichero-lisp no es válido"

#: spvw.d:3079
msgid "Return value of malloc() = %lx is not compatible with type code distribution."
msgstr "Valor devuelto por malloc() = %lx no es compatible con la distribución del código de tipo."

# solo es con acento.
# "sólo %d bytes disponibles\n" - lsg
#
# aMadre mía!! Tienes toda la razón del mundo - cll :)
#
#: spvw.d:3086
msgid "Only %ld bytes available."
msgstr "Sólo quedan %ld bytes disponibles."

# Duda: Imagino que SP es el "Stack Pointer". Pero entonces, ¿a qu
# viene decir "SP stack"? ¿Se referirán con ello a la pila del sistema?
# - cll
#
#: spvw.d:3321
msgid "Could not determine the end of the SP stack!"
msgstr "No fue posible determinar el final de la pila SP!"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:3496
msgid "WARNING: No initialization file specified."
msgstr "ADVERTENCIA: no se ha especificado ningún fichero de inicialización."

#: spvw.d:3498 spvw.d:3510
msgid "Please try: "
msgstr "Por favor, intente:"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:3508
msgid "WARNING: No installation directory specified."
msgstr "ADVERTENCIA: no se ha especificado ningún directorio de instalación."

#: spvw.d:3574
msgid "All positional arguments are put into "
msgstr "Todos los argumentos posicionales están establecidos dentro de "

#: spvw.d:3576
msgid ""
"The first positional argument is the script name,\n"
"the rest are put into "
msgstr ""
"El primer argumento posicional es el nombre del\n"
"script, el resto se ponen en "

#: spvw.d:3707
msgid "WARNING: no such package: "
msgstr "ADVERTENCIA: sin dicho paquete: "

#: spvw.d:3900
msgid "main thread"
msgstr "hilo principal"

#: spvw.d:4060
msgid "%s: Not enough memory for Lisp."
msgstr "%s: no hay memoria suficiente para Lisp."

#: spvw.d:4145
msgid "Bye."
msgstr "Adiós."

#: spvw.d:4151
msgid "Press a key to terminate..."
msgstr "Presione una tecla para terminar..."

# "*** - Memoria virtual agotada. REINICIALIZACION " - lsg
#
# Yo creo que el mensaje debe acabar en un imperativo: REINICIALIZAR - cll
#
#: spvw_alloca.d:48
msgid "*** - Virtual memory exhausted. RESET"
msgstr "*** - Memoria virtual agotada. REINICIE"

# "*** - Memoria agotada. REINICIALIZACION " - lsg
#
# Más de lo mismo - cll
#
#: spvw_alloca.d:50
msgid "*** - Memory exhausted. RESET"
msgstr "*** - Memoria agotada. REINICIE"

#: spvw_mmap.d:105
msgid "Warning: overwriting existing memory mappings in the address range 0x%lx...0x%lx. clisp will likely crash soon!!\n"
msgstr "Advertencia: sobrescribiendo desglose de memoria en el rango de dirección 0x%lx...0x%lx. ¡¡clisp explotará pronto!!\n"

#: spvw_mmap.d:161
msgid "Warning: reserving address range 0x%lx...0x%lx that contains memory mappings. clisp might crash later!\n"
msgstr "Advertencia: reservando rango de direcciones 0x%lx...0x%lx que contiene distribuciones de memoria. clisp puede romperse más tarde!\n"

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:203 spvw_mmap.d:323 spvw_mmap.d:496
msgid "Cannot map memory to address 0x%lx ."
msgstr "No se puede asignar la memoria a la dirección 0x%lx ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:296
msgid "Cannot reserve address range at 0x%lx ."
msgstr "No se puede reservar el rango de direcciones en 0x%lx ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:306
msgid "Cannot reserve address range 0x%lx-0x%lx ."
msgstr "No se puede reservar el rango de direcciones 0x%lx-0x%lx ."

#: spvw_mmap.d:350
msgid "CreateFileMapping() failed."
msgstr "CreateFileMapping() falló."

#: spvw_mmap.d:358
msgid "MapViewOfFileEx(addr=0x%x,off=0x%x) failed."
msgstr "MapViewOfFileEx(dirección=0x%x,segmento=0x%x) falló."

#: spvw_mmap.d:364
msgid "MapViewOfFileEx() returned 0x%x instead of 0x%x."
msgstr "MapViewOfFileEx() devolvió 0x%x en vez de 0x%x."

#: spvw_mmap.d:379
msgid "VirtualFree() failed."
msgstr "VirtualFree() fallado."

#: spvw_mmap.d:393
msgid "VirtualProtect() failed."
msgstr "VirtualProtect() fallado."

#: spvw_mmap.d:460
msgid "Cannot open <%s>."
msgstr "No se puede abrir <%s>."

#: spvw_global.d:628
#, lisp-format
msgid "CALL-WITH-TIMEOUT has failed in thread ~S."
msgstr "CALL-WITH-TIMEOUT ha fallado en el hilo ~S."

#: spvw_global.d:753
#, lisp-format
msgid "~S: could not make symbol value per-thread"
msgstr "~S: podría no crear valor simbólico por hilo"

#: spvw_fault.d:285
msgid "mprotect(0x%lx,%d,%d) failed."
msgstr "mprotect(0x%lx,%d,%d) fallado."

#: spvw_sigsegv.d:25
msgid "GC count: %lu"
msgstr "Contado GC: %lu"

# collect → recoger
#: spvw_sigsegv.d:27
msgid "Space collected by GC:"
msgstr "Espacio recogido por GC:"

#: spvw_sigsegv.d:41
msgid "Run time:"
msgstr "Tiempo de ejecución:"

#: spvw_sigsegv.d:43
msgid "Real time:"
msgstr "Hora real:"

#: spvw_sigsegv.d:45
msgid "GC time:"
msgstr "Tiempo GC:"

#: spvw_sigsegv.d:48
msgid "Permanently allocated: %lu bytes."
msgstr "Permanentemente asignados: %lu bytes."

#: spvw_sigsegv.d:51
msgid "Currently in use: %lu bytes."
msgstr "Actualmente empleados: %lu bytes."

#: spvw_sigsegv.d:54
msgid "Free space: %lu bytes."
msgstr "Espacio libre: %lu bytes."

# "SIGSEGV no puede ser subsanado. Dirección del error =3D 0x%x.\n" - lsg
#
# Si, me gusta más tu traducción. Yo había puesto:
#
# "No se puede evitar SIGSEGV. Dirección de fallo = 0x%x.\n"
#
# Pero el caso es que un SIGSEGV no tiene porque evitarse puesto que es
# una señal que, para cuando sale este mensaje, ya se ha recibido. El
# problema ---realmente--- es que no fue posible "subsanar" la
# señal. Muy bien - cll
#
# De todas formas, prefiero ponerlo al revés ("No se puede subsanar" en
# vez de "... no puede ser subsanado"). Por otra parte, en vez de
# "error" prefiero "fallo" puesto que eso es exactamente de lo que se
# trata. No de un error por algo que alguien hizo mal, sino de un fallo
# del sistema, ... - cll
#
#: spvw_sigsegv.d:65
msgid "SIGSEGV cannot be cured. Fault address = 0x%lx."
msgstr "SIGSEGV no se puede subsanar Dirección de fallo = 0x%lx."

#: spvw_sigsegv.d:180
msgid "Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!"
msgstr "Escenario Apollo 13: Falló la manipulación del desbordamiento de pila. a¡ Nos estrellaremos en el siguiente desbordamiento de pila !!!"

#: spvw_sigint.d:66 spvw_sigint.d:131
msgid "Ctrl-C: User break"
msgstr "Ctrl-C: Interrupción del usuario"

#: spvw_garcol.d:2563 spvw_garcol_old.d:1981
msgid "munmap() failed."
msgstr "munmap() fallado."

#: spvw_allocate.d:86
msgid "No more room for LISP objects"
msgstr "Sin más espacio para almacenar más objetos LISP"

#
# "*** - no queda espacio para almacenar objetos LISP - REINICIALIZANDO" - lsg
#
# Yo sigo en mis trece, ... Debe ser un imperativo: REINICIE - cll
#
#: spvw_allocate.d:103
msgid "*** - No more room for LISP objects: RESET"
msgstr "*** - No queda espacio para almacenar más objetos LISP: REINICIE"

#: spvw_allocate.d:314 spvw_allocate.d:373 spvw_allocate.d:456
msgid "Trying to make room through a GC..."
msgstr "Intentando obtener más espacio a través de un GC ..."

#: spvw_sigterm.d:53
msgid "Signal %d while exiting on a signal; cleanup may be incomplete\n"
msgstr "Señal %d mientras salía de una señal; el vaciado puede ser incompleto\n"

#: spvw_sigterm.d:60
msgid "Exiting on signal "
msgstr "Saliendo en la señal "

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: spvw_language.d:115
msgid "WARNING: %s/%s: %s.\n"
msgstr "ADVERTENCIA: %s/%s: %s.\n"

#: spvw_language.d:161
#, lisp-format
msgid "~S: locales ~S and ~S are not installed on this system"
msgstr "~S: ~S ubicable y ~S no están instalado en este sistema"

#: spvw_language.d:163
msgid "locales %s and %s are not installed on this system\n"
msgstr "%s ubicables y %s no están instalado en este sistema\n"

#: spvw_language.d:184
#, lisp-format
msgid "~S: invalid language ~S"
msgstr "~S: lenguaje no válido ~S"

#: spvw_language.d:202
#, lisp-format
msgid "~S: ~S resolves to ~S which is a file, not a directory"
msgstr "~S: ~S resuelve a ~S el cual es un fichero, no un directorio"

#: spvw_language.d:204
msgid "%s resolves o %s which is a file, not a directory\n"
msgstr "%s resuelve a %s el cual es un fichero, no un directorio\n"

#: spvw_language.d:212
#, lisp-format
msgid "~S: ~S does not exist"
msgstr "~S: ~S no existe"

#: spvw_language.d:214
msgid "%s does not exist\n"
msgstr "%s no existe\n"

#: spvw_language.d:234
msgid "WARNING: setting language to %s failed.\n"
msgstr "ADVERTENCIA: estableciendo contexto a %s ha fallado.\n"

#: spvw_memfile.d:234
msgid "disk full"
msgstr "el disco está lleno"

#: spvw_memfile.d:300
#, lisp-format
msgid "runtime too small (~S bytes missing)"
msgstr "tiempo de ejecución demasiado corto (~S bytes faltantes)"

#: spvw_memfile.d:333
msgid "Delegating cookie not found"
msgstr "Delegando cookie no encontrado"

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#: spvw_memfile.d:991 spvw_memfile.d:1847
msgid "%s: operating system error during load of initialization file `%s'"
msgstr "%s: error del sistema operativo durante la carga del fichero de inicialización `%s'"

#: spvw_memfile.d:1512
msgid "%s: Cannot map the initialization file `%s' into memory."
msgstr "%s: No puedo asignar el fichero de inicialización ‘%s’ dentro de memoria."

#: spvw_memfile.d:1852
msgid "%s: initialization file `%s' was not created by this version of CLISP runtime"
msgstr "%s: fichero de inicialización ‘%s’ no ha sido creado con esta versión de tiempo de ejecución CLISP"

#: spvw_memfile.d:1856
msgid "%s: not enough memory for initialization"
msgstr "%s: no hay memoria suficiente para inicialización."

#: spvw_memfile.d:1906
msgid "%s: 'image size' method failed, but found image header at %d\n"
msgstr "%s: método de 'tamaño de imagen' ha fallado, pero ha encontrado una cabecera de imagen en %d\n"

#: eval.d:879 init.lisp:846 init.lisp:861 compiler.lisp:1166
#, lisp-format
msgid "Invalid access to the value of the lexical variable ~S from within a ~S definition"
msgstr "Acceso no válio para el valor de la variable léxica ~S desde dentro de una definición ~S"

#: eval.d:1063 init.lisp:786 init.lisp:800 compiler.lisp:924
#, lisp-format
msgid "Invalid access to the local function definition of ~S from within a ~S definition"
msgstr "Acceso no válido para la definición de función local de ~S desde dentro de una definición ~S"

#: eval.d:1553
#, lisp-format
msgid "Too many documentation strings in ~S"
msgstr "Demasiadas cadenas de documentación en ~S"

#: eval.d:1574
#, lisp-format
msgid "Invalid declaration ~S"
msgstr "Declaración no válida ~S"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~S. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#: eval.d:1760
#, lisp-format
msgid "~S: lambda-list for ~S is missing"
msgstr "~S: la lista-macro para ~S falta."

#
# "FUNCTION: la lista lambda de ~S debe ser una lista, no un(a) ~S" - lsg
#
# Lo de "un(a)" no me mola, aunque sin esa palabra el mensaje queda más
# "telegráfico", me parece más apropiado para tratarse del "diálogo con
# un ordenador" :) - cll
#
#: eval.d:1768
#, lisp-format
msgid "~S: lambda-list for ~S should be a list, not ~S"
msgstr "~S: lista-lamda para ~S debería ser una lista, no ~S"

#: eval.d:1895
#, lisp-format
msgid "~S: illegal declaration ~S"
msgstr "~S: declaración incorrecta ~S"

#: eval.d:1989 eval.d:2171
#, lisp-format
msgid "~S: variable specification after ~S too long: ~S"
msgstr "~S: especificación de variable después de ~S es demasiado largo: ~S"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~S" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:2027
#, lisp-format
msgid "~S: ~S var must be followed by ~S or ~S or end of list: ~S"
msgstr "~S: variable ~S debe ser seguida por ~S o ~S o final de lista: ~S"

#
# Igualmente: "FUNCTION: &REST debe ir seguido de una variable: ~S" - lsg
#
# Pues si, es que cuando uno está mucho tiempo traduciendo del inglés,
# llega un momento en que empieza coger los hábitos de ese lenguaje y
# empieza a expresarse de una manera extraña, ... - cll
#
#: eval.d:2034
#, lisp-format
msgid "~S: ~S must be followed by a variable: ~S"
msgstr "~S: ~S debe ser seguido por una variable: ~S"

#: eval.d:2129
#, lisp-format
msgid "~S: incorrect variable specification after ~S: ~S"
msgstr "~S: especificación de variable incorrecta después de ~S: ~S"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~S" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:2139
#, lisp-format
msgid "~S: ~S must be followed by ~S or end of list: ~S"
msgstr "~S: ~S debe ser seguida por ~S o la finalización de lista: ~S"

#: eval.d:2192
#, lisp-format
msgid "~S: badly placed lambda-list keyword ~S: ~S"
msgstr "~S: la palabra de lista lambda ~S de la macro mal situado: ~S"

#: eval.d:2202
#, lisp-format
msgid "~S: too many parameters in the lambda-list ~S"
msgstr "~S: excesivos parámetros dentro de la lista lambda ~S"

#: eval.d:2210
#, lisp-format
msgid "~S: a dot in a lambda-list is allowed only for macros, not here: ~S"
msgstr "~S: un punto dentro de una lista lamda está solo permitida para macros, no aquí: ~S"

#: eval.d:2281
#, lisp-format
msgid "~S: ~S is a special operator, not a function"
msgstr "~S: ~S es un operador especial, no una función"

#: eval.d:2292
#, lisp-format
msgid "~S: ~S is a macro, not a function"
msgstr "~S: ~S es una macro, no una función"

#
# 'Se han pasado demasiados argumentos a ~S" - lsg
#
# Bueno, tu traducción es absolutamente válido. Tal vez, algo más
# informal que la mía, por aquello de "pasado" en vez de
# "entregado". Bueno, pues si te parece, esta vez lo dejo como lo tenía
# yo - cll
#
#: eval.d:2644
#, lisp-format
msgid "EVAL/APPLY: too many arguments given to ~S"
msgstr "EVAL/APPLY: se han entregado demasiados argumentos a ~S"

# "EVAL: no se han pasado suficientes argumentos a la forma especial ~S:~S" - lsg
#
# Bueno, pues te digo lo mismo que en el mensaje eval.d:2572, ... - cll
#
#: eval.d:3234
#, lisp-format
msgid "EVAL: too few parameters for special operator ~S: ~S"
msgstr "EVAL: escasos parámetros para operador especial ~S: ~S"

#
# "Se han pasado demasiados parámetros a la forma especial ~S: ~S" - lsg
#
# O sea, que quite lo de "para" y ponga "a". Pues vale, tienes toda la
# razón del mundo - cll
#
#: eval.d:3247
#, lisp-format
msgid "EVAL: too many parameters for special operator ~S: ~S"
msgstr "EVAL: demasiados parámetros para operador especial ~S: ~S"

#: eval.d:3259
#, lisp-format
msgid "EVAL: dotted parameter list for special operator ~S: ~S"
msgstr "EVAL: la lista de parámetros punteados para operador especial ~S: ~S"

#
# "EVAL: no se han pasado suficientes argumentos a ~S:~S" - lsg
#
# Una vez más, te digo lo mismo que en el mensaje eval.d:2572 - cll
#
#: eval.d:3319
#, lisp-format
msgid "EVAL: too few arguments given to ~S: ~S"
msgstr "EVAL: escasos argumentos dados para ~S: ~S"

#
# "Se han pasado demasiados argumentos a ~S: ~S" - lsg
#
# Me gusta más "entregado" que "pasado" - cll
#
#: eval.d:3329
#, lisp-format
msgid "EVAL: too many arguments given to ~S: ~S"
msgstr "EVAL: demasiados argumentos dados a ~S: ~S"

#
# "EVAL: la lista de argumentos pasada a ~S es punteada: ~S" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: eval.d:3337
#, lisp-format
msgid "EVAL: argument list given to ~S is dotted: ~S"
msgstr "EVAL: la lista de argumentos entregada a ~S está punteada: ~S"

#
# "Se han pasado demasiados argumentos a ~S" - lsg
#
# Una vez más, me gusta más "entregar" que "pasar" - cll
#
#: eval.d:4097
#, lisp-format
msgid "APPLY: too many arguments given to ~S"
msgstr "APPLY: se han entregado demasiados argumentos a ~S"

#: eval.d:4108
#, lisp-format
msgid "APPLY: dotted argument list given to ~S : ~S"
msgstr "APPLY: lista de argumentos entregada a ~S : ~S"

#
# "APPLY: no se han pasado suficientes argumentos a ~S:~S" - lsg
#
# Pues eso, que me gusta más "entregar" - cll
#
#: eval.d:4112
#, lisp-format
msgid "APPLY: too few arguments given to ~S"
msgstr "APPLY: se han entregado pocos argumentos a ~S"

#: eval.d:6417
#, lisp-format
msgid "~S: assignment to constant symbol ~S is impossible"
msgstr "~S: asignación al símbolo constante ~S es imposible"

# Duda: tagbody es de muy difícil traducción.
#       Echando un ojo a la traducción en francés me he encontrado con que est
#       tal cual, ... De momento se queda así hasta que otros miembros del
#       equipo decidan cualquier otra cosa, ...
#
# No es que sepa lo que es, pero, si tag es etiqueta, tagbody podría ser
# "el cuerpo de la etiqueta" (¿tiene sentido esto?), con lo cual, una
# posibilidad sería (para simplificar) "el cuerpo de las etiquetas..." sv
#
# Otra de las propuestas a esta cuestión en la lista de correo
# es@li.org, ha sido: "el contenido de las etiquetas ~S ya ha sido
# abandonado". Esta traducción me gusta, ... cll
#
# ( Desafortunadamente, no recuerdo el nombre de la persona que lo
# sugirió, ... cll )
#
# "(~S ~S): ya se ha salido del cuerpo de etiquetas ~S" - lsg
#
# Debo rendirme a la evidencia, ... La propuesta de Leo, no solo para
# este término sino todos cuanto se refieren a la traducción de `tag' y
# `tagbody' es perfecta y, además, sigue los pasos de la de Santiago, de
# modo que "moción aceptada" :)
#
#: eval.d:7154 eval.d:7186
#, lisp-format
msgid "(~S ~S): the tagbody of the tags ~S has already been left"
msgstr "(~S ~S): ya se ha salido del cuerpo de etiquetas ~S"

#: eval.d:7243 control.d:1986
#, lisp-format
msgid "~S: there is no CATCHer for tag ~S"
msgstr "~S: no hay ningún capturador (CATCH) para la etiqueta de salto ~S"

#: eval.d:7263
msgid "STACK corrupted"
msgstr "Pila (STACK) corrupta"

#: eval.d:7603
#, lisp-format
msgid "~S: ~S is not a correct index into ~S"
msgstr "~S: ~S no es un índice correcto en ~S"

#: eval.d:8201
#, lisp-format
msgid "undefined bytecode in ~S at byte ~S"
msgstr "Código de octeto ~S indefinido en el octeto ~S"

#: eval.d:8215
#, lisp-format
msgid "~S: jump by ~S takes ~S outside [~S;~S]"
msgstr "~s: saltado por ~S toma ~S externo [~S; ~S]"

#: eval.d:8223
#, lisp-format
msgid "Corrupted STACK in ~S at byte ~S"
msgstr "Pila corrupta en ~S en el byte ~S"

#: control.d:79 init.lisp:1262
#, lisp-format
msgid "~S: ~S should be a lambda expression"
msgstr "~S: ~S debe ser una expresión lambda"

#: control.d:174
#, lisp-format
msgid "~S: odd number of arguments: ~S"
msgstr "~S: número impar de argumentos: ~S"

#: control.d:272
#, lisp-format
msgid "~S: the special operator definition of ~S must not be removed"
msgstr "~S: la definición de operador especial de ~S no debe ser retirado"

#: control.d:340
#, lisp-format
msgid "doc-string is not allowed here and will be ignored: ~S"
msgstr "doc-string aquí no se permiten cadenas y serán ignoradas: ~S"

#: control.d:403
#, lisp-format
msgid "~S: illegal variable specification ~S"
msgstr "~S: especificación no válida de variable ~S"

#: control.d:553
#, lisp-format
msgid "~S: symbol ~S has been declared SPECIAL and may not be re-defined as a SYMBOL-MACRO"
msgstr "~S: el símbolo ~S ha sido declarado ESPECIAL y no puede ser redefinido como un MACRO-SIMBÓLICO"

#: control.d:558
#, lisp-format
msgid "~S: symbol ~S must not be declared SPECIAL and defined a SYMBOL-MACRO at the same time"
msgstr "~S: el símbolo ~S no debe ser declarado ESPECIAL y definido como un MACRO-SIMBÓLICO al mismo tiempo"

#: control.d:594
#, lisp-format
msgid "~S: too many variables and/or declarations"
msgstr "~S: demasiadas variables y/o declaraciones"

#: control.d:871
#, lisp-format
msgid "~S: ~S is not a function specification"
msgstr "~S: ~S no es la especificación de una función"

#: control.d:1051
#, lisp-format
msgid "~S: ~S is not a macro specification"
msgstr "~S: ~S no es la especificación de una macro"

#: control.d:1058
#, lisp-format
msgid "~S: macro name ~S should be a symbol"
msgstr "~S: nombre de macro ~S debería ser un símbolo"

#: control.d:1113
#, lisp-format
msgid "~S: ~S is not a function and macro specification"
msgstr "~S: ~S no es una función y especificación de macro"

#: control.d:1120
#, lisp-format
msgid "~S: function and macro name ~S should be a symbol"
msgstr "~S: la función y el nombre de macro ~S debería ser un símbolo"

#: control.d:1236
#, lisp-format
msgid "~S: clause ~S should be a list"
msgstr "~S: la clausula ~S debe ser una lista"

#: control.d:1266
#, lisp-format
msgid "~S: missing key list: ~S"
msgstr "~S: falta la lista de claves: ~S"

#: control.d:1275 macros1.lisp:307
#, lisp-format
msgid "~S: the ~S clause must be the last one"
msgstr "~S: la clausula ~S debe ser la última"

#: control.d:1329
#, lisp-format
msgid "~S: the block named ~S has already been left"
msgstr "~S: el bloque de nombre ~S ya ha sido abandonado"

#: control.d:1364
#, lisp-format
msgid "~S: no block named ~S is currently visible"
msgstr "~S: no hay ningún bloque visible con el nombre ~S"

#: control.d:1621
#, lisp-format
msgid "~S: ~S is neither tag nor form"
msgstr "~S: ~S no es ni una etiqueta de salto ni un formato"

#: control.d:1664
#, lisp-format
msgid "~S: illegal tag ~S"
msgstr "~S: etiqueta de salto no válida ~S"

#: control.d:1702
#, lisp-format
msgid "~S: tagbody for tag ~S has already been left"
msgstr "~S: ya se ha salido del cuerpo de etiquetas de ~S"

#: control.d:1716
#, lisp-format
msgid "~S: no tag named ~S is currently visible"
msgstr "~S: no hay ninguna etiqueta de salto visible con el nombre ~S"

#: control.d:1730
#, lisp-format
msgid "~S: too many return values"
msgstr "~S: demasiados valores devueltos"

#: control.d:2026
#, lisp-format
msgid "Argument ~S is not a macroexpansion environment"
msgstr "El argumento ~S no es un entorno para la expansión de macros"

#: control.d:2083
#, lisp-format
msgid "declarations ~S are not allowed here"
msgstr "las declaraciones ~S no están permitidas aquí"

#: control.d:2105
#, lisp-format
msgid "~S: ~S evaluated to the values ~S, not of type ~S"
msgstr "~S: ~S evaluado a los valores ~S, ninguno de tipo ~S"

#: control.d:2116
#, lisp-format
msgid "~S: bad declaration ~S"
msgstr "~S: declaración ~S equivocada"

#: control.d:2387 error.d:1035
#, lisp-format
msgid "~S: ~S is not a symbol"
msgstr "~S: ~S no es un símbolo"

#: control.d:2422
#, lisp-format
msgid "keyword argument list ~S has an odd length"
msgstr "la lista de argumentos clave ~S tiene longitud impar"

#: control.d:2459
#, lisp-format
msgid ""
"Illegal keyword/value pair ~S, ~S in argument list.\n"
"The allowed keywords are ~S"
msgstr ""
"Par de argumento clave/valor no válido ~S, ~S en la lista de argumentos.\n"
"Los parámetros clave permitidos son ~S"

#: encoding.d:240
#, lisp-format
msgid "~S: Invalid base64 encoding termination at position ~S"
msgstr "~S: terminación de codificación base64 no válida en posición ~S"

#: encoding.d:248
#, lisp-format
msgid "~S: Invalid base64 encoding at ~S (character ~S of ~S)"
msgstr "~S: codificación base64 no válida en ~S (carácter ~S de ~S)"

#: encoding.d:282
#, lisp-format
msgid "~S: Character #\\u~C~C~C~C cannot be represented in the character set ~S"
msgstr "~S: Carácter #\\u~C~C~C~C no puede ser representado dentro del conjunto de caracter ~S"

#: encoding.d:287
#, lisp-format
msgid "~S: Character #\\u00~C~C~C~C~C~C cannot be represented in the character set ~S"
msgstr "~S: Carácter  #\\u00~C~C~C~C~C~C no puede ser representado en el conjunto de carácter ~S"

#: encoding.d:305
#, lisp-format
msgid "~S: Incomplete byte sequence at end of buffer for ~S"
msgstr "~S: Secuencia de byte incompleta el final del búfer para ~S"

#: encoding.d:568
#, lisp-format
msgid "~S: Character #x~C~C~C~C~C~C~C~C in ~S conversion, not an UTF-32 character"
msgstr "~S: Carácter #x~C~C~C~C~C~C~C~C en conversión ~S, no un carácter UTF-32"

#: encoding.d:767
#, lisp-format
msgid "~S: Invalid byte #x~C~C in ~S conversion, not a Unicode-16"
msgstr "~S: byte no válido #x~C~C dentro de conversión ~S, no un Unicode-16"

#: encoding.d:784
#, lisp-format
msgid "~S: Invalid byte sequence #x~C~C #x~C~C in ~S conversion"
msgstr "~S: secuencia de byte no válida #x~C~C #x~C~C dentro de conversión ~S"

#: encoding.d:804
#, lisp-format
msgid "~S: Invalid byte sequence #x~C~C #x~C~C #x~C~C in ~S conversion"
msgstr "~S: secuencia de byte no válida #x~C~C #x~C~C #x~C~C en conversión ~S "

#: encoding.d:828
#, lisp-format
msgid "~S: Invalid byte sequence #x~C~C #x~C~C #x~C~C #x~C~C in ~S conversion"
msgstr "~S: secuencia de byte #x~C~C #x~C~C #x~C~C #x~C~C no válida en conversión ~S "

#: encoding.d:1634
#, lisp-format
msgid "~S: Invalid byte #x~C~C in ~S conversion"
msgstr "~S: byte #x~C~C dentro de conversión ~S"

#: encoding.d:2561 encoding.d:2566
msgid "WARNING: %s: no encoding %s, using %s"
msgstr "ADVERTENCIA: %s: sin codificación %s, empleando %s"

#: encoding.d:2682
#, lisp-format
msgid "*PATHNAME_ENCODING* on this platform can only be ~S"
msgstr "*PATHNAME_ENCODING* en esta plataforma solo puede ser ~S"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#
#: pathname.d:663 pathname.d:704
#, lisp-format
msgid "~S: host should be NIL or a string, not ~S"
msgstr "~S: el anfitrión debe ser, o bien NIL, o una cadena, pero no ~S"

#
# Duda: he traducido hostname por "nombre del `host'". ¿Qué os parece?
#
#: pathname.d:683 pathname.d:725
#, lisp-format
msgid "~S: illegal hostname ~S"
msgstr "~S: nombre de anfitrión no válido ~S"

#: pathname.d:848
#, lisp-format
msgid "~S: Argument ~S should be a pathname designator ~S"
msgstr "~S: El argumento ~S debería ser una ruta designada por ~S"

#: pathname.d:881
#, lisp-format
msgid "~S: Filename for ~S is unknown"
msgstr "~S: nombre de fichero para ~S es desconocido"

#: pathname.d:1230 pathname.d:3454 pathname.d:8564 hashtabl.d:1995 error.d:1393 error.d:1412
#, lisp-format
msgid "~S: Illegal ~S argument ~S"
msgstr "~S: argumento de ~S no es legal ~S"

#: pathname.d:1360 realelem.d:204
#, lisp-format
msgid ""
"The variable ~S had an illegal value.\n"
"~S has been reset to ~S."
msgstr ""
"La variable ~S tenía un valor no válido.\n"
"~S ha sido inicializado a ~S."

#: pathname.d:1687
#, lisp-format
msgid "~S: there is no user named ~S"
msgstr "~S: no hay ningún usuario con el nombre ~S"

#: pathname.d:1746
#, lisp-format
msgid "~S: there is no environment variable ~S"
msgstr "~S: no hay ninguna variable de entorno ~S"

#: pathname.d:1913
#, lisp-format
msgid "~S: syntax error in filename ~S at position ~S"
msgstr "~S: error de sintáxis en el nombre del fichero ~S, en la posición ~S"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:1927 pathname.d:1940
#, lisp-format
msgid "~S: hosts ~S and ~S of ~S should coincide"
msgstr "~S: los anfitriones ~S y ~S de ~S deben coincidir"

#: pathname.d:2079
#, lisp-format
msgid "~S: argument ~S is not a logical pathname, string, stream or symbol"
msgstr "~S: un argumento ~S no es un PATHNAME \"lógica\", una cadena de caracteres, un flujo o un símbolo"

#: pathname.d:2089
#, lisp-format
msgid "~S: the stream ~S was not opened with a logical pathname"
msgstr "~S: el flujo ~S no se ha abierto con un nombre de ruta lógica"

#: pathname.d:2103
#, lisp-format
msgid "~S: argument ~S does not contain a host specification"
msgstr "~S: un argumento ~S no contiene una especificación de anfitrión"

#: pathname.d:2158
#, lisp-format
msgid "~S: endless loop while resolving ~S"
msgstr "~S: bucle infinito para ~S"

#: pathname.d:2185
#, lisp-format
msgid "~S: unknown logical host ~S in ~S"
msgstr "~S: anfitrión ~S desconocido en ~S"

#: pathname.d:2197
#, lisp-format
msgid "~S: No replacement rule for ~S is known."
msgstr "~S: No se conoce ninguna regla de sustitución para ~S."

#: pathname.d:2494
#, lisp-format
msgid "~S: :VERSION-argument should be NIL or a positive fixnum or :WILD or :NEWEST, not ~S"
msgstr "~S: el argumento :VERSION debe ser NIL, un número positivo del tipo fixnum, :WILD o :NEWEST pero no ~S"

#: pathname.d:2562
#, lisp-format
msgid "The value of ~S was not a pathname. ~:*~S is being reset."
msgstr "El valor de ~S no es del tipo PATHNAME. ~:*~S se reinicializará."

#: pathname.d:3281
#, lisp-format
msgid "~S: on host ~S, device ~S is invalid, should be NIL"
msgstr "~S: en el anfitrión ~S, dispositivo ~S no es válido, debería ser NIL"

# Duda: Wildcard por comodín, ..., está bien, ¿no?
#
#: pathname.d:3678
#, lisp-format
msgid "~S: wildcards are not allowed here: ~S"
msgstr "~s: los comodines no están permitidos aquí: ~S"

#: pathname.d:3713
#, lisp-format
msgid "~S: argument ~S should be ~S, ~S, ~S, ~S, ~S, ~S or ~S"
msgstr "~S: un argumento ~S debería ser ~S, ~S, ~S, ~S, ~S, ~S o ~S"

#: pathname.d:4586
#, lisp-format
msgid "~S: replacement pieces ~S do not fit into ~S"
msgstr "~S: las piezas de intercambio ~S no caben en ~S"

#: pathname.d:4667
#, lisp-format
msgid "~S: ~S is not a specialization of ~S"
msgstr "~S: ~S no es una especialización de ~S"

#: pathname.d:4721
#, lisp-format
msgid "(~S ~S ~S ~S) is ambiguous: ~S"
msgstr "(~S ~S ~S ~S) es ambiguo: ~S"

#: pathname.d:4757
#, lisp-format
msgid "~S: Directory ~S does not exist"
msgstr "~S: El directorio ~S no existe"

#: pathname.d:4766 runprog.lisp:162
#, lisp-format
msgid "~S: File ~S already exists"
msgstr "~S: El fichero ~S ya existe"

#: pathname.d:4774
#, lisp-format
msgid "~S: ~S names a directory, not a file"
msgstr "~S: ~S es el nombre de un directorio, no de un fichero"

#: pathname.d:4980
#, lisp-format
msgid "no directory ~S above ~S"
msgstr "no existe el directorio ~S bajo ~S"

#: pathname.d:4987
#, lisp-format
msgid "\"..\\\\\" after \"...\\\\\" is invalid: ~S"
msgstr "\"..\\\\\" después de \"...\\\\\" no es válido: ~S"

# Casi lo mismo. Bueno, al menos aquí hay dos puntos. sv
#
# Tienes razón. Ahora que veo este mensaje me lío a poner dos puntos en
# los mensajes anteriores. cll
#
#: pathname.d:5270
#, lisp-format
msgid "UNIX error while GETWD: ~S"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~S"

# Si la tildecilla se sustituye por aquello que devolvió la orden GETWD,
# la frase resultante no tiene mucho sentido.
# Sugerencia: "La ejecución de GETWD en Unix devolvió ~S" sv
#
# Hmmm, ..., podría ser, pero verás: en primer lugar, el texto que est
# asociado con la etiqueta "UNIX GETWD returned ~S" es "UNIX error while
# GETWD" (fichero pathname.d, línea 6176); segundo, en CLisp se sigue la
# convención de colocar primero un mensaje y después, al final, aquello
# que originó el mensaje y, francamente, no quiero cambiar esta
# convención. Es decir, no quiero faltar al estilo original de los
# autores del programa. cll
#
# Por este motivo, creo que lo más conveniente es dejarlo como está. cll
#
#: pathname.d:5277
#, lisp-format
msgid "UNIX GETWD returned ~S"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~S"

# Lo mismo. sv
#
# Lo mismo también ;) cll
#
#: pathname.d:5443
#, lisp-format
msgid "UNIX REALPATH returned ~S"
msgstr "Se produjo un error UNIX durante la ejecución de REALPATH: ~S"

#: pathname.d:5564
#, lisp-format
msgid "~S: No file name given: ~S"
msgstr "~S: no se ha entregado ningún nombre de fichero: ~S"

#: pathname.d:5575
#, lisp-format
msgid "~S: Not a directory: ~S"
msgstr "~S: no un directorio: ~S"

#: pathname.d:5619
#, lisp-format
msgid "~S: File ~S does not exist"
msgstr "~S: El fichero ~S no existente"

#: pathname.d:5652
#, lisp-format
msgid "~S: pathname with type but without name makes no sense: ~S"
msgstr "~S: un PATHNAME con tipo, pero sin nombre, no tiene ningún sentido: ~S"

#: pathname.d:6018
#, lisp-format
msgid "~S: Cannot delete file ~S since there is a file stream open to it"
msgstr "~S: No se puede eliminar el fichero ~S puesto que hay un fichero del flujo abierto sobre él"

#: pathname.d:6062
#, lisp-format
msgid "~S: Cannot rename file ~S since there is a file stream open to it"
msgstr "~S: no se puede renombrar un fichero ~S desde que hay un flujo de fichero abierto para él"

#: pathname.d:6464
#, lisp-format
msgid "~S: ~S already points to file ~S, opening the file again for ~S may produce unexpected results"
msgstr "~S: ~S ya apunta al fichero ~S, abriendo el fichero de nuevo para ~S puede devolver resultados inesperados"

#: pathname.d:6476
msgid "Open the file anyway"
msgstr "Abra el fichero de todas formas"

#: pathname.d:6494
#, lisp-format
msgid "~S: The value of ~S should be one of ~S, ~S, ~S, or ~S, not ~S. It has been changed to ~S."
msgstr "~S: El valor de ~S debería ser uno de ~S, ~S, ~S o ~S, no ~S. Ha sido cambiado a ~S."

#: pathname.d:7740
#, lisp-format
msgid "root directory not allowed here: ~S"
msgstr "el directorio raíz no está permitido aquí: ~S"

# Duda: ¿Creando *el* directorio? ¿Creando *un* directorio? De momento,
# simplemente "Creando directorio" - cll
#
#: pathname.d:7841
msgid "Creating directory: "
msgstr "Creando directorio: "

#: pathname.d:8836
#, lisp-format
msgid "~S: There are multiple running threads. Currently they do not survive image saving/loading."
msgstr "~S: Hay múltiples hilos de ejecución. Actualmente no conserva imagen de guarda/carga."

#: pathname.d:8849
#, lisp-format
msgid "~S: Mutex ~S is locked by thread ~S. Currently locked mutexes are not allowed in memory files."
msgstr "~S: El mutex ~S esta bloqueado por el hilo ~S. Actualmente los mutexes bloqueados no están permitidos en los ficheros de memoria."

#: pathname.d:8901
msgid "Loading module~P ~{~A~^, ~} from ~A"
msgstr "Cargando módulo~P ~{~A~^, ~} desde ~A"

#: pathname.d:8929
msgid "Loaded module~P ~{~A~^, ~} from ~A"
msgstr "Cargado módulo~P ~{~A~^, ~} desde ~A"

#: pathname.d:8955
#, lisp-format
msgid "~S: installation directory is not known, use the -B command line option to specify it or set *LIB-DIRECTORY*"
msgstr "~S: directorio de instalación no está conocido, emplee la opción de línea de órdenes -B para especificación o establecer  *LIB-DIRECTORY*"

# Duda: En este mensaje, el primer "~S" se sustituye por el nombre de una
# función y el segundo "~S" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: stream.d:274 stream.d:13965
#, lisp-format
msgid "~S on ~S is illegal"
msgstr "~S no es posible sobre el flujo ~S"

# "~S:argumento de ~S debe ser un entero comprendido entre 2 y 36, no ~S" - lsg
#
# Algo parecido he puesto yo - cll
#
#: stream.d:611
#, lisp-format
msgid "Return value ~S of call to ~S should be an integer between ~S and ~S."
msgstr "Valor ~S de retorno de la llamada para ~S debería ser un entero entre ~S y ~S."

#: stream.d:778
#, lisp-format
msgid "~S: the last character read from ~S was not ~S"
msgstr "~S: el último carácter leído de ~S no era ~S"

# Duda: A continuación vienen muchos mensajes que empiezan por "~S from
# ~S". Para ayudar en su trabajo a quienes estén revisando este trabajo
# (no me canso de darte las gracias, Santiago, ..., y a quienes se
# animen) aclaro que el primer "~S" se sustituye por el nombre de una
# función cuya evaluación (o ejecución, pero esto no es correcto en
# Lisp, ... se prefiere el término evaluación porque se está a nivel de
# intérprete) produce el error; el segundo "~S" se refiere al nombre del
# flujo desde el cual se leyó dicha función. Luego, a continuación,
# viene el mensaje de error propiamente dicho.
#
# Por ejemplo, la siguiente instrucción en CLisp:
#
# > (read)
#
# ..., si se teclea:
#
# #<...>
#
# ..., produce el siguiente error: (en español, ya traducido)
#
# *** - READ en #<TERMINAL-STREAM>: los objetos escritos de la manera
# #<...> no pueden volverse a leer
#
# ¿De acuerdo?
#
# A continuación reproduzco un par de mails donde se explica el
# mecanismo general de estos mensajes, a propósito de la pregunta que
# puse en la lista de correo de CLisp:
#
# Mi pregunta fue:
#
# > 21. There are a few messages which begin with "~S from ~S". They are
# > very easy to translate but they use a lot of prepositions, and words
# > that could be translated in masculine or feminine. So, I need some
# > real examples of their use.
#
# Las respuestas fueron:
#
#
# ---------------------------------------------------------------------------
# Look in io.d:
#     { pushSTACK(*stream_); # Wert fu:r Slot STREAM von STREAM-ERROR
#       pushSTACK(ch); # Character
#       pushSTACK(*stream_); # Stream
#       pushSTACK(S(read));
#       //: DEUTSCH "~S von ~S: Gelesenes Zeichen ist kein String-Char: ~S"
#       //: ENGLISH "~S from ~S: character read should be a string-char: ~S"
#       //: FRANCAIS "~S de ~S : le caracte!re lu n'est pas de type STRING-CHAR."
# The first ~S is the function name, the second the stream that was being
# read from or written to and the third is the character that was read/written.
#
# So it says something like "READ from #<STREAM ...>: illegal character"
#
# 						(Joerg Hoehle)
#
# ---------------------------------------------------------------------------
# A general question here: I thought gettext was coming with an Emacs
# mode called "po-mode", which helps you in translating the messages.
# In particular, there are keystroke commands for showing the C/Lisp source
# surrounding the original reference to a message. From this context,
# you should at least be able to guess the meaning of the objects which
# are substituted for the ~S. Note, however, that the first ~S corresponds
# the last pushSTACK command before the string, the second ~S to the
# second-to-last pushSTACK command etc.
#
# 						(Bruno Haible)
#
# ---------------------------------------------------------------------------
#
#: stream.d:784
#, lisp-format
msgid "~S from ~S without ~S before it"
msgstr "~S desde ~S sin ~S antes de él"

#: stream.d:1135
#, lisp-format
msgid "~S: cannot output to ~S"
msgstr "~S: no se puede devolver en ~S"

#: stream.d:1145
#, lisp-format
msgid "~S: cannot output ~S into ~S, not of type ~S"
msgstr "~S: no se puede devolver ~S dentro de ~S, tipo distinto de ~S"

#: stream.d:1171
#, lisp-format
msgid "integer ~S is out of range, cannot be output onto ~S"
msgstr "el entero ~S está fuera del dominio, no puede imprimirse en ~S"

#: stream.d:1185
#, lisp-format
msgid "~S: argument ~S is not a stream of type ~S"
msgstr "~S: un argumento ~S no es un flujo del tipo ~S"

#: stream.d:1243
#, lisp-format
msgid "~S: argument ~S should be an input stream"
msgstr "~S: un argumento ~S debería ser un flujo de entrada"

#: stream.d:1255
#, lisp-format
msgid "~S: argument ~S should be an output stream"
msgstr "~S: un argumento ~S debería ser un flujo de salida"

#: stream.d:1545
#, lisp-format
msgid "~S: argument should be a symbol, not ~S"
msgstr "~S: un argumento debería ser un símbolo, no ~S"

#: stream.d:2388 stream.d:2870
#, lisp-format
msgid "~S is beyond the end because the string ~S has been adjusted"
msgstr "~S está más allá del final porque la cadena ~S ha sido ajustada"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2499
#, lisp-format
msgid "~S: ~S is not a string input stream"
msgstr "~S: ~S no es un flujo de entrada de cadenas"

#: stream.d:2571 charstrg.d:3153
#, lisp-format
msgid "~S: ~S argument must be a subtype of ~S, not ~S"
msgstr "~S: argumento ~S debe ser un subtipo de ~S, no ~S"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2626
#, lisp-format
msgid "~S: ~S is not a string output stream"
msgstr "~S: ~S no es una cadena de flujo de salida"

# Duda: He traducido `fill pointer' por "puntero de relleno". En
# realidad, los `fill-pointer' son exactamente, eso:
#
# "The fill pointer constitutes the "active length" of the vector; all
# vector elements whose index is less than the fill pointer are active,
# and the others are inactive." (Guy L. Steele, Jr; Common Lisp, The
# Language - 2nd Edition; pag. 454).
#
#: stream.d:2660
#, lisp-format
msgid "~S: argument ~S should be a string with fill pointer"
msgstr "~S: un argumento ~S debería ser una cadena con un puntero de relleno"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2711
#, lisp-format
msgid "~S: ~S is not a string stream"
msgstr "~S: ~S no es un flujo de cadena"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2958
#, lisp-format
msgid "~S: ~S is not a buffered input stream"
msgstr "~S: ~S no es un flujo de entrada con buffer"

#: stream.d:3955
#, lisp-format
msgid "~S: Ctrl-C: User break"
msgstr "~S: Ctrl-C: Interrupción del usuario"

#: stream.d:4035
#, lisp-format
msgid "unknown character set ~S"
msgstr "conjunto de carácter desconocido ~S"

#: stream.d:5892
#, lisp-format
msgid "Unbuffered streams need an ~S with a bit size being a multiple of 8, not ~S"
msgstr "Flujo sin búfer necesita un ~S con un tamaño de bit que sea un múltiplo de 8, no ~S"

#: stream.d:6254
#, lisp-format
msgid "Closed ~S because disk is full."
msgstr "Se ha cerrado ~S porque el disco está lleno."

#: stream.d:6388
#, lisp-format
msgid "cannot position ~S beyond EOF"
msgstr "no es posible colocarse en ~S más allá de EOF"

# Duda: lo del fichero `regular' por `normal'. De hecho, yo juraría que
# en la asignatura de Sistemas Operativos, en mi Facultad, los
# llamábamos "ficheros normales". ¿Qué tal os suena?.
#
#: stream.d:8102
#, lisp-format
msgid "~S: argument ~S ~S was specified, but ~S is not a regular file."
msgstr "~S: un argumento ~S ~S fue especificado, pero ~S no es un fichero corriente."

#: stream.d:8134
#, lisp-format
msgid "~S: arguments ~S ~S and ~S ~S were specified, but ~S is not a regular file."
msgstr "~S: ~S argumentos ~S y ~S ~S fueron especificados, pero ~S no es un fichero común."

# Duda: aqui he traducido de la version francesa (no se frances, pero
# por lo que parece que pone, ...)
#
#: stream.d:8197
#, lisp-format
msgid "file ~S is not an integer file"
msgstr "el fichero ~S no tiene el formato de un fichero de enteros"

#: stream.d:9310
#, lisp-format
msgid "Return value ~S of call to ~S is not a list."
msgstr "Valor ~S de retorno de la llamada para ~S no es una lista."

#: stream.d:9331
#, lisp-format
msgid "Return value ~S of call to ~S contains ~S which is not a ~S."
msgstr "Valor ~S de retorno de la llamada para ~S conteniendo ~S el cual no es un ~S."

#: stream.d:10401
#, lisp-format
msgid "~S: argument ~S should be a window stream"
msgstr "~S: un argumento ~S debería ser un WINDOW-STREAM"

#: stream.d:10951
msgid "cannot output to standard output"
msgstr "no se puede escribir en la salida estándar"

#: stream.d:12150
msgid "environment has no TERM variable"
msgstr "no existe ninguna variable de entorno TERM"

#: stream.d:12155
#, lisp-format
msgid "terminal type ~S unknown to termcap"
msgstr "No existe ninguna entrada para el tipo de terminal ~S en termcap"

# Duda: Juan Jordana (de la lista de CLisp) propone usar la expresión:
#
# 	Terminal incompleta (o errónea): Terminal de impresora.
#
# 	y me gusta, salvo que prefiero decir a continuación algo del
# 	tipo "usando el modo de impresora" o algo así, ¿no os parece
# 	mejor?
#
#: stream.d:12168
msgid "insufficient terminal: hardcopy terminal"
msgstr "terminal insuficiente: terminal de copia impresa"

# Duda: ¿Pues qué voy a decir? La traducción siguiente es una auténtica
# traducción libre. De todos modos, tanto la versión francesa como la
# alemana (aunque no sé ni alemán ni francés) hacen ---por lo visto---,
# lo que yo: una traducción libre.
#
#: stream.d:12172
msgid "insufficient terminal: overstrikes, cannot clear output"
msgstr "terminal insuficiente: acuñaciones, se puede vaciar la salida"

#: stream.d:12176
msgid "insufficient terminal: cannot scroll"
msgstr "terminal insuficiente: no se puede desplazar la pantalla"

#: stream.d:12181
msgid "insufficient terminal: cannot clear screen"
msgstr "terminal insuficiente: no se puede vaciar la pantalla"

#: stream.d:12185
msgid "insufficient terminal: cannot position cursor randomly"
msgstr "terminal insuficiente: no se puede situar el cursor aleatoriamente"

# Duda: he dejado `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: stream.d:13677
#, lisp-format
msgid "host should be string, not ~S"
msgstr "el anfitrión debe ser una cadena de caracteres y no ~S"

# Duda: Pues otra vez como siempre, ..., he dejado `display' tal
# cual. Pienso que todo el mundo sabe lo que es un `display' ¿no?
#
# Por otra parte (como ya sucedió en un mensaje anterior), ..., `fixnum'
# por ser el nombre de un subtipo (o tipo, si se quiere) en Lisp, est
# sin traducir, ...
#
#: stream.d:13684
#, lisp-format
msgid "display should be a small nonnegative integer, not ~S"
msgstr "el `display' debe ser un entero no negativo, no ~S"

#: stream.d:13755 io.d:935
#, lisp-format
msgid "~S: input stream ~S has reached its end"
msgstr "~S: el flujo de entrada ~S ha alcanzado su final"

#: stream.d:13960 record.d:217 record.d:592 record.d:753 record.d:794 record.d:850 weak.d:40 weak.d:130 weak.d:248 weak.d:314 weak.d:372 weak.d:473 weak.d:575 weak.d:722 sequence.d:330 error.d:939 error.d:941 error.d:1147
#, lisp-format
msgid "~S: ~S is not a ~S"
msgstr "~S: ~S no es un ~S"

#: stream.d:14009
#, lisp-format
msgid "~S: argument ~S is not an open SOCKET-STREAM"
msgstr "~S: un argumento ~S no es un SOCKET-STREAM abierto"

#: stream.d:14020
#, lisp-format
msgid "~S: argument ~S is not a SOCKET-STREAM"
msgstr "~S: un argumento ~S no es un SOCKET-STREAM"

#: stream.d:14034
msgid "WARNING: (socket-server <socket>) is deprecated, use (socket-server <port> :interface <socket>)"
msgstr "ADVERTENCIA: (socket-server <socket>) es obsoleto, utilice (socket-server <puerto> :interfaz <socket>)"

#: stream.d:14286
#, lisp-format
msgid "~S: argument ~S is not an open stream"
msgstr "~S: un argumento ~S no es un flujo abierto"

#: stream.d:14513
#, lisp-format
msgid "~S: list ~S is too long (~S maximum)"
msgstr "~S: la lista ~S es demasiado larga (~S máxima)"

#: stream.d:14743
#, lisp-format
msgid "~S: argument ~S should be of type ~S."
msgstr "~S: un argumento ~S debería ser de tipo ~S."

#: stream.d:15067
#, lisp-format
msgid "Invalid direction ~S for accessing ~S"
msgstr "Dirección no válida ~S para acceso a ~S"

#: stream.d:15103
#, lisp-format
msgid "~S: ~S should be a handle, handle stream, or one of ~S, ~S, ~S"
msgstr "~S: ~S debería ser un manipulador, flujo de manipulación, o uno de ~S, ~S, ~S"

#: stream.d:15407
#, lisp-format
msgid "~S: The value of ~S is not a stream: ~S"
msgstr "~S: El valor de ~S no es un flujo: ~S"

#: stream.d:15409
#, lisp-format
msgid "~S: The value of ~S is not an appropriate stream: ~S"
msgstr "~S: El valor de ~S no es un flujo apropiado: ~S"

#: stream.d:15422
#, lisp-format
msgid "~S: The value of ~S was not an appropriate stream: ~S. It has been changed to ~S."
msgstr "~S: El valor de ~S no era un flujo apropiado: ~S. Ha sido cambiado a ~S."

#: stream.d:15435
msgid "readline library: out of memory."
msgstr "biblioteca «readline»: memoria agotada."

#: stream.d:15750
#, lisp-format
msgid "~S: The ~S of ~S cannot be changed from ~S to ~S."
msgstr "~S: El ~S de ~S no puede convertirse desde ~S hasta ~S."

#: stream.d:16344
#, lisp-format
msgid "Return value ~S of call to ~S is not a string."
msgstr "Valor ~S de retorno de la llamada para ~S no es una cadena."

#: stream.d:16852
#, lisp-format
msgid "Return value ~S of call to ~S is not a fixnum >= 0 or NIL."
msgstr "Valor ~S de retorno de la llamada para ~S no es un número fijo >= 0 o NIL."

#: stream.d:17013
#, lisp-format
msgid "~S needs an ~S with a bit size being a multiple of 8, not ~S"
msgstr "~S necesita un ~S con un tamaño de bit que sea un múltiplo de 8, no ~S"

#: stream.d:17061
#, lisp-format
msgid "~S: illegal endianness argument ~S"
msgstr "~S: endianness de argumento ~S no legal"

#: stream.d:17194
#, lisp-format
msgid "~S: argument ~S does not contain a valid OS stream handle"
msgstr "~S: un argumento ~S no contiene un flujo válido de manipulación de SO"

#: stream.d:17195
#, lisp-format
msgid "~S: ~S: buffered pipe-input-streams are not supported"
msgstr "~S: ~S: pipe-input-streams con búfer no son compatibles"

#: stream.d:17196
#, lisp-format
msgid "~S: ~S: stream of wrong direction"
msgstr "~S: ~S: flujo de dirección equivocada"

#: stream.d:17406 stream.d:17416
#, lisp-format
msgid "~S is not a ~S, cannot be output onto ~S"
msgstr "~S no es un ~S, no puede ser emitida en ~S"

#: stream.d:17491
#, lisp-format
msgid "~S: argument ~S is not an open file stream"
msgstr "~S: un argumento ~S no es el flujo de un fichero abierto"

#: stream.d:17549
#, lisp-format
msgid "~S: position argument should be ~S or ~S or a nonnegative integer, not ~S"
msgstr "~S: argumento de posición debería ser ~S o ~S o un entero no negativo, no ~S"

#: socket.d:347
#, lisp-format
msgid "~S: IP address ~S must have length ~S or ~S"
msgstr "~S: argumento IP ~S debe tener de longitud ~S o ~S"

#
# "~S: los elementos de la formación ~S no son de tipo ~S" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#: socket.d:349
#, lisp-format
msgid "~S: IP address ~S must have length ~S"
msgstr "~S: direcciones IP ~S deben tener la longitud ~S"

#: io.d:464
#, lisp-format
msgid "The value of ~S was not a readtable. It has been reset."
msgstr "El valor de ~S no es una tabla de lectura. Ha sido inicializado/a."

#: io.d:550 error.d:1292
#, lisp-format
msgid "~S: argument ~S is not a ~S"
msgstr "~S: un argumento ~S no es un ~S"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
# Al final, por iniciativa de Leo, he cambiado `# macro carácter', que
# no me gustaba demasiado por `macro carácter secundario', que me parece
# mucho mejor. - cll
#
#: io.d:704
#, lisp-format
msgid "~S: ~S is a dispatch macro character"
msgstr "~S: ~S es un macro carácter secundario"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:756
#, lisp-format
msgid "~S: ~S is not a dispatch macro character"
msgstr "~S: ~S no es un macro carácter secundario"

#: io.d:780
#, lisp-format
msgid "~S: digit ~C not allowed as sub-char"
msgstr "~S: el dígito ~C no está permitido como un sub-carácter"

#: io.d:827
#, lisp-format
msgid "~S: new value ~S should be ~S, ~S, ~S or ~S."
msgstr "~S: el nuevo valor ~S debe ser ~S, ~S, ~S o ~S."

#: io.d:859
#, lisp-format
msgid ""
"The value of ~S should be an integer between 2 and 36, not ~S.\n"
"It has been reset to 10."
msgstr ""
"El valor de ~S debe ser un entero entre 2 y 36, no ~S.\n"
"Ha sido inicializado a 10."

#: io.d:905 defs2.lisp:179
#, lisp-format
msgid "~S from ~S: character read should be a character: ~S"
msgstr "~S desde ~S: carácter leído debería ser un carácter: ~S"

#: io.d:947
#, lisp-format
msgid "~S: input stream ~S ends within an object. Last opening parenthesis probably in line ~S."
msgstr "~S: el flujo de entrada ~S ha terminado mientras se procesaba un objeto. El último paréntesis abierto es, probablemente, el de la línea ~S."

#: io.d:951
#, lisp-format
msgid "~S: input stream ~S ends within an object"
msgstr "~S: el flujo de entrada ~S ha terminado mientras se procesaba un objeto"

#: io.d:1214
#, lisp-format
msgid "~S from ~S: illegal character ~S"
msgstr "~S desde ~S: carácter no válido ~S"

#
# Duda: Lo mismo de antes, he dejado `token' sin traducir
#
#: io.d:1224
#, lisp-format
msgid "~S: input stream ~S ends within a token after single escape character"
msgstr "~S: el flujo de entrada ~S termina con un `token' después de un carácter de escape simple"

#
# Duda: A ver, ¿la palabra `token'?
#       Mientras no se os ocurra algo mejor, lo he dejado en inglés, ...
#
#: io.d:1270
#, lisp-format
msgid "~S: input stream ~S ends within a token after multiple escape character"
msgstr "~S: el flujo de entrada ~S termina con un `token' después de un carácter de escape múltiple"

#: io.d:1791
#, lisp-format
msgid "~S from ~S: ~S has no macro character definition"
msgstr "~S desde ~S: ~S no tiene ninguna definición de macro carácter"

#: io.d:1803
#, lisp-format
msgid "~S from ~S: macro character definition for ~S may not return ~S values, only one value."
msgstr "~S desde ~S: la definición del macro carácter para ~S no puede devolver ~S valores, sólo puede ser uno."

#: io.d:1824 defs2.lisp:173
#, lisp-format
msgid "~S: input stream ~S ends within read macro beginning with ~S"
msgstr "~S: un flujo de entrada ~S termina dentro del inicio de una macro de lectura con ~S"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:1856 defs2.lisp:200
#, lisp-format
msgid "~S from ~S: After ~S is ~S an undefined dispatch macro character"
msgstr "~S desde ~S: después de ~S está ~S, que no es una macro carácter secundario"

#: io.d:1868
#, lisp-format
msgid "~S from ~S: dispatch macro character definition for ~S after ~S may not return ~S values, only one value."
msgstr "~S desde ~S: la definición del macro carácter secundario de ~S después de ~S sólo puede devolver un valor, no ~S"

# Duda: He traducido `token' tal cual, ... Santiago, imagino que la
# palabra token se queda tal cual. Quiero decir, ¿es necesario lo de las
# comillas? - cll
#
#: io.d:1934
#, lisp-format
msgid "~S from ~S: a token consisting only of dots cannot be meaningfully read in"
msgstr "~S desde ~S: no puede leerse correctamente un `token' que consiste únicamente en puntos"

# Duda: Todo el mundo sabe que `colon' es el signo de dos puntos
# `:'. Bueno, pues la traducción del siguiente mensaje podría ser algo
# del estilo: "demasiados signos de dos puntos en el token ...", sin
# embargo, me ha parecido mejor poner los dos puntos directamente, ...
#
#: io.d:2047
#, lisp-format
msgid "~S from ~S: too many colons in token ~S"
msgstr "~S desde ~S: demasiados `:' en el `token' ~S"

#: io.d:2054
#, lisp-format
msgid "~S from ~S: token ~S contains an invalid constituent character (see ANSI CL 2.1.4.2.)"
msgstr "~S desde ~S: etiqueta ~S contiene un carácter constitutivo no válido (vea ANSI CL 2.1.4.2.)"

#: io.d:2103
#, lisp-format
msgid "~S from ~S: there is no package with name ~S"
msgstr "~S desde ~S: no existe ningún paquete con el nombre ~S"

#: io.d:2129
#, lisp-format
msgid "~S from ~S: ~S has no external symbol with name ~S"
msgstr "~S desde ~S: ~S no tiene ningún símbolo externo con el nombre ~S"

#: io.d:2168
#, lisp-format
msgid "~S from ~S: token \".\" not allowed here"
msgstr "~S desde ~S: el `token' \".\" no está permitido aquí"

#: io.d:2194
#, lisp-format
msgid "~S: the value of ~S has been arbitrarily altered to ~S"
msgstr "~S: el valor de ~S ha sido alterado arbitrariamente a ~S"

#: io.d:2202
#, lisp-format
msgid "~S: symbol ~S is not bound, it appears that top-level ~S was called with a non-NIL recursive-p argument"
msgstr "~S: símbolo ~S no está reservado, aparece que el nivel máximo ~S ha sido llamado con un argumento recursivo-p no NIL"

#: io.d:2238
#, lisp-format
msgid "~S: no entry for ~S from ~S in ~S = ~S"
msgstr "~S: no existe ninguna entrada para ~S de ~S desde ~S = ~S"

#: io.d:2449
#, lisp-format
msgid "~S from ~S: illegal end of dotted list"
msgstr "~S desde ~S: fin de lista punteada no válido"

#: io.d:2517
#, lisp-format
msgid "~S from ~S: an object cannot start with ~S"
msgstr "~S desde ~S: un objeto no puede comenzar por ~S"

#: io.d:2634
#, lisp-format
msgid "~S: input stream ~S ends within a string"
msgstr "~S: el flujo de entrada ~S termina con una cadena"

#: io.d:2697
#, lisp-format
msgid "~S from ~S: no number allowed between # and ~C"
msgstr "~S desde ~S: ningún número permitido entre # y ~C"

#: io.d:2786
#, lisp-format
msgid "~S: input stream ~S ends within a comment #~C ... ~C#"
msgstr "~S: el flujo de entrada ~S termina dentro un comentario #~C ... ~C#"

#: io.d:2854
#, lisp-format
msgid "~S from ~S: font number ~S for character is too large, should be = 0"
msgstr "~S desde ~S: el número ~S para el tipograma de caracteres es demasiado grande, debería ser = 0"

#: io.d:2919
#, lisp-format
msgid "~S from ~S: there is no character with name ~S"
msgstr "~S desde ~S: no hay ningún carácter con el nombre ~S"

#: io.d:2975
#, lisp-format
msgid "~S from ~S: token ~S after #~C is not a rational number in base ~S"
msgstr "~S desde ~S: el `token' ~S después de #~C no es un número racional en base ~S"

#: io.d:3041
#, lisp-format
msgid "~S from ~S: the number base must be given between # and R"
msgstr "~S desde ~S: el número de la base debe estar entre # y R"

#: io.d:3054
#, lisp-format
msgid "~S from ~S: The base ~S given between # and R should lie between 2 and 36"
msgstr "~S desde ~S: La base ~S entre # y R debe estar entre 2 y 36"

#: io.d:3099
#, lisp-format
msgid "~S from ~S: bad syntax for complex number: #C~S"
msgstr "~S desde ~S: sintaxis equivocada del número complejo: #C~S"

#: io.d:3129
#, lisp-format
msgid "~S from ~S: token expected after #:"
msgstr "~S desde ~S: se esperaba un `token' después de #:"

#: io.d:3157
#, lisp-format
msgid "~S from ~S: token ~S after #: should contain no colon"
msgstr "~S desde ~S: el `token' ~S después de #: no debe contener dos puntos"

#: io.d:3182
#, lisp-format
msgid "~S from ~S: ~S is longer than the explicitly given length ~S"
msgstr "~S desde ~S: ~S tiene una longitud mayor que la explícitamente indicada ~S"

#: io.d:3191
#, lisp-format
msgid "~S from ~S: must specify elements of ~S of length ~S"
msgstr "~S desde ~S: debe especificar elementos de ~S de longitud ~S"

#: io.d:3201
#, lisp-format
msgid "~S from ~S: invalid ~S length ~S"
msgstr "~S desde ~S: ~S no válido de longitud ~S"

#: io.d:3251
#, lisp-format
msgid "~S from ~S: only zeroes and ones are allowed after #*"
msgstr "~S desde ~S: sólo se permiten ceros y unos después de #*"

#: io.d:3398
#, lisp-format
msgid "~S from ~S: bad syntax for array: #A~S"
msgstr "~S desde ~S: sintaxis equivocada en la matriz: #A~S"

#: io.d:3462
#, lisp-format
msgid "~S from ~S: ~S = ~S does not allow the evaluation of ~S"
msgstr "~S desde ~S: ~S = ~S no permite la evaluación de ~S"

#: io.d:3577
#, lisp-format
msgid "~S from ~S: a number must be given between # and ~C"
msgstr "~S desde ~S: un número debe darse entre # y ~C"

#: io.d:3626
#, lisp-format
msgid "~S from ~S: label #~S= may not be defined twice"
msgstr "~S desde ~S: la etiqueta #~S= no puede definirse dos veces"

#: io.d:3653
#, lisp-format
msgid "~S from ~S: #~S= #~S# is illegal"
msgstr "~S desde ~S: #~S= #~S# no está permitido"

#: io.d:3677
#, lisp-format
msgid "~S from ~S: undefined label #~S#"
msgstr "~S desde ~S: la etiqueta #~S# no está definida"

#: io.d:3691
#, lisp-format
msgid "~S from ~S: objects printed as #<...> cannot be read back in"
msgstr "~S desde ~S: los objetos escritos de la manera #<...> no pueden volverse a leer"

#: io.d:3706
#, lisp-format
msgid "~S from ~S: objects printed as # in view of ~S cannot be read back in"
msgstr "~S desde ~S: los objetos escritos como # a causa de ~S no pueden volverse a leer"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#: io.d:3736
#, lisp-format
msgid "~S from ~S: illegal feature ~S"
msgstr "~S desde ~S: propiedad no válida ~S"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#: io.d:3740
#, lisp-format
msgid "~S: illegal feature ~S"
msgstr "~S: característica ilegal ~S"

#: io.d:3908
#, lisp-format
msgid "~S from ~S: #S must be followed by the type and the contents of the structure, not ~S"
msgstr "~S desde ~S: #S debe estar seguido del tipo y contenidos de la estructura, no ~S"

#: io.d:3919
#, lisp-format
msgid "~S from ~S: the type of a structure should be a symbol, not ~S"
msgstr "~S desde ~S: el tipo de una estructura debe ser un símbolo, no ~S"

#: io.d:3930 io.d:3994
#, lisp-format
msgid "~S from ~S: bad ~S"
msgstr "~S desde ~S: ~S equivocado"

#: io.d:3970
#, lisp-format
msgid "~S from ~S: bad ~S (not enough fields)"
msgstr "~S desde ~S: ~S equivocado (campos no suficientes)"

#: io.d:3977
#, lisp-format
msgid "~S from ~S: bad ~S (extra fields: ~S"
msgstr "~S desde ~S: ~S equivocado (campos adicionales: ~S"

#: io.d:4043
#, lisp-format
msgid "~S from ~S: bad ~S for ~S"
msgstr "~S desde ~S: ~S equivocado en ~S"

#: io.d:4053
#, lisp-format
msgid "~S from ~S: no structure of type ~S has been defined"
msgstr "~S desde ~S: no se ha definido ninguna estructura del tipo ~S"

#: io.d:4062
#, lisp-format
msgid "~S from ~S: structures of type ~S cannot be read in, missing constructor function"
msgstr "~S desde ~S: las estructuras del tipo ~S no pueden leerse, no se conoce la función de construcción"

#: io.d:4083
#, lisp-format
msgid "~S from ~S: a structure ~S may not contain a component \".\""
msgstr "~S desde ~S: una estructura ~S no debe contener un componente \".\""

#: io.d:4094
#, lisp-format
msgid "~S from ~S: ~S is not a symbol, not a slot name of structure ~S"
msgstr "~S desde ~S: ~S no es un símbolo, ni el nombre de una ranura ni una estructura ~S"

#: io.d:4103
#, lisp-format
msgid "~S from ~S: missing value of slot ~S in structure ~S"
msgstr "~S desde ~S: falta el valor de la ranura ~S en la estructura ~S"

#
# Duda: slots se queda tal cual, ...
#
# De acuerdo con la lista spanglish, `slot' se traducirá, en todo el
# CLisp, como "ranura".
#
#: io.d:4122
#, lisp-format
msgid "~S from ~S: too many slots for structure ~S"
msgstr "~S desde ~S: hay demasiadas ranuras en la estructura ~S"

#
# "~S en ~S: sintaxis inválida del vector de código de recinto tras #~SY" - lsg
#
# Hmmm, no me acaba de gustar, ... - cll
#
#: io.d:4160
#, lisp-format
msgid "~S from ~S: illegal syntax of closure code vector after #~SY"
msgstr "~S desde ~S: sintaxis no válida del vector de código de la cerradura después de #~SY"

#: io.d:4218
#, lisp-format
msgid "~S from ~S: object #Y~S has not the syntax of a compiled closure"
msgstr "~S desde ~S: el objeto #Y~S no tiene la sintaxis de una cerradura compilada"

#: io.d:4248
#, lisp-format
msgid "~S from ~S: invalid code vector length ~S"
msgstr "~S desde ~S: longitud de vector de código no válido ~S"

#
# pathname NO es array!
# "~S en ~S: sintaxis incorrecta en nombre de path: #A~S" - lsg
#
# Si, es verdad, aquí se me había ido la mano, ...
#
# Además, PATHNAME no se traduce puesto que, o bien se refiere al tipo
# de datos PATHNAME o a la función PATHNAME (en este caso, al tipo de
# datos). Como ambos términos están definidos en el estándar de Common
# Lisp: Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr., pues
# no se traduce y se pone en mayúsculas para distinguirlo de otros
# términos. - cll
#
#: io.d:4366
#, lisp-format
msgid "~S from ~S: bad syntax for pathname: #P~S"
msgstr "~S desde ~S: sintaxis equivocada para PATHNAME: #P~S"

# Nota: El siguiente mensaje se debe a la función PEEK-CHAR (Common
# Lisp, The Language - 2nd Edition; Guy L. Steele, Jr; pag. 574), que
# realiza la lectura del siguiente objeto de un flujo de caracteres
# según el valor de su primer argumento opcional `peek-type' que solo
# puede valer, como reza el mensaje, NIL, T o un carácter.
#
#: io.d:4587
#, lisp-format
msgid "~S: peek type should be NIL or T or a character, not ~S"
msgstr "~S: el tipo del PEEK solo puede ser NIL, T o un carácter, y no ~S"

# "~S:argumento de ~S debe ser un entero comprendido entre 2 y 36, no ~S" - lsg
#
# Algo parecido he puesto yo - cll
#
#: io.d:4727
#, lisp-format
msgid "~S: ~S argument ~S is not an integer between 2 and 36"
msgstr "~S: ~S argumento ~S no es un enterio entre 2 y 36"

# "~S: la cadena ~S no tiene sintaxis de entero" - lsg
#
# He cambiado lo "de entero" por "de un número entero", que parece más
# inteligible - cll
#
#: io.d:4826
#, lisp-format
msgid "~S: substring ~S does not have integer syntax at position ~S"
msgstr "~S: la subcadena ~S no tiene la sintaxis de un número entero posicionado en ~S"

#: io.d:4974
#, lisp-format
msgid "~S: Despite ~S, ~S cannot be printed readably."
msgstr "~S: A pesar de ~S, ~S no puede ser enseñado de manera leíble."

#: io.d:5000
#, lisp-format
msgid ""
"~S: the value ~S of ~S is neither ~S nor ~S nor ~S.\n"
"It is reset to ~S."
msgstr ""
"~S: el valor de ~S de ~S no es ~S ni ~S ni ~S.\n"
"Restablecido a ~S."

#: io.d:5578
#, lisp-format
msgid "~S: must be a positive integer or NIL, not ~S"
msgstr "~S: debe ser un número positivo entero o NIL, pero no ~S"

# "~S: espacio insuficiente en la pila para realizar un análisis de circularidad" - lsg
#
# Vale - cll
#
#: io.d:6619
#, lisp-format
msgid "~S: not enough stack space for carrying out circularity analysis"
msgstr "~S: no hay espacio suficiente en la pila para realizar un análisis de circularidad"

#: io.d:8375
#, lisp-format
msgid "~S: bad class"
msgstr "~S: clase equivocada"

#: io.d:9498
#, lisp-format
msgid "~S: an unknown record type has been generated!"
msgstr "~S: se ha generado un tipo de registro desconocido!"

#: io.d:10039
#, lisp-format
msgid "~S: argument ~S is too large"
msgstr "~S: un argumento ~S es demasiado largo"

#: io.d:10061
#, lisp-format
msgid "~S: argument ~S should be ~S or ~S."
msgstr "~S: un argumento ~S debería ser ~S o ~S."

#: io.d:10102 weak.d:684
#, lisp-format
msgid "~S: argument ~S should be ~S, ~S, ~S or ~S."
msgstr "~S: un argumento ~S debería ser ~S, ~S, ~S o ~S."

#
# aLarge no es largo, sino grande!! - lsg
#
# Tienes toda la razón, ya lo he cambiado en todos los mensajes - cll
#
#: array.d:247
msgid "index too large"
msgstr "índice demasiado grande"

# FIXME. Esto no cabe en 80 columnas. Comunicar al autor (?) sv
#
# "Una formación ha sido acortada mediante un ajuste al trasladar otra formación hacia ella"
# O bien, para que quepa en 80 columnas:
# "Una formación ha sido acortada al trasladar otra formación hacia ella" - lsg
#
# Yo había puesto:
#
# "Una matriz ha sido acortada debido a un ajuste cuando otra se ha desplazado "
# "hacia ella"
#
# Y ciertamente me gusta más tu traducción, salvo que en vez de
# formaciones hay que hablar de matrices, ¿no crees? - cll
#
#: array.d:252
msgid "An array has been shortened by adjusting it while another array was displaced to it."
msgstr "Una matriz ha sido acortada al trasladar otra matriz ella"

#: array.d:355 foreign.d:2665
#, lisp-format
msgid "~S: got ~S subscripts, but ~S has rank ~S"
msgstr "~S: se encontraron ~S subíndices, pero ~S tiene rango ~S"

#: array.d:367 foreign.d:2680
#, lisp-format
msgid "~S: subscripts ~S for ~S are not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~S: los subíndices ~S de ~S no son del tipo '(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:388 foreign.d:2689
#, lisp-format
msgid "~S: subscripts ~S for ~S are out of range"
msgstr "~S: los subíndices ~S de ~S han excedido el rango"

#: array.d:445
#, lisp-format
msgid "~S: index ~S for ~S is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~S: el índice ~S de ~S no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:462
#, lisp-format
msgid "~S: index ~S for ~S is out of range"
msgstr "~S: el índice ~S de ~S ha excedido el rango"

#: array.d:509
#, lisp-format
msgid "~S: cannot retrieve values from an array of element type NIL"
msgstr "~S: no se puede obtener valores dentro de una matriz de elementos de tipo NIL"

#: array.d:515
#, lisp-format
msgid "~S: cannot store values in an array of element type NIL"
msgstr "~S: no puede almacenar valores dentro de una matriz de elementos de tipo NIL"

#: array.d:521
#, lisp-format
msgid "~S: cannot access values of an array of element type NIL"
msgstr "~S: no puede acceder valores de una matriz de elementos de tipo NIL"

#: array.d:566
#, lisp-format
msgid "~S: ~S does not fit into ~S, bad type"
msgstr "~S: ~S no cabe en ~S, tipo equivocado"

#: array.d:570
#, lisp-format
msgid "~S: ~S cannot be stored in an array of element type NIL"
msgstr "~S: ~S no puede ser almacenado dentro de una matriz de elementos de tipo NIL"

#: array.d:943
#, lisp-format
msgid "~S: ~S is not an nonnegative integer less than the rank of ~S"
msgstr "~S: ~S no es un entero no negativo menor que el rango de ~S"

#: array.d:1168
#, lisp-format
msgid "~S: ~S is not an array of bits"
msgstr "~S: ~S no es una matriz de bit"

#: array.d:1969
#, lisp-format
msgid "~S: The arguments ~S and ~S should be arrays of bits with the same dimensions"
msgstr "~S: Los argumentos ~S y ~S deben ser matrices de bits de la misma dimensión"

#: array.d:1978
#, lisp-format
msgid "~S: The arguments ~S, ~S and ~S should be arrays of bits with the same dimensions"
msgstr "~S: Los argumentos ~S, ~S y ~S deben ser matrices de bits de la misma dimensión"

#: array.d:3742
#, lisp-format
msgid "~S: vector ~S has no fill pointer"
msgstr "~S: el vector ~S no tiene ningún puntero de relleno"

#: array.d:3806
#, lisp-format
msgid "~S: ~S has length zero"
msgstr "~S: ~S tiene longitud nula"

#: array.d:3818
#, lisp-format
msgid "~S: extending the vector by ~S elements makes it too long"
msgstr "~S: ampliar el vector en ~S elementos, lo hace muy grande"

#: array.d:3839
#, lisp-format
msgid "~S works only on adjustable arrays, not on ~S"
msgstr "~S funciona sólo con matrices ajustables, no con ~S"

#: array.d:3853
#, lisp-format
msgid "~S: extension ~S should be a positive fixnum"
msgstr "~S: la extensión ~S debe ser un número positivo del tipo FIXNUM"

#: array.d:3944
#, lisp-format
msgid "~S: cannot push ~S into array ~S (bad type)"
msgstr "~S: no se puede introducir ~S en la matriz ~S (tipo equivocado)"

#: array.d:4009
#, lisp-format
msgid "~S: dimension ~S is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~S: la dimensión ~S no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:4267
#, lisp-format
msgid "~S: dimensions ~S produce too large total-size"
msgstr "~S: las dimensiones ~S producen un tamaño total demasiado grande"

#: array.d:4308
#, lisp-format
msgid "~S: ambiguous, more than one initialization specified"
msgstr "~S: ambiguo, se ha especificado más de una inicialización"

#: array.d:4317
#, lisp-format
msgid "~S: ~S must not be specified without ~S"
msgstr "~S: ~S no debe especificarse sin ~S"

#: array.d:4339
#, lisp-format
msgid "~S: the initial-element ~S is not of type ~S"
msgstr "~S: el INITIAL-ELEMENT ~S no es del tipo ~S"

#: array.d:4471
#, lisp-format
msgid "~S: ~S is of incorrect length"
msgstr "~S: ~S no tiene la longitud correcta"

#: array.d:4495
#, lisp-format
msgid "~S: ~S-argument ~S is not an array"
msgstr "~S: El ~S argumento ~S no es una matriz"

#: array.d:4512
#, lisp-format
msgid "~S: ~S-argument ~S does not have element type ~S"
msgstr "~S: El ~S argumento ~S no tiene como tipo de elemento ~S"

#: array.d:4527
#, lisp-format
msgid "~S: ~S-argument ~S is not of type `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"
msgstr "~S: El ~S argumento ~S no es del tipo `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"

#: array.d:4537
#, lisp-format
msgid "~S: array-total-size + displaced-offset (= ~S) exceeds total size ~S of ~S-argument"
msgstr "~S: array-total-size + displaced-offset (= ~S) excede el tamaño total ~S del ~S argumento"

#: array.d:4558
#, lisp-format
msgid "~S: fill-pointer ~S should be a nonnegative fixnum"
msgstr "~S: El puntero de relleno ~S debe ser un número no negativo del tipo FIXNUM"

#: array.d:4565
#, lisp-format
msgid "~S: fill-pointer argument ~S is larger than the length ~S"
msgstr "~S: El argumento FILL-POINTER ~S es mayor que la longitud ~S"

#
# "~S: el rango intentado ~S es demasiado grande" - lsg
#
# De acuerdo - cll
#
#: array.d:4632
#, lisp-format
msgid "~S: attempted rank ~S is too large"
msgstr "~S: rango intentado ~S es demasiado grande"

#: array.d:4644
#, lisp-format
msgid "~S: ~S may not be specified for an array of rank ~S"
msgstr "~S: ~S no debe especificarse para una matriz de rango ~S"

#: array.d:4839
#, lisp-format
msgid "~S: rank ~S of array ~S cannot be altered: ~S"
msgstr "~S: no es posible cambiar el rango ~S de la matriz ~S: ~S"

#
# "~S: los elementos de la formación ~S no son de tipo ~S" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#: array.d:4859
#, lisp-format
msgid "~S: array ~S does not have element-type ~S"
msgstr "~S: los elementos de la matriz ~S no son del tipo ~S"

#: array.d:4972
#, lisp-format
msgid "~S: cannot displace array ~S to itself"
msgstr "~S: no se puede desplazar la matriz ~S hacia ella misma"

#: array.d:5003
#, lisp-format
msgid "~S: the fill-pointer of array ~S is ~S, greater than ~S"
msgstr "~S: el puntero de relleno de la matriz ~S es ~S que es mayor que ~S"

# ... de la misma forma que uno no pone "START Índice" sv
#
# Si, si, ..., tienes toda la razón, ... cll
#
#: array.d:5125
#, lisp-format
msgid "Illegal START index ~S for ~S"
msgstr "Índice START ~S no válido en ~S"

#: array.d:5153
#, lisp-format
msgid "Illegal END index ~S for ~S"
msgstr "Índice END ~S no válido en ~S"

#: array.d:5166
#, lisp-format
msgid "~S: invalid bit-vector length ~S"
msgstr "~S: la longitud de BIT-VECTOR ~S es no válida"

#: hashtabl.d:1338
#, lisp-format
msgid "Performance/scalability warning: The hash table ~S needs to be rehashed after a garbage collection, since it contains key whose hash code is not GC-invariant."
msgstr "Advirtiendo mejora/escalabilidad: El tipo hash ~S necesita ser rehaseado después de una recogida de basura, desde que contiene clave cuyo código hash no es GC-invariante."

#: hashtabl.d:1526
#, lisp-format
msgid "Performance/scalability warning: The hash table ~S must be rehashed after each garbage collection, since its key ~S has a hash code that is not GC-invariant."
msgstr "Advirtiendo mejora/escalabilidad: la tabla hash ~S debe ser recalculada después de cada colección de basura, desde su clave ~S tiene un código hash que no es GC-invariante."

# Duda: hash lo he traducido por hash. ¿Alguna sugerencia? ¿Tablas de
# acceso rápido, o algo así?. Tened en cuenta que en Common Lisp, las
# tablas hash son una estructura bien definida que cuenta con sus
# propias instrucciones. A mí me gusta tal cual, ...
# Sugerencia: tabla de `hash'. sv
#
# No, no, no, no, ... :) `hash table' es `tabla hash'. Si se quiere,
# podríamos traducir la palabra `hash' pero si se deja es `tabla
# hash'. Todos los informáticos las llamamos así. Jamás he oído `Tabla
# *de* hash' cll
#
#: hashtabl.d:1674
#, lisp-format
msgid "Hash table size ~S too large"
msgstr "La tabla hash ~S es demasiado grande"

#
# "error interno al redimensionar ~S" - lsg
#
# Me gusta, salvo que el error ocurre "durante" - cll
#
#: hashtabl.d:1721
#, lisp-format
msgid "internal error occured while resizing ~S"
msgstr "error interno durante el redimensionamiento de ~S"

#: hashtabl.d:1835 hashtabl.d:1855 hashtabl.d:1875
#, lisp-format
msgid ""
"~S: The value of ~S should be ~S or ~S, not ~S.\n"
"It has been reset to ~S."
msgstr ""
"~S: El valor de ~S debería ser ~S o ~S, no ~S.\n"
"Ha sido reinicializado a ~S."

#: hashtabl.d:1895
#, lisp-format
msgid "~S: argument ~S should be ~S, ~S, ~S, ~S or ~S."
msgstr "~S: un argumento ~S debería ser ~S, ~S, ~S, ~S o ~S."

#: hashtabl.d:2014
#, lisp-format
msgid "~S: ~S argument should be a fixnum >=0, not ~S"
msgstr "~S: el argumento ~S debería ser un número fijo >=0, no ~S"

#: hashtabl.d:2036
#, lisp-format
msgid "~S: ~S argument should be an integer or a float > 1, not ~S"
msgstr "~S: el argumento ~S debe ser un entero o un real > 1, no ~S"

# "~S:argumento de ~S debe ser un entero comprendido entre 2 y 36, no ~S" - lsg
#
# Algo parecido he puesto yo - cll
#
#: hashtabl.d:2081
#, lisp-format
msgid "~S: ~S argument should be a real between 0 and 1, not ~S"
msgstr "~S: el argumento ~S debería ser un real entre 0 y 1, no ~S"

#: hashtabl.d:2175
#, lisp-format
msgid "~S: internal error while building ~S"
msgstr "~S: error interno durante compilación de ~S"

#: hashtabl.d:2219
#, lisp-format
msgid "~S: argument ~S is not a hash table"
msgstr "~S: un argumento ~S no es una tabla hash"

#: list.d:747
#, lisp-format
msgid "~S: ~S is a circular list"
msgstr "~S: ~S es una lista circular"

#: list.d:1145
#, lisp-format
msgid "~S: ~S is not a pair"
msgstr "~S: ~S no es un par"

#: list.d:1667
#, lisp-format
msgid "~S: lists ~S and ~S are not of same length"
msgstr "~S: las listas ~S y ~S no son de la misma longitud"

#: list.d:1843
#, lisp-format
msgid "~S: index ~S too large for ~S"
msgstr "~S: el índice ~S es demasiado grande para ~S"

#: list.d:1895
#, lisp-format
msgid "~S: start index ~S too large for ~S"
msgstr "~S: el índice :START ~S es demasiado grande para ~S"

#: list.d:1935
#, lisp-format
msgid "~S: end index ~S too large for ~S"
msgstr "~S: el índice :END ~S es demasiado grande para ~S"

#: package.d:397
#, lisp-format
msgid "symbol ~S cannot be deleted from symbol table"
msgstr "el símbolo ~S no puede ser borrado de la tabla de símbolos"

#: package.d:720
#, lisp-format
msgid "~S inconsistent: symbol ~S is a shadowing symbol but not present"
msgstr "~S inconsistente: el símbolo ~S es un símbolo que eclipsa a otro/s, sin embargo no está presente."

#: package.d:754
msgid "Ignore the lock and proceed"
msgstr "Ignorar el candado y proceder."

#: package.d:755
#, lisp-format
msgid "~A(~S): ~S is locked"
msgstr "~A(~S): ~S está bloqueado"

#: package.d:1033
msgid "symbol ~A from ~A will become a shadowing symbol"
msgstr "símbolo ~A desde ~A se convertirá en un símbolo que eclipsa a otro"

#: package.d:1064
#, lisp-format
msgid ""
"Uninterning ~S from ~S uncovers a name conflict.\n"
"You may choose the symbol in favour of which to resolve the conflict."
msgstr ""
"Desinternando ~S desde ~S no cubre un conflicto de nombre.\n"
"Puede elegir el símbolo en favor del cual se resolverá el conflicto."

#
# publicar está mal y ademas no es consistente con el mensaje d:329 en el que dice 'sacar'
# En este y en otros mensajes, el texto no es una orden dada al usuario, sino una opción que
# se le ofrece. Por tanto, no debe traducirse como un imperativo (impórtelo)  sino en
# infinitivo (importarlo). Pero deberías confirmar esto. - lsg
#
# Si, creo que tienes toda la razón, ... Entonces pongo `sacar' que
# aunque suene muy burro, creo que es muy, muy claro, ...
#
#: package.d:1112
msgid "((IMPORT \"import it and unintern the other symbol\" . T) (IGNORE \"do not import it, leave undone\" . NIL))"
msgstr "((IMPORT \"importarlo y sacar el otro símbolo\" . T) (IGNORE \"no importarlo, dejarlo como está\" . NIL))"

#
# Aquí tengo la misma duda anterior - lsg
#
#: package.d:1116
msgid "((IMPORT \"import it, unintern one other symbol and shadow the other symbols\" . T) (IGNORE \"do not import it, leave undone\" . NIL))"
msgstr "((IMPORT \"importarlo, sacar uno de los otro símbolo y eclipsar los otros símbolos\" . T) (IGNORE \"no importarlo, dejarlo como está\" . NIL))"

#
# Lo mismo de antes - lsg
#
#: package.d:1120
msgid "((IMPORT \"import it and shadow the other symbol\" . T) (IGNORE \"do nothing\" . NIL))"
msgstr "((IMPORT \"importarlo y eclipsar el otro símbolo\". T) (IGNORE \"no hacer nada\" . NIL))"

#: package.d:1126
#, lisp-format
msgid "Importing ~S into ~S produces a name conflict with ~S and other symbols."
msgstr "Importando ~S dentro de ~S produce un conflicto de nombres con ~S y otros símbolos."

#: package.d:1127
#, lisp-format
msgid "Importing ~S into ~S produces a name conflict with ~S."
msgstr "Importando ~S dentro de ~S produce un conflicto de nombres con ~S."

#: package.d:1229
#, lisp-format
msgid "UNEXPORT in ~S is illegal"
msgstr "UNEXPORT en ~S es no válido"

#
# "UNEXPORT sólo funciona con símbolos accesibles, no con ~S en ~S" - lsg
#
# Ya, o sea, que cambie "sobre" por "con". Vale, me gusta mucho más tu
# mensaje que el mío - cll
#
#: package.d:1248
#, lisp-format
msgid "UNEXPORT works only on accessible symbols, not on ~S in ~S"
msgstr "UNEXPORT sólo funciona sobre símbolos accesibles, no con ~S desde ~S"

#
# La misma cuestión anterior entre imperativo e infinitivo - lsg
#
#: package.d:1301
msgid "((IMPORT \"import the symbol first\" . T) (IGNORE \"do nothing, do not export the symbol\" . NIL))"
msgstr "((IMPORT \"importar el símbolo primero\" . T) (IGNORE \"no hacer nada, no exportar el símbolo\" . NIL))"

#: package.d:1303
#, lisp-format
msgid "~S: Symbol ~S should be imported into ~S before being exported."
msgstr "~S: El símbolo ~S debería ser importado a ~S antes de ser exportado."

#: package.d:1337
msgid "the symbol to export, "
msgstr "el símbolo a exportar, "

#: package.d:1348
msgid "the old symbol, "
msgstr "El símbolo original, "

#
# El segundo from deberia ser 'de', porque quiere decir que un símbolo
# a de un paquete A entra en conflicto con el símbolo b _del_ paquete
# B. Luego, debe ser 'de'.
#
#: package.d:1362
#, lisp-format
msgid ""
"Exporting ~S from ~S produces a name conflict with ~S from ~S.\n"
"You may choose which symbol should be accessible in ~S."
msgstr ""
"Exportando ~S desde ~S produce un conflicto de nombres con ~S de ~S.\n"
"Puede elegir cual símbolo debería ser accesible en ~S."

#: package.d:1628
#, lisp-format
msgid ""
"(~S ~S ~S): ~S name conflicts remain\n"
"Which symbol with name ~S should be accessible in ~S?"
msgstr ""
"(~S ~S ~S): nombre ~S en conflicto continua\n"
"¿Cual símbolo con nombre ~S debería ser accesible en ~S?"

#: package.d:1871
#, lisp-format
msgid "The value of *PACKAGE* was not a package and was reset. The old value was ~S. The new value is ~S."
msgstr "El valor de *PACKAGE* no fue un paquete y fue restablecido. El valor anterior fue ~S. El valor nuevo es ~S."

#: package.d:1872
msgid "Proceed with the new value."
msgstr "Procesado con el valor actual."

#: package.d:1895
#, lisp-format
msgid "~S: Package ~S has been deleted."
msgstr "~S: El paquete ~S ha sido eliminado."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~SS.",
# pienso que "No hay ningún paquete con el nombre ~SS" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: package.d:1909
#, lisp-format
msgid "~S: There is no package with name ~S"
msgstr "~S: No hay ningún paquete con el nombre ~S"

#: package.d:1926
#, lisp-format
msgid "~S: argument should be a package or a package name, not ~S"
msgstr "~S: un argumento debe ser un paquete o el nombre de un paquete, no ~S"

#: package.d:2043
#, lisp-format
msgid "~S: there is already a package named ~S"
msgstr "~S: ya hay un paquete llamado ~S"

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: package.d:2355
#, lisp-format
msgid "~S: argument should be a symbol or a list of symbols, not ~S"
msgstr "~S: un argumento debería ser un símbolo o una lista de símbolos, no ~S"

#: package.d:2504
msgid "discard this nickname"
msgstr "descarta este apodo"

#: package.d:2505
msgid "return the existing package"
msgstr "devuelve el paquete existente"

#: package.d:2509
msgid "input another nickname"
msgstr "introduzca otro apodo"

#: package.d:2510
msgid "input another name"
msgstr "introduzca otro nombre"

#: package.d:2516
#, lisp-format
msgid "~S: a package with name ~S already exists."
msgstr "~S: un paquete con nombre ~S ya existe."

#: package.d:2614
#, lisp-format
msgid "One should not change the case sensitiveness of ~S."
msgstr "Uno no debería cambiar los casos distinguiendo mayúsculas/minúsculas de ~S."

#: package.d:2624
#, lisp-format
msgid "One should not change the case inversion of ~S."
msgstr "Uno no debería cambiar la inversión de mayúsculas/minúsculas de ~S."

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: package.d:2702
msgid "Ignore."
msgstr "Ignorar."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: package.d:2703
#, lisp-format
msgid "~S: There is no package with name ~S."
msgstr "~S: No hay ningún paquete con el nombre ~S."

#: package.d:2731
#, lisp-format
msgid "~*Delete ~S anyway."
msgstr "~*Elimina ~S de todas formas."

#
# Leo, en vez de "está siendo utilizado", ¿no crees que es mejor "es
# utilizado"? - cll
#
# Propongo *se utiliza*, es mucho más español. sv
#
# Pero, ¿cómo pones algo así? "~S se utiliza en ~{~S~^, ~}.", ¿por
# ejemplo? Es que el problema es que no ~S (el primero) no "se utiliza"
# en la segunda expresión, sino que la segunda expresión es una que
# emplea a la primera. No se si me explico, ...
#
# En cualquier caso, creo que tienes toda la razón al decir "es mucho
# más español", es que de hecho la expresión "es utilizado" aunque es
# correcta, no parece muy española, por favor, ¿sugerencias? - cll
#
#: package.d:2732
#, lisp-format
msgid "~S: ~S is used by ~{~S~^, ~}."
msgstr "~S: ~S es utilizado por ~{~S~^, ~}."

#: package.d:2939
#, lisp-format
msgid "~S: ~S is not using ~S"
msgstr "~S: ~S no está empleando ~S"

#: record.d:32
#, lisp-format
msgid "~S: ~S is not a valid index into ~S"
msgstr "~S: ~S no es un índice válido en ~S"

#: record.d:40
#, lisp-format
msgid "~S: ~S is not a record"
msgstr "~S: ~S no es un registro"

#: record.d:99
#, lisp-format
msgid "~S: length ~S should be of type ~S"
msgstr "~S: la longitud ~S debería ser de tipo ~S"

#: record.d:132
#, lisp-format
msgid "~S: ~S is not a structure of type ~S"
msgstr "~S: ~S no es una estructura del tipo ~S"

#: record.d:180
#, lisp-format
msgid "~S: Slot ~S of ~S has no value"
msgstr "~S: La ranura ~S de ~S no tiene ningún valor"

#: record.d:284 trace.lisp:72
#, lisp-format
msgid "~S: ~S is not a closure"
msgstr "~S: ~S no es una cerradura"

#: record.d:312
#, lisp-format
msgid "~S: ~S is not a compiled closure"
msgstr "~S: ~S no es una cerradura compilada"

#: record.d:401
#, lisp-format
msgid "~S is not a valid code-vector byte"
msgstr "~S no es un byte CODE-VECTOR válido"

#: record.d:412
#, lisp-format
msgid "~S: invalid side-effect class ~S for function ~S"
msgstr "~S: clase ~S con efecto lateral no válida para la función ~S"

#: record.d:439
#, lisp-format
msgid "~S: function ~S is too big: ~S"
msgstr "~S: la función ~S es demasiado grande: ~S"

#: record.d:547
#, lisp-format
msgid "~S: argument is not a funcallable instance: ~S"
msgstr "~S: un argumento no es una instancia llamadora de función: ~S"

#: record.d:554
#, lisp-format
msgid "~S: argument is not a function: ~S"
msgstr "~S: un argumento no es una función: ~S"

#: record.d:617
#, lisp-format
msgid "~S: This is not a prototype of a generic function: ~S"
msgstr "~S: Esto no es un prototipo de una función genérica: ~S"

#: record.d:811
#, lisp-format
msgid "Due to the compiler optimization settings, lambda list for ~S is not available"
msgstr "Debido a las opciones de optimización del compilador, lista lambda para ~S no está disponible"

#: record.d:963
#, lisp-format
msgid "~S: ~S is not a CLOS class-version"
msgstr "~S: ~S no es una versión de clase CLOS"

#: record.d:1050
#, lisp-format
msgid "~S: invalid initialization argument ~S"
msgstr "~S: argumento de inicialización no válida ~S"

#: record.d:1138
#, lisp-format
msgid "~S: Invalid location ~S of slot ~S in ~S (check the :ALLOCATION slot option)"
msgstr "~S: ubicación no válida ~S de ranura ~S dentro de ~S (comprueba la opción de ranura :ALLOCATION) "

#
# "EVAL: la lista de argumentos pasada a ~S es punteada: ~S" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: record.d:1155
#, lisp-format
msgid "~S: invalid arguments: class argument ~S is not the class of ~S"
msgstr "~S: argumento no válido: argumento de clase ~S no es de la clase de ~S"

#: record.d:1375
#, lisp-format
msgid "~S: invalid slot location ~S"
msgstr "~S: invalidada ubicación de ranura ~S"

#: record.d:1381
#, lisp-format
msgid "~S: not a CLOS instance: ~S"
msgstr "~S: no una instancia de la clase CLOS: ~S"

#: record.d:2073 clos-class5.lisp:633
#, lisp-format
msgid "~S method for ~S returned ~S"
msgstr "método ~S para ~S devuelto ~S"

#: weak.d:436 weak.d:538
#, lisp-format
msgid "~S: the keys list argument is empty"
msgstr "~S: la lista de teclas argumentadas está vacía"

#: weak.d:649
#, lisp-format
msgid "~S: ~S is not an association list"
msgstr "~S: ~S no es una lista de asociación"

#: sequence.d:271
#, lisp-format
msgid "There are no sequences of type ~S"
msgstr "No hay secuencias del tipo ~S"

#: sequence.d:358
#, lisp-format
msgid "~S: sequence type forces length ~S, but result has length ~S"
msgstr "~S: tecla de secuencia fuerza longitud ~S, pero resultado tiene longitud ~S"

#: sequence.d:405 sequence.d:432
#, lisp-format
msgid "~S: ~S = ~S should not be greater than ~S = ~S"
msgstr "~S: ~S = ~S no debe ser mayor que ~S = ~S"

#: sequence.d:573
#, lisp-format
msgid "~S: the index should be a fixnum >=0, not ~S"
msgstr "~S: el índice debe ser un número >=0 del tipo FIXNUM, no ~S"

#: sequence.d:838 sequence.d:1184
#, lisp-format
msgid "~S: bad length ~S"
msgstr "~S: longitud equivocada ~S"

#: sequence.d:946
#, lisp-format
msgid "~S: the result ~S is not of type ~S"
msgstr "~S: el resultado ~S no es de tipo ~S"

#: sequence.d:968
#, lisp-format
msgid "~S: size should be an integer >=0, not ~S"
msgstr "~S: el tamaño debe ser un entero >=0, no ~S"

#: sequence.d:974
#, lisp-format
msgid "~S: :UPDATE must not be specified without :INITIAL-ELEMENT"
msgstr "~S: :UPDATE no debe especificarse sin :INITIAL-ELEMENT"

#: sequence.d:2001
#, lisp-format
msgid "~S: sequence ~S is too long: ~S is not a FIXNUM"
msgstr "~S: secuencia ~S es demasiado larga: ~S no es un FIXNUM"

#: charstrg.d:1545
#, lisp-format
msgid "~S: the radix must be an integer between 2 and 36, not ~S"
msgstr "~S: la base debe ser un entero entre 2 y 36, no ~S"

#: charstrg.d:1890
#, lisp-format
msgid "~S: the code argument should be an integer, not ~S"
msgstr "~S: el argumento del código debe ser un entero y no ~S"

# "~S: no se puede convertir ~S al tipo character"
#
# No sé si traducir la palabra character, puesto que es una palabra
# clave en Lisp. - lsg
#
# Yo ya había traducido este mensaje como:
#
# "~S: ~S no puede convertirse a un carácter"
#
# Pero el tuyo me gusta mucho más, salvo que `character', puesto que es
# un término definido en el estándar Common Lisp, debe ir en mayúsculas
# - cll
#
#: charstrg.d:1911
#, lisp-format
msgid "~S: cannot coerce ~S to a character"
msgstr "~S: no se puede convertir ~S al tipo CHARACTER"

#: charstrg.d:1944
#, lisp-format
msgid "~S: the weight argument should be an integer, not ~S"
msgstr "~S: el argumento de ponderación debe ser un entero, y no ~S"

#: charstrg.d:1980
#, lisp-format
msgid "~S: argument should be an integer, not ~S"
msgstr "~S: un argumento debería ser un entero, no ~S"

#: charstrg.d:2128 compiler.lisp:7216
#, lisp-format
msgid "~S: index should be an integer, not ~S"
msgstr "~S: el índice debe ser un entero, no ~S"

#: charstrg.d:2131
#, lisp-format
msgid "~S: ~S-index should be an integer, not ~S"
msgstr "~S: el índice ~S debería ser un entero, no ~S"

#: charstrg.d:2142
#, lisp-format
msgid "~S: index should be NIL or an integer, not ~S"
msgstr "~S: el índice debe ser NIL o un entero, no ~S"

#: charstrg.d:2145
#, lisp-format
msgid "~S: ~S-index should be NIL or an integer, not ~S"
msgstr "~S: el índice ~S debería ser NIL o un entero, no ~S"

#: charstrg.d:2162
#, lisp-format
msgid "~S: index ~S should not be greater than the length of the string"
msgstr "~S: el índice ~S no debe ser mayor que la longitud de la cadena"

#: charstrg.d:2165
#, lisp-format
msgid "~S: ~S-index ~S should not be greater than the length of the string"
msgstr "~S: el índice ~S = ~S no debe ser mayor que la longitud de la cadena"

#: charstrg.d:2183
#, lisp-format
msgid "~S: index ~S should be less than the length of the string"
msgstr "~S: el índice ~S debe ser menor que la longitud de la cadena"

#: charstrg.d:2186
#, lisp-format
msgid "~S: ~S-index ~S should be less than the length of the string"
msgstr "~S: el índice ~S = ~S debe ser menor que la longitud de la cadena"

#: charstrg.d:2345 charstrg.d:2449 charstrg.d:3657
#, lisp-format
msgid "~S: :START-index ~S must not be greater than :END-index ~S"
msgstr "~S: El :START-index ~S no debe ser mayor que el :END-index ~S"

#: charstrg.d:2410
#, lisp-format
msgid "~S: argument ~S should be a string, a symbol or a character"
msgstr "~S: un argumento ~S debería ser una cadena, un símbolo o un carácter"

#: charstrg.d:2499
#, lisp-format
msgid "~S: :START1-index ~S must not be greater than :END1-index ~S"
msgstr "~S: El :START1-index ~S no debe ser mayor que el :END1-index ~S"

#: charstrg.d:2522
#, lisp-format
msgid "~S: :START2-index ~S must not be greater than :END2-index ~S"
msgstr "~S: El :START2-index ~S no debe ser mayor que el :END2-index ~S"

#: charstrg.d:3138
#, lisp-format
msgid "~S: the string length ~S should be nonnegative fixnum"
msgstr ""
"~S: la longitud de la cadena de caracteres ~S debe ser un número no negativo\n"
"del tipo FIXNUM"

#: charstrg.d:3170
#, lisp-format
msgid "~S: ~S argument ~S should be of type ~S"
msgstr "~S: un argumento ~S ~S debería ser de tipo ~S"

#
# Duda: esta traducción ha sido muy difícil, y está basada en la
# traducción francesa que dice: "~S: Mauvais mode de saut d'environnement
# ~S."
#
#: debug.d:874
#, lisp-format
msgid "~S: bad frame climbing mode ~S"
msgstr "~S: modo de salto de marco equivocado ~S"

#: debug.d:892
#, lisp-format
msgid "~S: ~S is not a stack pointer"
msgstr "~S: ~S no es un puntero de pila"

#: debug.d:1060
#, lisp-format
msgid "~S: ~S is not a pointer to an EVAL/APPLY frame"
msgstr "~S: ~S no es un puntero a un marco de tipo EVAL/APPLY"

#: debug.d:1222
msgid "APPLY frame with breakpoint for call "
msgstr "marco APPLY con punto de ruptura para invocar "

#: debug.d:1225
msgid "APPLY frame for call "
msgstr "marco APPLY para invocar "

#: debug.d:1242
msgid "EVAL frame with breakpoint for form "
msgstr "EVAL marco con punto de ruptura para la forma "

#: debug.d:1245
msgid "EVAL frame for form "
msgstr "EVAL marco para la forma "

#
# A ver aquí, que hay mogollón, hay mogollón, ...
#
# Leo, tu opinas que aquí deberíamos traducir:
#
# "variables con vinculación de recintos (~ = dinámicamente):"
#
# Sin embargo, yo creo que lo más correcto es:
#
# "trama de ligadura de las variables (~ = dinámicamente):"
#
# Puesto que esto se refiere al tipo de tramas que hay en la pila,
# cuando ésta está siendo examinada. De hecho, la traducción francesa
# es:
#
# "Le «frame» de liaison de variables (~ signifiant dynamique) lie :"
#
# ..., que viene a ser algo como lo que he puesto yo. - cll
#
#: debug.d:1250
msgid "frame binding variables (~ = dynamically):"
msgstr "marco de ligadura de las variables (~ = dinámicamente):"

#: debug.d:1266
msgid "CALLBACK frame"
msgstr "marco CALLBACK"

#: debug.d:1271
msgid "frame binding variables "
msgstr "marco de ligadura de las variables"

#: debug.d:1274 debug.d:1303
msgid " binds (~ = dynamically):"
msgstr " vincula (~ = dinámicamente):"

#: debug.d:1299
msgid "frame binding functions "
msgstr "marco de ligadura de las funciones "

# Un poco más en español podría ser: "Entorno siguiente: " sv
#
# Hmmm, ..., aquí no estoy de acuerdo contigo. No me suena bien lo del
# "Entorno siguiente", ... cll
#
#: debug.d:1323 debug.d:1394
msgid "  Next environment: "
msgstr "  Siguiente entorno: "

#: debug.d:1349
msgid "compiled tagbody frame for "
msgstr "marco compilado del cuerpo de etiquetas de salto para "

#: debug.d:1353
msgid "compiled block frame for "
msgstr "marco de bloque compilado para "

#: debug.d:1359
msgid "block frame "
msgstr "marco de bloque"

#: debug.d:1362
msgid "nested block frame "
msgstr "marco anidado de bloque "

#: debug.d:1367
msgid " for "
msgstr " para "

#: debug.d:1372
msgid "tagbody frame "
msgstr "marco tagbody"

# Duda: Aquí lo de `nested' es bastante puñetero. Creo que no debe
# traducirse por `anidado' (que no tendría demasiado sentido, creo),
# sino por `encajada', haciendo referencia a la trama a la que se llega
# por el uso de las etiquetas de salto, ...
#
# Sin embargo, no estoy demasiado seguro, ... aSocorro!! - cll
#
# A propósito de esta cuestión, pregunté en la lista de correo de CLisp:
#
# > `nested' have various meanings. It can mean that one thing is `into'
# > other one or that one thing is `joined' with other one. In this
# > message, I think you are talking about the frame you arrive when using
# > a tag, as if you were `joining' a new frame, is it so?
#
# Y la respuesta de Bruno Haible fue:
#
# No. In CLISP it's yet another (maybe new?) meaning. Interpretation frames
# are normally built up in the stack. However, when a closure is created,
# some parts of the frames must be moved out to the heap, so that the
# closure points to valid data, called "environment", even after the frame
# has been deestablished. We called this process "nesting" of a frame.
# Any better vocabulary? Can you propose a good german or french translation?
#
# Asi que, la verdad, "anidado" me parece correcto. Para ello, imaginaos
# una trama (o marco), de la que se "re-elabora" una parte denominada
# "entorno" pero que solo tiene sentido dentro de esta trama (o marco),
# puesto que se ha levantado un `closure'. - cll
#
#: debug.d:1375
msgid "nested tagbody frame "
msgstr "marco anidado del cuerpo de etiquetas "

#: debug.d:1380
msgid " for"
msgstr " para"

#: debug.d:1405
#, lisp-format
msgid "~S: environment is not an association list"
msgstr "~S: entorno no es una lista de asociación"

#
# Ésta estaba claramente mal - lsg
#
#: debug.d:1418
msgid "catch frame for tag "
msgstr "marco de captura para la etiqueta "

# Handler, otra buena.. Sugerencias? - lsg
#
# Duda: ¿cómo traducir `handler'?
#
# Pues bien, he elegido el término `manipulador' puesto que eso es,
# precisamente, lo que es un `handler' en Common Lisp. De hecho, el
# estándar Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr.,
# en la página 872 dice:
#
# "The process of signaling involves the search for an invocation of a
# handler, a piece of code that will attempt to deal appropiately with
# the situation"
#
# Y atención a la siguiente observación: (en la misma página, a
# continuación del párrafo anterior)
#
# "If a handle is found, it may either handle the situation, by
# performing some non-local transfer of control, or decline to handle
# it, by failing to perform a non-local transfer of control. If it
# declines, other handlers are sought".
#
# En fin, a la vista de esta definición y de la siguiente aclaración,
# propongo `manejador' para su traducción - cll
#
#: debug.d:1422
msgid "handler frame for conditions"
msgstr "marco de manipulación para condiciones"

#
# Estaba mal. Yo pondria: "recinto de unwind-protect" - lsg
#
# Y yo creo que si cambiamos `recinto' por `trama' ya es la leche de
# perfecto ;) - cll
#
# Leo, como puedes ver he cambiado en todos lados `trama' por `marco' - cll
#
#: debug.d:1432
msgid "unwind-protect frame"
msgstr "marco `unwind-protect'"

# Duda: Lo de `driver' lo dejo sin traducir, ...
#
# En la traducción francesa está sin traducir y en el estándar de Common
# Lisp no se hace ni la mas mínima referencia a algo que se llame así.
#
# "recinto de driver" - lsg
#
# Vale, ¡pero vamos!, que cambio `recinto' por `trama' - cll
#
#: debug.d:1436
msgid "driver frame"
msgstr "marco `driver'"

# "Entornos con vinculación de recintos" - lsg
#
# Aquí volvemos un poco a lo del mensaje constobj.d:915 Según creo,
# estos mensajes se refieren al tipo de tramas que hay en la pila, no se
# trata de un entorno (en el sentido que en Lisp tiene esta palabra).
#
# La traducción francesa dice:
#
# "«frame» de liaison d'environnements"
#
# ¿Que os parece?
#
#: debug.d:1440 debug.d:1445 debug.d:1450 debug.d:1455 debug.d:1460 debug.d:1465 debug.d:1472
msgid "frame binding environments"
msgstr "marco de ligadura del entorno"

#: debug.d:1486
#, lisp-format
msgid "~S: unknown frame type"
msgstr "~S: tipo de marco desconocido"

#: error.d:57 reploop.lisp:495
msgid "Unprintable error message"
msgstr "Mensaje de error no imprimible"

#: error.d:183
#, lisp-format
msgid "internal error or error in message catalog: invalid low-level format string ~S"
msgstr "error interno o error en el catálogo de mensaje: cadena de formato a bajo nivel ~S"

#: error.d:841 error.d:846
#, lisp-format
msgid "~S: User break"
msgstr "~S: Interrupción del usuario"

#: error.d:844
msgid "Continue execution"
msgstr "Continuar ejecución"

#: error.d:918 foreign.d:702 foreign.d:2442 foreign.d:2553 foreign.d:3205
#, lisp-format
msgid "~S: ~S is not of type ~S"
msgstr "~S: ~S no es de tipo ~S"

#: error.d:949 error.d:951
#, lisp-format
msgid "~S: ~S comes from a previous Lisp session and is invalid"
msgstr "~S: ~S proviene desde una sesion Lisp anterior y no es válido"

#: error.d:968 error.d:993
#, lisp-format
msgid "~S: ~S is not a list"
msgstr "~S: ~S no es una lista"

#: error.d:1003
#, lisp-format
msgid "~S: A proper list must not end with ~S"
msgstr "~S: una lista propietaria debe no finalizar con ~S"

#: error.d:1015
#, lisp-format
msgid "~S: A proper list must not be circular: ~S"
msgstr "~S: una lista propia debe no ser circular: ~S"

# me comería el "y por ello", todo el mundo lo entenderá, y además no
# está en el original. sv
#
# No sólo eso, sino que además el mensaje queda demasiado largo. Ser
# mucho más cómodo, para quien esté trabajando, ver mensajes cortos,
# ... sugerencia aceptada. cll
#
#: error.d:1055
#, lisp-format
msgid "~S: ~S is a constant, may not be used as a variable"
msgstr "~S: ~S es una constante, quizá no se emplea como una variable"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#: error.d:1071
#, lisp-format
msgid "~S: ~S is not a symbol, cannot be declared ~S"
msgstr "~S: ~S no es un símbolo, no puede declararse ~S"

#: error.d:1092
msgid "Remove the global SYMBOL-MACRO definition"
msgstr "Quita la definición global de SYMBOL-MACRO"

#: error.d:1094
#, lisp-format
msgid "~S: attempting to turn ~S into a SPECIAL variable, but it is already a global SYMBOL-MACRO."
msgstr "~S: intentando volver ~S dentro de una variable SPECIAL, pero ya es un MACRO-SIMBÓLICO global."

#: error.d:1096
#, lisp-format
msgid "~S: attempting to turn ~S into a constant, but it is already a global SYMBOL-MACRO."
msgstr "~S: intentando volver ~S dentro de una constante, pero ya es un MACRO-SIMBÓLICO global."

#: error.d:1097
#, lisp-format
msgid "~S: interning ~S into the KEYWORD package would turn it into a constant, but it is already a global SYMBOL-MACRO."
msgstr "~S: internando ~S dentro del paquete KEYWORD debería tornarlo en una constante, pero ya es un MACRO-SIMBÓLICO global."

#: error.d:1116 error.d:1128
#, lisp-format
msgid "~S: the symbol ~S names a global SPECIAL variable"
msgstr "~S: el símbolo ~S nombra una variable global SPECIAL"

# binding
#: error.d:1127
msgid "Remove the global SPECIAL variable binding"
msgstr "Quita el enlace variable global ESPECIAL"

#: error.d:1157
#, lisp-format
msgid "~S: ~S is not a vector"
msgstr "~S: ~S no es un vector"

#: error.d:1165
#, lisp-format
msgid "~S: argument ~S is not an array"
msgstr "~S: un argumento ~S no es una matriz"

#: error.d:1172
#, lisp-format
msgid "~S: argument ~S is not a vector"
msgstr "~S: un argumento ~S no es un vector"

#: error.d:1185
#, lisp-format
msgid "~S: argument ~S is not a vector of type ~S"
msgstr "~S: un argumento ~S no es un vector de tipo ~S"

#: error.d:1199
#, lisp-format
msgid "~S: ~S may not be used as an environment"
msgstr "~S: ~S no puede usarse como un entorno"

#: error.d:1209 error.d:1217
#, lisp-format
msgid "~S: argument ~S is not a nonnegative fixnum"
msgstr "~S: un argumento ~S no es un número fijo no negativo"

#: error.d:1224
#, lisp-format
msgid "~S: ~S is not an integer"
msgstr "~S: ~S no es un entero"

#: error.d:1237
#, lisp-format
msgid "~S: ~S is not a non-negative integer"
msgstr "~S: ~S no es un entero no negativo"

#: error.d:1253
#, lisp-format
msgid "~S: index should not be negative: ~S"
msgstr "~S: el índice no debe ser negativo: ~S"

#: error.d:1256
#, lisp-format
msgid "~S: ~S-index should not be negative: ~S"
msgstr "~S: el índice ~S no debería ser negativo: ~S"

#: error.d:1268 error.d:1276 xcharin.lisp:34
#, lisp-format
msgid "~S: argument ~S is not a character"
msgstr "~S: un argumento ~S no es un carácter"

#: error.d:1283
#, lisp-format
msgid "~S: argument ~S is not a string"
msgstr "~S: un argumento ~S no es una cadena"

#: error.d:1300
#, lisp-format
msgid "Attempt to modify a read-only string: ~S"
msgstr "Tratando modificar una cadena de sólo lectura: ~S"

#: error.d:1310
#, lisp-format
msgid "~S: argument ~S is neither a string nor an integer"
msgstr "~S: un argumento ~S no es ni una cadena ni un entero"

#: error.d:1321
#, lisp-format
msgid "string too long: desired length ~S exceeds the supported maximum length"
msgstr "cadena excesivamente larga: deseaba una longitud de ~S excede la longitud máxima compatible"

#: error.d:1332 clos-class2.lisp:103
#, lisp-format
msgid "~S: ~S is not a class"
msgstr "~S: ~S no es una clase"

#: error.d:1341
#, lisp-format
msgid "~S: argument ~S is not a stream"
msgstr "~S: un argumento ~S no es un flujo"

#: error.d:1394
#, lisp-format
msgid "~S: Argument ~S is not a character set"
msgstr "~S: un argumento ~S no es un conjunto de carácter"

#: error.d:1422
#, lisp-format
msgid "~S: the property list ~S has an odd length"
msgstr "~S: la lista de propiedades ~S tiene longitud impar"

#: error.d:1438
#, lisp-format
msgid "~S: keyword arguments in ~S should occur pairwise"
msgstr "~S: los argumentos clave dentro de ~S ocurriría por pares"

#: error.d:1449
#, lisp-format
msgid "~S: ~S marker ~S is not a symbol"
msgstr "~S: ~S marcador ~S no es un símbolo"

#
# Yo pondría un guión entre argumento y clave. - lsg
#
# Hmm, o sea `argumento-clave'. No, no me gusta y de hecho, en el
# "Vocabulario bilingüe de términos técnicos" de "Lisp" (3ra edición) de
# Winston y Horn, los traductores al español ponen en la página 649:
#
# keyword arguments - argumentos clave
#
# sin guión por medio - cll
#
#: error.d:1471
#, lisp-format
msgid ""
"~S: illegal keyword/value pair ~S, ~S in argument list.\n"
"The allowed keywords are ~S"
msgstr ""
"~S: par argumento clave/valor no válido ~S, ~S en la lista de argumentos.\n"
"Los parámetros clave permitidos son ~S"

#: error.d:1486
#, lisp-format
msgid "~S: ~S is not a function"
msgstr "~S: ~S no es una función"

#: error.d:1522 trace.lisp:159
#, lisp-format
msgid "~S: undefined function ~S"
msgstr "~S: la función ~S no definida"

#: error.d:1579
#, lisp-format
msgid "~S: ~S is not a function name; try using a symbol instead"
msgstr "~S: ~S no es un nombre de una función, pruebe utilizando un símbolo en su lugar"

#: error.d:1594
#, lisp-format
msgid ""
"~S: argument ~S is not a function.\n"
"To get a function in the current environment, write (FUNCTION ...).\n"
"To get a function in the global environment, write (COERCE '... 'FUNCTION)."
msgstr ""
"~S: un argumento ~S no es una función.\n"
"Para obtener una función dentro del entorno actual, escriba (FUNCIÓN ...).\n"
"Para obtener una función dentro del entorno global, escriba (COERCE '...' 'FUNCTION)."

#: error.d:1610
#, lisp-format
msgid "EVAL/APPLY: Too many arguments (~S instead of at most ~S) given to ~S"
msgstr "EVALUAR/APLICAR: Demasiados argumentos (~S en vez de como mucho ~S) dados para ~S"

#: error.d:1613
#, lisp-format
msgid "~S: Too many arguments (~S instead of at most ~S) given to ~S"
msgstr "~S: Demasiados argumentos (~S en vez de como mucho ~S) dados a ~S"

#: error.d:1628
#, lisp-format
msgid "EVAL/APPLY: Too few arguments (~S instead of at least ~S) given to ~S"
msgstr "EVALUAR/APLICAR: Muy pocos argumentos (~S en vez de al menos ~S) dados a ~S"

#: error.d:1631
#, lisp-format
msgid "~S: Too few arguments (~S instead of at least ~S) given to ~S"
msgstr "~S: Muy pocos argumentos (~S en vez de al menos ~S) dados a ~S"

#
# "EVAL: la variable ~S no tiene asignado ningún valor" - lsg
#
# Bueno, he quitado lo de "asignado" porque parece de "perogrullo", pero
# lo demás se queda - cll
#
#: error.d:1648 error.d:1649
#, lisp-format
msgid "~S: variable ~S has no value"
msgstr "~S: la variable ~S no tiene ningún valor"

# "~S:argumento de ~S debe ser un entero comprendido entre 2 y 36, no ~S" - lsg
#
# Algo parecido he puesto yo - cll
#
#: error.d:1665
#, lisp-format
msgid "~S: argument ~S is not an integer with at most ~S bits (including the sign bit)"
msgstr "~S: un argumento ~S no es un entero con al menos ~S bit (incluyendo el bit de signo)"

#: error.d:1666
#, lisp-format
msgid "~S: argument ~S is not a nonnegative integer with at most ~S bits"
msgstr "~S: un argumento ~S no es un entero no negativo con al menos ~S bit"

#: error.d:1711
#, lisp-format
msgid "~S: ~S is not an `unsigned int' number"
msgstr "~S: ~S no es un número del tipo `unsigned int'"

#: error.d:1719
#, lisp-format
msgid "~S: ~S is not an `int' number"
msgstr "~S: ~S no es un número del tipo `int'"

#: error.d:1738
#, lisp-format
msgid "~S: ~S is not a `unsigned long' number"
msgstr "~S: ~S no es un número del tipo `unsigned long'"

#: error.d:1746
#, lisp-format
msgid "~S: ~S is not a `long' number"
msgstr "~S: ~S no es un número del tipo `long'"

#: error.d:1757
#, lisp-format
msgid "~S: ~S is not a single-float"
msgstr "~S: ~S no es un REAL-SIMPLE"

#: error.d:1765
#, lisp-format
msgid "~S: ~S is not a double-float"
msgstr "~S: ~S no es un real-doble"

#: errunix.d:19
msgid "UNIX error "
msgstr "Error de UNIX "

# Cambio librería por el término oficial. sv
#
# Uuuffffff, ..., aquí sí que podríamos discutir hasta la muerte. Pero
# bueno, se queda como tú lo has puesto. cll
#
#: errunix.d:21
msgid "POSIX library error "
msgstr "Error de biblioteca POSIX"

#: errwin32.d:8
msgid "Win32 error "
msgstr "Error de Win32 "

#: misc.d:77
msgid " (built "
msgstr " (compilado "

#: misc.d:83
msgid " (memory "
msgstr " (memoria "

#: misc.d:89
msgid " (built on "
msgstr " (compilado el "

#: misc.d:111
msgid "This file was produced by another lisp version, must be recompiled."
msgstr "Este fichero ha sido producido por otra versión de lisp, debe ser recompilado."

#: misc.d:258
#, lisp-format
msgid "~S (~S ~S): out of memory"
msgstr "~S (~S ~S): sin memoria suficiente"

#: misc.d:314
#, lisp-format
msgid "~S: type of attribute ~S is unsupported"
msgstr "~S: tipo de atributo ~S sin mantenimiento"

#: misc.d:334
msgid "GNU C++ "
msgstr "GNU C++"

#: misc.d:336
msgid "GNU C "
msgstr "GNU C "

#: misc.d:342
msgid "C++ compiler"
msgstr "Compilador de C++"

#: misc.d:344
msgid "C compiler"
msgstr "Compilador de C"

#: misc.d:545
#, lisp-format
msgid "~S: Lisp value ~S is not found in table ~S: ~S"
msgstr "~S: el valor ~S de Lisp no se ha encontrado en la tabla ~S: ~S"

#: time.d:765
#, lisp-format
msgid "~S: too large shift amount ~S"
msgstr "~S: el tamaño del desplazamiento es muy grande ~S"

#: predtype.d:1765 predtype.d:2004
#, lisp-format
msgid "~S: unidentifiable type!!!"
msgstr "~S: a¡tipo irreconocible!!!"

#: predtype.d:2010
#, lisp-format
msgid "~S: type ~S does not correspond to a class"
msgstr "~S: el tipo ~S no se corresponde con una clase"

#: predtype.d:2038
#, lisp-format
msgid "~S: ~S does not name a class"
msgstr "~S: ~S no es el nombre de una clase"

#: predtype.d:2157
#, lisp-format
msgid "~S: type definition for ~S exceeds depth limit, maybe recursive"
msgstr "~S: definición de tipo para ~S excede límite de profundidad, quizá por recursivo"

#: predtype.d:2476 type.lisp:32
#, lisp-format
msgid "~S: invalid type specification ~S"
msgstr "~S: invalidada especificación de tipo ~S"

#: predtype.d:2484
#, lisp-format
msgid "~S: ~S cannot be coerced to type ~S"
msgstr "~S: ~S no puede convertirse al tipo ~S"

#: symbol.d:17
#, lisp-format
msgid "~S: the property list of ~S has an odd length"
msgstr "~S: la lista de propiedades de ~S tiene longitud impar"

#: symbol.d:89
#, lisp-format
msgid "~S: ~S is not a system function"
msgstr "~S: ~S no es una función del sistema"

#: symbol.d:348
#, lisp-format
msgid "The value of *GENSYM-COUNTER* was not a nonnegative integer. Old value ~S. New value ~S."
msgstr "El valor de *GENSYM-COUNTER* no era un entero no negativo. Valor anterior ~S. Nuevo valor ~S."

#: lisparit.d:324
#, lisp-format
msgid "~S: argument should be a positive fixnum, not ~S"
msgstr "~S: un argumento debe ser un número positivo del tipo FIXNUM, no ~S"

#: lisparit.d:348
#, lisp-format
msgid "~S: ~S is not a number"
msgstr "~S: ~S no es un número"

#: lisparit.d:365
#, lisp-format
msgid "~S: ~S is not a real number"
msgstr "~S: ~S no es un número real"

#: lisparit.d:392
#, lisp-format
msgid "~S: ~S is not a floating-point number"
msgstr "~S: ~S no es un número de coma flotante"

#: lisparit.d:418
#, lisp-format
msgid "~S: ~S is not a rational number"
msgstr "~S: ~S no es un número racional"

#: lisparit.d:1660
#, lisp-format
msgid "~S: argument should be a ~S, not ~S"
msgstr "~S: un argumento debería ser un ~S, no ~S"

#: lisparit.d:1672
#, lisp-format
msgid "~S: the value of ~S should be a ~S, not ~S"
msgstr "~S: el valor de ~S debería ser un ~S, no ~S"

#: lisparit.d:1695
#, lisp-format
msgid "~S: argument should be positive and an integer or float, not ~S"
msgstr "~S: un argumento debería ser un número positivo del tipo INTEGER o FLOAT, no ~S"

#: aridecl.d:347
#, lisp-format
msgid "~S: division by zero"
msgstr "~S: división por cero"

#: aridecl.d:356
#, lisp-format
msgid "~S: floating point overflow"
msgstr "~S: sobredesbordamiento de coma flotante"

# Duda: Lo del desbordamiento inferior de coma flotante ha sido
# traducción super libre mía ;) Este mensaje ocurre cuando el resultado
# (expresado en coma flotante) ocurre mucho más cerca del cero de lo que
# permite la representación de números en coma flotante. Por ejemplo:
# 2.3e-30 * 2.3e-30 sería 5.29e-60 que excedió el límite inferior.
#
#: aridecl.d:365
#, lisp-format
msgid "~S: floating point underflow"
msgstr "~S: subdesbordamiento de coma flotante"

#: intelem.d:207 intelem.d:317
#, lisp-format
msgid "not a 32-bit integer: ~S"
msgstr "no un entero de 32 bit: ~S"

#: intelem.d:388 intelem.d:504
#, lisp-format
msgid "not a 64-bit integer: ~S"
msgstr "no un entero de 64 bit: ~S"

#: intelem.d:1108
msgid "bignum overflow"
msgstr "desbordamiento de números grandes"

#: intlog.d:424
#, lisp-format
msgid "~S: ~S is not a valid boolean operation"
msgstr "~S: ~S no es una operación lógica válida"

#: intlog.d:533
#, lisp-format
msgid "~S: index ~S is negative"
msgstr "~S: el índice ~S es negativo"

#: intlog.d:665
#, lisp-format
msgid "~S: shift ~S is too large"
msgstr "~S: desplazamiento ~S es demasiado grande"

# Duda: En Lisp existe un tipo predeterminado: `fixnum'. Por ese motivo,
# dejo sin traducir este término.
#
#: intbyte.d:13
#, lisp-format
msgid "The arguments to BYTE must be fixnums >=0: ~S, ~S"
msgstr "Los argumentos de BYTE deben ser números enteros del tipo FIXNUM >=0: ~S, ~S"

#: intbyte.d:33
#, lisp-format
msgid "~S is not a BYTE specifier"
msgstr "~S no es un especificador de BYTE"

#: intmal.d:8
msgid "overflow during multiplication of large numbers"
msgstr "desbordamiento durante la multiplicación de números grandes"

#: intdiv.d:383
#, lisp-format
msgid "quotient ~S / ~S is not an integer"
msgstr "el cociente ~S / ~S no es un entero"

# Duda: long-float es un tipo, así que lo dejo como `LONG-FLOAT'. Aunque
# Bruno Haible y Marcus Daniels lo han puesto como `long float' se
# refieren al tipo `long-float'
# Sugerencia: `long float'. sv
#
# No estoy de acuerdo con la sugerencia. No se trata de que `long' sea
# un adjetivo de `float', sino que en CLisp existe el tipo "long-float"
# (Common Lisp The Language, 2nd edition, Guy L. Steele, pag. 39). De
# hecho, en muchos otros sitios de CLisp se pone "long-float". Más aún,
# la traducción francesa de este mensaje es: "LONG-FLOAT trop long".
#
# De hecho, en mi opinion, Bruno Haible y Marcus Daniels se equivocaron
# aquí y debían haber puesto el guión. cll
#
#: lfloat.d:7
msgid "long float too long"
msgstr "LONG-FLOAT demasiado largo"

#: flo_konv.d:429
#, lisp-format
msgid "~S: floating point NaN occurred"
msgstr "~S: coma flotante NaN ocurrido"

#: flo_rest.d:39
#, lisp-format
msgid "Floating point operation combines numbers of different precision. See ANSI CL 12.1.4.4 and the CLISP impnotes for details. The result's actual precision is controlled by ~S. To shut off this warning, set ~S to ~S."
msgstr "Las operaciones en coma flotante combinan números de diferentes precisiones. Vea ANSI CL  12.1.4.4 y notaciones internas de CLISP para detalles. La precisión actual del resultado está controlado por ~S. Para quitar esta advertencia, establezca ~S a ~S."

#: realelem.d:149
#, lisp-format
msgid "Numerical operation combines exact and inexact numbers (rational numbers and floating-point numbers), and the mathematical result is exact. See ANSI CL 12.1.4.1 and the CLISP impnotes for details. The result's actual exactness is controlled by ~S. To shut off this warning, set ~S to ~S."
msgstr "La operación numérica combina números exactos e inexantos (números racionales y coma flotante),y el resultado matemático es exacto. Vea ANSI CL 12.1.4.1 y las notas de implementación de CLISP para detalles. La precisión actual del resultado está controlada por ~S. Para quitar este aviso, establezca el valor de ~S a ~S."

#: funarg.d:107
#, lisp-format
msgid "~S: must not specify both :TEST and :TEST-NOT arguments"
msgstr "~S: no debe especificar ambos argumentos :TEST y :TEST-NOT simultaneamente"

#: foreign.d:21
#, lisp-format
msgid "~S: argument is not a foreign object: ~S"
msgstr "~S: un argumento no es un objeto externo: ~S"

#: foreign.d:63
#, lisp-format
msgid "~S: argument ~S should be a ~S, ~S or ~S"
msgstr "~S: un argumento ~S debería ser un ~S, ~S, o ~S"

#: foreign.d:121
#, lisp-format
msgid "~S: must not invalidate the sole FFI session pointer"
msgstr "~S: no debe ser invariante el puntero de sesión FFI único"

#: foreign.d:127
#, lisp-format
msgid "~S: cannot resurrect the zombie ~S"
msgstr "~S: no se puede devolver el zombie ~S"

#: foreign.d:201
#, lisp-format
msgid "Foreign variable ~S already exists"
msgstr "Variable externa ~S ya existente"

# Duda: he traducido `foreign' por `ajeno/a'.
#
# Lo he pensado mejor y `extranjera' me gusta mucho más, ..., ¿qué os
# parece? cll
#
#: foreign.d:235
#, lisp-format
msgid "Foreign function ~S already exists"
msgstr "Función externa ~S ya existente"

#: foreign.d:262
#, lisp-format
msgid "No foreign int type of size ~S"
msgstr "Ningún tipo int externo de tamaño ~S"

#: foreign.d:279
#, lisp-format
msgid "Cannot redefine foreign type ~S from ~S to ~S"
msgstr "No puede redefinir tipo externo ~S desde ~S hasta ~S"

#: foreign.d:289
#, lisp-format
msgid "No foreign int type named ~S"
msgstr "Ningún tipo int externo nombrado ~S"

#: foreign.d:321
#, lisp-format
msgid "~S: illegal foreign data type ~S"
msgstr "~S: Tipo de datos externos no válido ~S"

#: foreign.d:329
#, lisp-format
msgid "~S: ~S cannot be converted to the foreign type ~S"
msgstr "~S: ~S no puede ser convertido en un tipo externo ~S"

#: foreign.d:337
#, lisp-format
msgid "~S: 64 bit integers are not supported on this platform and with this C compiler: ~S"
msgstr "~S: enteros de 64 bit no son compatibles en esta plataforma y con este compilador de C: ~S"

#: foreign.d:351
#, lisp-format
msgid "~S: illegal foreign function type ~S"
msgstr "~S: tipo de función externa no válido ~S"

#: foreign.d:481
#, lisp-format
msgid "~S cannot be converted to a foreign function with another calling convention."
msgstr "~S no puede ser convertido a una función externa con otra convención de llamada."

#: foreign.d:1108
#, lisp-format
msgid "~S: element type has size 0: ~S"
msgstr "~S: el tipo del elemento tiene tamaño 0: ~S"

#: foreign.d:1116
#, lisp-format
msgid "~S: trying to read an object of type ~S from NULL address"
msgstr "~S: probando leer un objeto de tipo ~S dentro de una dirección NULL"

#: foreign.d:1936
#, lisp-format
msgid "~S: trying to write object ~S of type ~S into NULL address"
msgstr "~S: intentando escribir el objeto ~S de tipo ~S dentro de una dirección NULL"

#: foreign.d:2447
#, lisp-format
msgid "~S: foreign variable with unknown type, missing DEF-C-VAR: ~S"
msgstr "~S: variable externa de tipo desconocido, se ha omitido DEF-C-VAR: ~S"

#: foreign.d:2463
#, lisp-format
msgid "~S: foreign variable ~S does not exist"
msgstr "~S: variable externa ~S no existe"

#: foreign.d:2464
msgid "Skip foreign variable creation"
msgstr "Omitir una creación de variable externa"

#: foreign.d:2478
#, lisp-format
msgid "~S: foreign variable ~S does not have the required size or alignment"
msgstr "~S: la variable externa ~S no tiene el tamaño o alineamiento requerido"

#: foreign.d:2489
#, lisp-format
msgid "~S: type specifications for foreign variable ~S conflict: ~S and ~S"
msgstr "~S: especificación de tipo para variable externa ~S en conflicto: ~S y ~S"

#: foreign.d:2515
#, lisp-format
msgid "~S(~S): version ~S without library does not make sense"
msgstr "~S(~S): versión ~S sin biblioteca no distinguible"

#: foreign.d:2534
#, lisp-format
msgid "~S: foreign variable ~S does not have the required alignment"
msgstr "~S: la variable externa ~S no tiene el alineamiento requerido"

#: foreign.d:2611
#, lisp-format
msgid "~S: foreign variable ~S may not be modified"
msgstr "~S: no se puede modificar la variable externa ~S"

#: foreign.d:2657
#, lisp-format
msgid "~S: foreign variable ~S of type ~S is not an array"
msgstr "~S: la variable externa ~S del tipo ~S no es una matriz"

#: foreign.d:2733
#, lisp-format
msgid "~S: foreign variable ~S of type ~S is not a pointer"
msgstr "~S: la variable externa ~S del tipo ~S no es un puntero"

#: foreign.d:2841
#, lisp-format
msgid "~S: foreign variable ~S of type ~S is not a struct or union"
msgstr "~S: la variable externa ~S del tipo ~S no es, ni una estructura, ni una unión"

#: foreign.d:2848
#, lisp-format
msgid "~S: foreign variable ~S of type ~S has no component with name ~S"
msgstr "~S: la variable externa ~S del tipo ~S no tiene ningún componente con el nombre ~S"

#: foreign.d:3185
#, lisp-format
msgid "~S: ~S has no type, :FULL is illegal"
msgstr "~S: ~S no tiene tipo, :FULL es ilegal"

#: foreign.d:3210
#, lisp-format
msgid "~S: foreign function with unknown calling convention, missing DEF-CALL-OUT: ~S"
msgstr "~S: función externa con convención de llamada desconocida, se ha omitido DEF-CALL-OUT: ~S"

#: foreign.d:3228
#, lisp-format
msgid "~S: foreign function ~S does not exist"
msgstr "~S: función externa ~S no existe"

# Duda: he traducido `foreign' por `ajeno/a'.
#
# Lo he pensado mejor y `extranjera' me gusta mucho más, ..., ¿qué os
# parece? cll
#
#: foreign.d:3229
msgid "Skip foreign function creation"
msgstr "Omitir una creación de función externa"

#: foreign.d:3236
#, lisp-format
msgid "~S: calling conventions for foreign function ~S conflict"
msgstr "~S: conflicto en la convención de llamada de la función externa ~S"

#: foreign.d:3563 foreign1.lisp:1261
#, lisp-format
msgid "~S: :OUT argument is not a pointer: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: foreign.d:4215
#, lisp-format
msgid "~S: ~S is not supported on this platform."
msgstr "~S: ~S sin mantenimiento para esta plataforma."

#: foreign.d:4234
#, lisp-format
msgid "~S: Cannot open library ~S: ~S"
msgstr "~S: No se puede abrir la biblioteca ~S: ~S"

#: foreign.d:4236
#, lisp-format
msgid "~S: Cannot open library ~S"
msgstr "~S: No se puede abrir la biblioteca ~S"

#: foreign.d:4306
#, lisp-format
msgid "~S: no dynamic object named ~S in library ~S"
msgstr "~S: ningún objeto dinámico nombrado ~S dentro de la biblioteca ~S"

#: foreign.d:4307
#, lisp-format
msgid "~S: no dynamic object named ~S (version ~S) in library ~S"
msgstr "~S: ningún objeto dinámico nombrado ~S (versión ~S) dentro de la biblioteca ~S"

#: foreign.d:4308
msgid "Skip foreign object creation"
msgstr "Omitir una creación de objeto externo"

#: foreign.d:4591
#, lisp-format
msgid "~S: cannot find ~S in ~S due to lack of dlsym() on this platform"
msgstr "~S: no puede encontrar ~S dentro de ~S debido a la falta de dlsym() en esta plataforma"

#: foreign.d:4655
#, lisp-format
msgid "~S(~S): dladdr() failed: ~S"
msgstr "~S(~S): dladdr() fallado: ~S"

#: foreign.d:4657
#, lisp-format
msgid "~S(~S): dladdr() failed"
msgstr "~S(~S): dladdr() fallado"

#: init.lisp:271 format.lisp:367
#, lisp-format
msgid "The destination argument ~S is invalid (not NIL or T or a stream or a string)."
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

#: init.lisp:301 format.lisp:391 format.lisp:2547
#, lisp-format
msgid "~S: The control-string must be a string, not ~S"
msgstr "~S: La cadena de control debe ser una cadena, y no ~S"

#: init.lisp:314 init.lisp:2250 condition.lisp:1618 reploop.lisp:486
msgid "Continuable Error"
msgstr "Error Continuable"

#: init.lisp:550
msgid "special operator"
msgstr "un operador especial"

#: init.lisp:555
msgid "macro"
msgstr "macro"

#: init.lisp:561 trace.lisp:175
msgid "function"
msgstr "función"

#: init.lisp:616
#, lisp-format
msgid "~A: ~S is a special operator and may not be redefined."
msgstr "~A: ~S es una operadora especial y puede no ser redefinida."

#: init.lisp:679
#, lisp-format
msgid "~A: redefining ~A ~S in ~A, was defined in ~A"
msgstr "~A: redefiniendo ~A ~S dentro de ~A, estaba definida en ~A"

#: init.lisp:709
#, lisp-format
msgid "~A: redefining ~S; it was traced!"
msgstr "~A: redefiniendo ~S; ¡estaba rastreada!"

#: init.lisp:723
#, lisp-format
msgid "~S is impossible in compiled code"
msgstr "~S es imposible en código compilado"

#: init.lisp:809
#, lisp-format
msgid "~S is an invalid function environment"
msgstr "~S es un entorno de función no válido"

#: init.lisp:870
#, lisp-format
msgid "~S is an invalid variable environment"
msgstr "~S es un entorno de variable no válido"

#: init.lisp:898 compiler.lisp:3473
#, lisp-format
msgid "Illegal syntax in ~A: ~S"
msgstr "Sintaxis ilegal en ~A: ~S"

#: init.lisp:946
#, lisp-format
msgid "~S: ~S is illegal since ~S is a local macro"
msgstr "~S: ~S es no válido, puesto que ~S es una macro local"

#: init.lisp:949
#, lisp-format
msgid "~S: invalid function environment ~S"
msgstr "~S: ~S es un entorno de función no válido"

#: init.lisp:955
#, lisp-format
msgid "~S: ~S is invalid since ~S is not a symbol"
msgstr "~S: ~S es incorrecto, puesto que ~S no es un símbolo"

#: init.lisp:1107
#, lisp-format
msgid "code after MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de MACROLET contiene una lista punteada que termina con ~S"

#: init.lisp:1140
#, lisp-format
msgid "code after SYMBOL-MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de SYMBOL-MACROLET contiene una lista punteada que termina con ~S"

#: init.lisp:1152 compiler.lisp:5829
#, lisp-format
msgid "~S: symbol ~S must not be declared SPECIAL and a macro at the same time"
msgstr "~S: el símbolo ~S no debe ser declarado ESPECIAL y una macro al mismo tiempo"

#: init.lisp:1165
#, lisp-format
msgid "~S: symbol ~S is declared special and must not be declared a macro"
msgstr "~S: símbolo ~S está declarado especial y no debe ser declarado como macro"

#: init.lisp:1194
#, lisp-format
msgid "bad function environment occurred in ~S: ~S"
msgstr "se ha encontrado un entorno de función equivocado en ~S: ~S"

#: init.lisp:1203
#, lisp-format
msgid "~S: invalid form ~S"
msgstr "~S: forma no válida ~S"

#: init.lisp:1220
#, lisp-format
msgid "code contains a dotted list, ending with ~S"
msgstr "el código contiene una lista punteada que termina con ~S"

#: init.lisp:1296
#, lisp-format
msgid "lambda list must not end with the atom ~S"
msgstr "la lista lambda no debe terminar con el átomo ~S"

#: init.lisp:1325 init.lisp:1342
#, lisp-format
msgid "~S: variable list ends with the atom ~S"
msgstr "~S: la lista de variables termina con el átomo ~S"

#: init.lisp:1439
#, lisp-format
msgid "FLET/LABELS: code contains a dotted list, ending with ~S"
msgstr "FLET/LABELS: el código contiene una lista punteada que termina con ~S"

#: init.lisp:1465
#, lisp-format
msgid "FUNCTION-MACRO-LET: code contains a dotted list, ending with ~S"
msgstr "FUNCTION-MACRO-LET: El código de contiene una lista de punteados, finalizando con ~S"

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: init.lisp:1558 condition.lisp:1653
msgid "WARNING:"
msgstr "ADVERTENCIA:"

#: init.lisp:1602
#, lisp-format
msgid "~S: compiled file ~A lacks a version marker"
msgstr "~S: fichero compilado ~A le falta una versión de marcador"

#: init.lisp:1604
#, lisp-format
msgid "~S: compiled file ~A has a corrupt version marker ~S"
msgstr "~S: fichero ~A compilado tiene un marcador de versión ~S corrupto"

#: init.lisp:1606
#, lisp-format
msgid "~S: compiled file ~A was created by an older CLISP version and needs to be recompiled"
msgstr "~S: fichero compilado ~A ha sido creado por una versión anterior de CLISP y requiere ser recompilado."

#: init.lisp:1726
#, lisp-format
msgid "~S: A file with name ~A does not exist"
msgstr "~S: Un fichero con nombre ~A no existe"

#: init.lisp:1748
#, lisp-format
msgid "Loading file ~A ..."
msgstr "Cargando lista ~A ..."

#: init.lisp:1783 defs1.lisp:521
#, lisp-format
msgid "Loaded file ~A"
msgstr "Cargando fichero ~A"

#: init.lisp:1797
#, lisp-format
msgid "~S: missing function name and/or parameter list"
msgstr "~S: no se ha indicado el nombre de la función y/o la lista de parámetros"

#: init.lisp:1807
#, lisp-format
msgid "~S: special operator ~S cannot be redefined."
msgstr "~S: operador especial ~S no puede ser redefinido."

#: init.lisp:1842 macros1.lisp:155
#, lisp-format
msgid "exit clause in ~S must be a list"
msgstr "la cláusula exit en ~S debe ser una lista"

#: init.lisp:2004
#, lisp-format
msgid "~S: cannot define a function from that: ~S"
msgstr "~S: no se puede definir una función desde esa: ~S"

#: init.lisp:2010 clos-genfun3.lisp:101 clos-genfun3.lisp:179
#, lisp-format
msgid "~S: the name of a function must be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: init.lisp:2016
#, lisp-format
msgid "~S: function ~S is missing a lambda list"
msgstr "~S: la función ~S debe tener una lista lambda"

#: init.lisp:2257 condition.lisp:1625 reploop.lisp:513
msgid "If you continue (by typing 'continue'): "
msgstr "Si continúa (tecleando `continue'): "

#: backquote.lisp:67
#, lisp-format
msgid "~S: unquotes may occur only in (...) or #(...) forms"
msgstr "~S: desencomillados pueden ocurrir únicamente en estructuras (...) o #(...)"

# Duda: Aquí, igual que en el caso de la traducción francesa, he
# preferido preservar el término `backquote' y ---porque así se ha
# decidido en Spanish GNU Translation Team---, el término está con
# comillas simples.
#
# He tomado esta decisión porque el `backquote' (que es la tilde
# invertida `) es un término muy familiar para todos los programadores
# de Lisp que, con toda seguridad, conocerán.
#
#: backquote.lisp:85
#, lisp-format
msgid "~S: comma is illegal outside of backquote"
msgstr "~S: la coma es no válida fuera del `backquote'"

#: backquote.lisp:90
#, lisp-format
msgid "~S: more commas out than backquotes in, is illegal"
msgstr "~S: no se pueden emplear más comas fuera que apóstrofes invertidos dentro"

#: backquote.lisp:95
#, lisp-format
msgid "~S: unquotes may not occur in structures"
msgstr "~S: descomillados pueden no ocurrir estructuras"

#: backquote.lisp:100
#, lisp-format
msgid "~S: unquotes may not occur in arrays"
msgstr "~S: descomillados pueden no ocurrir en matrices"

#: backquote.lisp:131
msgid "the syntax `,@form is invalid"
msgstr "la sintaxis `,@form no es válida"

#: backquote.lisp:132
msgid "the syntax `,.form is invalid"
msgstr "la sintaxis  `,.form no es válida"

#: backquote.lisp:136 backquote.lisp:152
#, lisp-format
msgid "READ: ~@?"
msgstr "¿LECTURA: ~@?"

#: backquote.lisp:147
msgid "the syntax `( ... . ,@form) is invalid"
msgstr "la sintaxis `( ... . ,@form) no es válida"

#: backquote.lisp:148
msgid "the syntax `( ... . ,.form) is invalid"
msgstr "la sintaxis `( ... . ,@form) no es válida"

#: defmacro.lisp:50
#, lisp-format
msgid "The macro ~S may not be called with a circular argument list: ~S"
msgstr "La macro ~S no puede ser invocada con un argumento de lista circular: ~S"

#: defmacro.lisp:56
#, lisp-format
msgid "The macro ~S may not be called with a dotted argument list: ~S"
msgstr "La macro ~S no puede ser invocada con un argumento punteado: ~S"

#: defmacro.lisp:61
#, lisp-format
msgid "The macro ~S may not be called with ~S arguments: ~S"
msgstr "La macro ~S no puede ser invocada con ~S argumentos: ~S"

#: defmacro.lisp:68 defmacro.lisp:434
#, lisp-format
msgid "~S: ~S does not match lambda list element ~:S"
msgstr "~S: ~S no coincide con lista de elemento lambda ~:S"

#: defmacro.lisp:139 defmacro.lisp:180 defmacro.lisp:268
#, lisp-format
msgid "The rest of the lambda list will be ignored."
msgstr "El resto de la lista lambda será ignorado."

#: defmacro.lisp:140 defmacro.lisp:181
#, lisp-format
msgid "The lambda list of macro ~S contains a dot after ~S."
msgstr "La lista lambda de la macro ~S contiene un punto después de ~S."

#: defmacro.lisp:147
#, lisp-format
msgid "in macro ~S: ~S may not be used as &AUX variable."
msgstr "en la macro ~S: ~S no debe usarse como una variable &AUX."

#: defmacro.lisp:158
#, lisp-format
msgid "~S: invalid supplied-p variable ~S"
msgstr "~S: invalidada variable suministrada-p ~S"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
#: defmacro.lisp:189 defmacro.lisp:334
#, lisp-format
msgid "It will be ignored."
msgstr "Será ignorado."

#: defmacro.lisp:190 defmacro.lisp:335
#, lisp-format
msgid "The lambda list of macro ~S contains a badly placed ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S mal situado."

#: defmacro.lisp:203
#, lisp-format
msgid "The lambda list of macro ~S contains the invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene el elemento no válido ~S"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# No tengo ni idea de qué significa ese "0*"
#: defmacro.lisp:215
#, lisp-format
msgid "~0*It will be ignored."
msgstr "~0*Será ignorado."

#: defmacro.lisp:216
#, lisp-format
msgid "The lambda list of macro ~S contains an invalid keyword specification ~S"
msgstr "La lista lambda de la macro ~S contiene una especificación de argumento clave no válida: ~S"

#: defmacro.lisp:250
#, lisp-format
msgid "The lambda list of macro ~S is missing a variable after &REST/&BODY."
msgstr "La lista lambda de la macro ~S necesita una variable después de &REST/&BODY."

#: defmacro.lisp:261
#, lisp-format
msgid "The lambda list of macro ~S contains an illegal variable after &REST/&BODY: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable no válida después de &REST/&BODY: ~S"

#: defmacro.lisp:269
#, lisp-format
msgid "The lambda list of macro ~S contains a misplaced dot."
msgstr "La lista lambda de la macro ~S contiene un punto mal situado."

# Ojo. sv
#
# :) Vale :) cll
#
#: defmacro.lisp:273
#, lisp-format
msgid "They will be ignored."
msgstr "Serán ignorados."

#: defmacro.lisp:274
#, lisp-format
msgid "The lambda list of macro ~S contains superfluous elements: ~S"
msgstr "La lista lambda de la macro ~S contiene elementos innecesarios: ~S"

#: defmacro.lisp:325
#, lisp-format
msgid "The lambda list of macro ~S contains an illegal &REST variable: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable &REST no válida: ~S"

#: defmacro.lisp:347
#, lisp-format
msgid "The lambda list of macro ~S contains an invalid &WHOLE: ~S"
msgstr "La lista lambda de la macro ~S contiene un &WHOLE no válido: ~S"

#: defmacro.lisp:351
#, lisp-format
msgid "The lambda list of macro ~S contains a superfluous ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S innecesario."

#: defmacro.lisp:363
#, lisp-format
msgid "The lambda list of macro ~S contains ~S before &KEY."
msgstr "La lista lambda de la macro ~S contiene ~S antes de &KEY."

#: defmacro.lisp:366
#, lisp-format
msgid "The lambda list of macro ~S contains ~S which is illegal here."
msgstr "La lista lambda de la macro ~S contiene ~S, lo cual es incorrecto aquí."

#: defmacro.lisp:385
#, lisp-format
msgid "The lambda list of macro ~S contains an invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene un elemento no válido: ~S"

#: defmacro.lisp:456
#, lisp-format
msgid "In the lambda list of macro ~S, &ENVIRONMENT must be followed by a non-NIL symbol: ~S"
msgstr "En la lista lambda de la macro ~S, &ENVIRONMENT debe estar seguido de un símbolo no nulo: ~S"

#: defmacro.lisp:481
#, lisp-format
msgid "Cannot define a macro from that: ~S"
msgstr "No se puede definir una macro a partir de: ~S"

#: defmacro.lisp:487
#, lisp-format
msgid "The name of a macro must be a symbol, not ~S"
msgstr "El nombre de una macro debe ser un símbolo, no ~S"

#: defmacro.lisp:493
#, lisp-format
msgid "Macro ~S is missing a lambda list."
msgstr "La macro ~S necesita una lista lambda."

#: macros1.lisp:25 macros1.lisp:48
#, lisp-format
msgid "~S: non-symbol ~S cannot be a variable"
msgstr "~S: sólo los símbolos pueden ser variables, y no ~S"

#: macros1.lisp:31 macros1.lisp:54
#, lisp-format
msgid "~S: the constant ~S must not be redefined to be a variable"
msgstr "~S: la constante ~S no debe redefinirse como una variable"

#: macros1.lisp:68
#, lisp-format
msgid "~S: non-symbol ~S cannot be defined constant"
msgstr "~S: ~S no simbólico no puede ser definido como constante"

#: macros1.lisp:104
#, lisp-format
msgid "~S redefines the constant ~S. Its old value was visually similar though. Set ~S to avoid this warning."
msgstr "~S redefine la constante ~S. Su valor anterior era visualmente similar a persar. Establezca ~S para quitar esta advertencia."

#: macros1.lisp:107
#, lisp-format
msgid "~S redefines the constant ~S. Its old value was ~S."
msgstr "~S redefine la constante ~S. Su valor anterior era ~S."

#: macros1.lisp:161
#, lisp-format
msgid "Invalid syntax in ~S form: ~S."
msgstr "Sintaxis no válida en la forma ~S: ~S."

#: macros1.lisp:261 places.lisp:619 places.lisp:839
#, lisp-format
msgid "~S called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: macros1.lisp:299
#, lisp-format
msgid "~S: missing key list"
msgstr "~S: falta la lista de claves"

#: macros1.lisp:428
#, lisp-format
msgid "Not a list of COND clauses: ~S"
msgstr "No es una lista de cláusulas COND: ~S"

#: macros1.lisp:434
#, lisp-format
msgid "The atom ~S must not be used as a COND clause."
msgstr "El átomo ~S no debe usarse como una cláusula COND."

#: macros2.lisp:13
#, lisp-format
msgid "Invalid clause in ~S: ~S"
msgstr "Cláusula no válida en ~S: ~S"

#: macros2.lisp:26
#, lisp-format
msgid "~A~%The value is: ~S"
msgstr "~A~%El valor es: ~S"

#: macros2.lisp:29
#, lisp-format
msgid "The value of ~S should be ~:[of type ~S~;~:*~A~]."
msgstr "El valor de ~S debe ser ~:[del tipo ~S~;~:*~A~]."

#: macros2.lisp:32
#, lisp-format
msgid "Input a new value for ~S."
msgstr "Introduzca un valor nuevo para ~S."

#: macros2.lisp:34
#, lisp-format
msgid "Input a value to be used instead~@[ of ~S~]."
msgstr "Introduzca un valor para ser empleado~@[ de ~S~]."

#: macros2.lisp:36
#, lisp-format
msgid "New ~S"
msgstr "Crear ~S"

#: macros2.lisp:53
msgid "Retry"
msgstr "Reintentar"

#: macros2.lisp:55
#, lisp-format
msgid "Input new values for ~@{~S~^, ~}."
msgstr "Introduzca valores nuevos para ~@{~S~^, ~}."

#: macros2.lisp:58
#, lisp-format
msgid "~S must evaluate to a non-NIL value."
msgstr "~S no puede evaluarse como NIL."

#: macros2.lisp:84
#, lisp-format
msgid "The value of ~S must be of one of the types ~{~S~^, ~}"
msgstr "El valor de ~S debe ser de uno de los tipos ~{~S~^, ~}"

#: macros2.lisp:88
#, lisp-format
msgid "The value of ~S must be one of ~{~S~^, ~}"
msgstr "El valor de ~S debe ser uno de los siguientes ~{~S~^, ~}"

#: macros2.lisp:103 condition.lisp:1456
#, lisp-format
msgid "~S used as a key in ~S, it would be better to use parentheses."
msgstr "~S empleado como una clave en ~S, sería mejor utilizar paréntesis."

#: macros2.lisp:177
#, lisp-format
msgid "~S is a built-in type and may not be redefined."
msgstr "~S es un tipo predefinido y no puede ser redefinido."

#: macros2.lisp:206
#, lisp-format
msgid "The deftype expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de DEFTYPE para ~S no puede invocarse con ~S argumentos."

#: macros2.lisp:216
#, lisp-format
msgid "~S: the name of a symbol macro must be a symbol, not ~S"
msgstr "~S: el nombre de un símbolo de macro debe ser un símbolo, no ~S"

#: defs1.lisp:87
#, lisp-format
msgid "missing symbol types (~S/~S/~S) in ~S"
msgstr "faltando tipos simbólicos (~S/~S/~S) en ~S"

#: defs1.lisp:95
#, lisp-format
msgid "~S: flag must be one of the symbols ~S, ~S, ~S, not ~S"
msgstr "~S: la clausula debe ser luna de los símbolos ~S, ~S, ~S, no ~S"

#: defs1.lisp:502
#, lisp-format
msgid "~S: ~S does not name a logical host"
msgstr "~S: ~S no es el nombre de un anfitrión \"lógico\""

#: defs1.lisp:519
#, lisp-format
msgid "Loading logical hosts from file ~A ..."
msgstr "Cargando hospedadores lógicos desde el fichero ~A ..."

#: defs1.lisp:524 defs1.lisp:532
#, lisp-format
msgid "Defined logical host ~A"
msgstr "Anfitrión lógico definido ~A"

#: defs1.lisp:530
#, lisp-format
msgid "Loading logical host from file ~A ..."
msgstr "Cargando hospedador lógico desde el fichero ~A ..."

#: defs1.lisp:561
#, lisp-format
msgid "No translations for logical host ~S found"
msgstr "Sin traslación para un anfitrión lógico ~S encontrado"

#: defs1.lisp:623
#, lisp-format
msgid "~S: argument ~S should be a nonnegative number"
msgstr "~S: un argumento ~S debería ser un número no negativo"

#: defs1.lisp:783
#, lisp-format
msgid "incorrect date: ~S-~S-~S ~S:~S:~S, time zone ~S"
msgstr "fecha incorrecta: ~S-~S-~S ~S:~S:~S, zona horaria ~S"

#: lambdalist.lisp:16
#, lisp-format
msgid "Lambda list marker ~S not allowed here."
msgstr "El marcador de la lista lambda ~S no está permitido aquí."

#: lambdalist.lisp:21
#, lisp-format
msgid "Invalid lambda list element ~S"
msgstr "Elemento de lista lambda ~S no válido"

#: lambdalist.lisp:22
#, lisp-format
msgid "Invalid lambda list element ~S. A lambda list may only contain symbols and lists."
msgstr "Lista de elemento lambda no válida ~S. Una lista lambda puse contener únicamente símbolos y listas."

#: lambdalist.lisp:26
#, lisp-format
msgid "Invalid lambda list element ~S. ~S parameters cannot have default value forms in generic function lambda lists."
msgstr "Lista de elemento lambda no válida ~S. Parámetros ~S no pueden tener formatos de valor predeterminados en listas de función lambda genérica."

#: lambdalist.lisp:40
#, lisp-format
msgid "Lambda lists with dots are only allowed in macros, not here: ~S"
msgstr "Sólo se permiten las listas lambda con puntos en la macros, no aquí: ~S"

#: lambdalist.lisp:53
#, lisp-format
msgid "Missing ~S parameter in lambda list ~S"
msgstr "Falta parámetro ~S en lista lambda ~S"

#: lambdalist.lisp:76
#, lisp-format
msgid "Duplicate variable name ~S"
msgstr "Nombre variable duplicado ~S"

#: lambdalist.lisp:151
#, lisp-format
msgid "Lambda list element ~S is superfluous. Only one variable is allowed after ~S."
msgstr "El elemento ~S de la lista lambda es innecesario. Sólo una variablle está permitida después de ~S."

#: lambdalist.lisp:152
#, lisp-format
msgid "Lambda list element ~S is superfluous. No variable is allowed right after ~S."
msgstr "El elemento ~S de la lista lambda es innecesario. Ninguna variable está permitida tras ~S."

#: lambdalist.lisp:153
#, lisp-format
msgid "Lambda list element ~S (after ~S) is superfluous."
msgstr "El elemento ~S de la lista lambda (posterior de ~S) es innecesario."

#: places.lisp:24
#, lisp-format
msgid "The function (~S ~S) is hidden by a SETF expander."
msgstr "Una función de expansión de SETF oculta a la función (~S ~S)"

#: places.lisp:78
#, lisp-format
msgid "The argument ~S to ~S should be a keyword."
msgstr "El argumento ~S de ~S debe ser un argumento clave."

# Lo mismo de antes. A lo mejor se puede poner "modificable setf". sv
#: places.lisp:126
#, lisp-format
msgid "~S: Argument ~S is not a SETF place."
msgstr "~S: Argumento ~S no es un lugar SETF."

#: places.lisp:135
#, lisp-format
msgid "SETF place ~S should produce exactly one store variable."
msgstr "lugar SETF ~S podría generar exactamente una variable de almacenamiento."

#: places.lisp:343
#, lisp-format
msgid "The name of the accessor must be a symbol, not ~S"
msgstr "El nombre de la función de acceso debe ser un símbolo, no ~S"

# Duda: En esta y otras partes de este archivo .po aparece la expresión
# `expander' (¡expansor es horrible!). Me dio muchisimos quebraderos de
# cabeza, pero muchos y francamente, estaba absolutamente atascado
# cuando lo pregunté en las listas de Spanish GNU y CLisp.
#
# Curiosamente, la única persona que respondió no tiene ni idea de
# español (Bruno Haible):
#
# "expander" or "expansion function", I would say.
#
# ¡Pues leches, eso mismo! Función de expansión me suena
# perfectísimamente, ...
#
#: places.lisp:378
#, lisp-format
msgid "The SETF expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de SETF para ~S no puede invocarse con ~S argumentos."

#: places.lisp:390 places.lisp:406 places.lisp:463
msgid "SETF expander"
msgstr "Expansor SETF"

#: places.lisp:416
#, lisp-format
msgid "~S: Too many arguments: ~S"
msgstr "~S: Demasiados argumentos: ~S"

#: places.lisp:421
#, lisp-format
msgid "~S: The documentation string must be a string: ~S"
msgstr "~S: La cadena de la documentación debe ser una cadena: ~S"

#: places.lisp:439 places.lisp:723 clos-methcomb2.lisp:185
#, lisp-format
msgid "~S ~S: invalid ~S lambda-list: ~A"
msgstr "~S ~S: invalidación lista-lamda ~S: ~A"

#: places.lisp:473
#, lisp-format
msgid "(~S ~S): Illegal syntax."
msgstr "(~S ~S): sintaxis ilegal."

#: places.lisp:503
#, lisp-format
msgid "~S: index ~S is too large for ~S"
msgstr "~S: el índice ~S es demasiado grande para ~S"

#: places.lisp:833
#, lisp-format
msgid "~S: Illegal place: ~S"
msgstr "~S: localización no legal: ~S"

#: places.lisp:852
#, lisp-format
msgid "~S: too few arguments: ~S"
msgstr "~S: muy pocos argumentos: ~S"

#: places.lisp:1011 places.lisp:1073
#, lisp-format
msgid "~S is only defined for functions of the form #'symbol."
msgstr "~S sólo está definido para funciones de la forma #'símbolo."

# Duda: en Common Lisp existe lo que se denominan los `setf places'. En
# realidad, es una manera bastante correcta de referirse a posiciones de
# memoria (cuyos nombres pueden ser variables, funciones, etc.) que son
# modificables con la primitiva SETF de Lisp. Por ello, traducirlo como
# `modificable' es eminentemente correcto, pero en realidad me da miedo
# porque a los programadores experimentados les mosqueará lo de
# `modificable' a secas. Les resultará mucho más familiar algo como
# `setf modificables', aunque en español esto suene bastante
# regular. cll
#
# En cualquier caso, cuando uno se empeña en emplear la palabra inglesa,
# siempre queda la posibilidad de conservar la sintaxis española,
# por ejemplo: "... no es un lugar modificable `setf'" sv
#
#: places.lisp:1019
#, lisp-format
msgid "~S on ~S is not a SETF place."
msgstr "~S sobre ~S no es un lugar SETF."

#: places.lisp:1118
#, lisp-format
msgid "SETF place ~S expects different numbers of values in the true and false branches (~D vs. ~D values)."
msgstr "lugar SETF ~S espera números diferentes de valores en la ramas de verdad o falsa (valores ~D vs. ~D)."

#: floatprint.lisp:337
#, lisp-format
msgid "argument is not a float: ~S"
msgstr "el argumento no es un flotante: ~S"

#: defpackage.lisp:55
#, lisp-format
msgid "~S ~A: the symbol ~A must not be specified more than once"
msgstr "~S ~A: el símbolo ~A no debe especificarse más de una vez"

#: defpackage.lisp:78 defpackage.lisp:86
#, lisp-format
msgid "~S ~A: the ~S option must not be given more than once"
msgstr "~S ~A: no se debe poner la opción ~S más de una vez"

#: defpackage.lisp:135
#, lisp-format
msgid "~S ~A: unknown option ~S"
msgstr "~S ~A: la opción ~S es desconocida"

#: defpackage.lisp:140
#, lisp-format
msgid "~S ~A: invalid syntax in ~S option: ~S"
msgstr "~S ~A: la sintaxis de la opción ~S es no válida: ~S"

#: defpackage.lisp:145
#, lisp-format
msgid "~S ~A: not a ~S option: ~S"
msgstr "~S ~A: no se trata de una opción ~S: ~S"

#: defpackage.lisp:212
#, lisp-format
msgid "This symbol will be created."
msgstr "Este símbolo será creado."

#: defpackage.lisp:213
#, lisp-format
msgid "~S ~A: There is no symbol ~A::~A ."
msgstr "~S ~A: El símbolo ~A::~A no existe."

#: type.lisp:63 compiler.lisp:7113
#, lisp-format
msgid "~S: argument to SATISFIES must be a symbol: ~S"
msgstr "~S: un argumento para SATISFIES debe ser un símbolo: ~S"

#: type.lisp:160 condition.lisp:176
#, lisp-format
msgid "~S: type ~S is not a subtype of ~S"
msgstr "~S: el tipo ~S no es un subtipo de ~S"

# Duda: En este mensaje, el primer "~S" se sustituye por el nombre de una
# función y el segundo "~S" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: type.lisp:357
#, lisp-format
msgid "~S: dimension ~S is invalid"
msgstr "~S: dimensión ~S es no válida"

# Duda: En este mensaje, el primer "~S" se sustituye por el nombre de una
# función y el segundo "~S" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: type.lisp:362
#, lisp-format
msgid "~S: rank ~S is invalid"
msgstr "~S: rango ~S no es válido"

#: type.lisp:408
#, lisp-format
msgid "~S: argument to ~S must be *, ~S or a list of ~S: ~S"
msgstr "~S: un argumento para ~S debe ser *, ~S o una lista de ~S: ~S"

#: type.lisp:520
#, lisp-format
msgid "~S: argument to MOD must be an integer: ~S"
msgstr "~S: un argumento para MOD debe ser un entero: ~S"

#: type.lisp:528 type.lisp:537
#, lisp-format
msgid "~S: argument to ~S must be an integer or * : ~S"
msgstr "~S: un argumento para ~S debe ser un entero o * : ~S"

#: type.lisp:1110 type.lisp:1134
#, lisp-format
msgid "~S is not up-to-date with ~S for element type ~S"
msgstr "~S no está actualizado con ~S para tipo de elemento ~S"

#: clos-slotdef1.lisp:198
#, lisp-format
msgid "(~S ~S): The slot name is not specified."
msgstr "(~S ~S): el nombre de la ranura no está especificado."

#: clos-slotdef1.lisp:201
#, lisp-format
msgid "(~S ~S): The slot name should be a symbol, not ~S"
msgstr "(~S ~S): el nombre de la ranura debería ser un símbolo, no ~S"

#: clos-slotdef1.lisp:204
#, lisp-format
msgid "(~S ~S) for slot ~S: The ~S and ~S arguments can only be specified together."
msgstr "(~S ~S) para ranura ~S: Los argumentos ~S y ~S sólo pueden ser especificados juntos."

#: clos-slotdef1.lisp:209
#, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a function, not ~S"
msgstr "(~S ~S) para ranura ~S: El argumento ~S debería ser una función, no ~S"

#: clos-slotdef1.lisp:212
#, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a symbol, not ~S"
msgstr "(~S ~S) para ranura ~S: el argumento ~S debería ser un símbolo, no ~S"

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: clos-slotdef1.lisp:215
#, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a proper list of symbols, not ~S"
msgstr "(~S ~S) para ranura ~S: El argumento ~S debería ser una lista propia de símbolos, no ~S"

#: clos-slotdef1.lisp:218
#, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a string or NIL, not ~S"
msgstr "(~S ~S) para ranura ~S: El argumento ~S debería ser una cadena o un NIL, no ~S"

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: clos-slotdef1.lisp:243 clos-slotdef1.lisp:246
#, lisp-format
msgid "(~S ~S) for slot ~S: The ~S argument should be a proper list of function names, not ~S"
msgstr "(~S ~S) para ranura ~S: el argumento ~S debería ser una lista propia de nombres de función, no ~S"

#: clos-slotdef1.lisp:423
#, lisp-format
msgid "Wrong ~S result for class ~S: not a property list: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: no una lista propia: ~S"

#: clos-slotdef1.lisp:426
#, lisp-format
msgid "Wrong ~S result for class ~S, slot ~S: value of ~S is wrong: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S, ranura ~S: valor de ~S está equivocado: ~S"

#: clos-slotdef1.lisp:436 clos-slotdef1.lisp:442 clos-class3.lisp:1171 clos-class3.lisp:1177 clos-class3.lisp:1592 clos-class3.lisp:1635
#, lisp-format
msgid "Wrong ~S result for class ~S: not a subclass of ~S: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: no una subclase de ~S: ~S"

#: clos-slotdef1.lisp:462 clos-class3.lisp:208 clos-class3.lisp:219
#, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a valid slot option"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una opción de ranura válida"

#: clos-specializer1.lisp:112
#, lisp-format
msgid "~S: Some methods have been removed from their generic function, but the list in the ~S specializer was not updated."
msgstr "~S: algunos métodos han sido quitados desde sus función genérica, pero la lista en el especializador ~S no estaba actualizada."

#: clos-class1.lisp:316 clos-class1.lisp:339 clos-class1.lisp:350
#, lisp-format
msgid "(~S ~S) for class ~S: The ~S argument should be a proper list, not ~S"
msgstr "(~S ~S) para la clase ~S: el argumento ~S debería ser una lista propia, no ~S"

#: clos-class1.lisp:323
#, lisp-format
msgid "(~S ~S) for class ~S: The direct-superclasses list should consist of classes, not ~S"
msgstr "(~S ~S) para la clase ~S: la lista de superclase directa debería pertenecer de clase, no ~S"

#: clos-class1.lisp:328
#, lisp-format
msgid "(~S ~S) for class ~S: The metaclass ~S forbids more than one direct superclass: It does not support multiple inheritance."
msgstr "(~S ~S) para la clase ~S: la metaclase ~S prohibe más de una superclase directa: no es compatible con herencia múltiple."

#: clos-class1.lisp:344
#, lisp-format
msgid "(~S ~S) for class ~S: The direct slot specification ~S is not in the canonicalized form (slot-name initform initfunction)."
msgstr "(~S ~S) para la clase ~S: la especificación de ranura directa ~S no está dentro de la forma canónica (nombre-slot initform initfunction)."

#: clos-class1.lisp:355
#, lisp-format
msgid "(~S ~S) for class ~S: The direct default initarg ~S is not in canonicalized form (a property list)."
msgstr "(~S ~S) para la clase ~S: el initarg predeterminada directa ~S no está en formato canónico (una lista propietaria)."

#: clos-class1.lisp:361
#, lisp-format
msgid "(~S ~S) for class ~S: The ~S argument should be a string or NIL, not ~S"
msgstr "(~S ~S) para la clase ~S: el argumento ~S debería ser una cadena o NIL, no ~S"

#: clos-class2.lisp:98
#, lisp-format
msgid "~S: argument ~S is not a symbol"
msgstr "~S: un argumento ~S no es un símbolo"

#: clos-class2.lisp:109
#, lisp-format
msgid "~S: cannot redefine built-in class ~S"
msgstr "~S: no se puede redefinir la clase predefinida ~S"

#: clos-class2.lisp:114 describe.lisp:69
msgid "class"
msgstr "clase"

#: clos-class3.lisp:54
#, lisp-format
msgid "~S ~S: expecting list of superclasses instead of ~S"
msgstr "~S ~S: se esperaba una lista de superclases en vez de ~S"

#: clos-class3.lisp:61
#, lisp-format
msgid "~S ~S: superclass name ~S should be a symbol"
msgstr "~S ~S: el nombre de la clase matriz ~S debe ser un símbolo"

#: clos-class3.lisp:74
#, lisp-format
msgid "~S ~S: expecting list of slot specifications instead of ~S"
msgstr "~S ~S: se esperaba una lista de especificación de ranuras en vez de ~S"

#: clos-class3.lisp:84
#, lisp-format
msgid "~S ~S: Every second slot name is a keyword, and these slots have no options. If you want to define a slot with options, you need to enclose all slot specifications in parentheses: ~S, not ~S."
msgstr "~S ~S: Cada segundo el nombre de ranura es una palabra, y estas ranuras no tienen opciones. Si quiere definir una ranura con opciones, necesita encerrar todas las especificaciones de ranuras entre paréntesis: ~S, no ~S."

#: clos-class3.lisp:95
#, lisp-format
msgid "~S ~S: slot name ~S should be a symbol"
msgstr "~S ~S: el nombre de ranura ~S debería ser un símbolo"

#: clos-class3.lisp:101
#, lisp-format
msgid "~S ~S: There may be only one direct slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura directa con el nombre ~S."

#: clos-class3.lisp:116
#, lisp-format
msgid "~S ~S: slot options for slot ~S must come in pairs"
msgstr "~S ~S: las opciones de ranura para ~S no vienen por pares"

#: clos-class3.lisp:128 clos-class3.lisp:144
#, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a non-NIL symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo no NIL"

#: clos-class3.lisp:136
#, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a function name"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una función"

#: clos-class3.lisp:153
#, lisp-format
msgid "~S ~S, slot option ~S for slot ~S: ~S is not a symbol"
msgstr "~S ~S, opción de ranura ~S para la ranura ~S: ~S no es un símbolo"

#: clos-class3.lisp:159 clos-class3.lisp:175 clos-class3.lisp:184 clos-class3.lisp:192
#, lisp-format
msgid "~S ~S, slot option ~S for slot ~S may only be given once"
msgstr "~S ~S, la opción de ranura ~S para ~S solo debe indicarse una vez"

#: clos-class3.lisp:167
#, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo"

#: clos-class3.lisp:198
#, lisp-format
msgid "~S ~S, slot option for slot ~S: ~S is not a string"
msgstr "~S ~S, opción de ranura para ~S: ~S no es una cadena de caracteres"

#: clos-class3.lisp:277 clos-class3.lisp:356 clos-methcomb2.lisp:1135 clos-methcomb2.lisp:1149 clos-methcomb2.lisp:1157
#, lisp-format
msgid "~S ~S: option ~S may only be given once"
msgstr "~S ~S: opción ~S sólo puede ser dado una vez"

#: clos-class3.lisp:287 clos-class3.lisp:310 clos-methcomb2.lisp:1163
#, lisp-format
msgid "~S ~S, option ~S: ~S is not a symbol"
msgstr "~S ~S, opción ~S: ~S no es un símbolo"

#: clos-class3.lisp:298
#, lisp-format
msgid "~S ~S, option ~S: arguments must come in pairs"
msgstr "~S ~S, opción ~S: los argumentos no aparecen en pares"

#: clos-class3.lisp:316
#, lisp-format
msgid "~S ~S, option ~S: ~S may only be given once"
msgstr "~S ~S, opción ~S: ~S sólo se puede poner una vez"

#: clos-class3.lisp:331
#, lisp-format
msgid "~S ~S, option ~S: ~S is not a string"
msgstr "~S ~S, opción ~S: ~S no es una cadena de caracteres"

#: clos-class3.lisp:342 clos-class3.lisp:363 clos-class3.lisp:387 clos-genfun3.lisp:558
#, lisp-format
msgid "~S ~S: invalid option ~S"
msgstr "~S ~S: opción no válida ~S"

#: clos-class3.lisp:439 clos-class3.lisp:561
#, lisp-format
msgid "~S: class name ~S should be a symbol"
msgstr "~S: nombre de clase ~S debe ser un símbolo"

#: clos-class3.lisp:446
#, lisp-format
msgid "~S for class ~S: metaclass ~S is neither a class or a symbol"
msgstr "~S para la clase ~S: la metaclase ~S no es ni una clase ni un símbolo"

#: clos-class3.lisp:450
#, lisp-format
msgid "~S for class ~S: metaclass ~S is not a subclass of CLASS"
msgstr "~S para la clase ~S: metaclase ~S no es una subclase de CLASS"

#: clos-class3.lisp:453
#, lisp-format
msgid "~S for class ~S: The ~S argument should be a proper list, not ~S"
msgstr "~S para la clase ~S: el argumento ~S debería ser una lista propia, no ~S"

#: clos-class3.lisp:460
#, lisp-format
msgid "~S for class ~S: The direct-superclasses list should consist of classes and symbols, not ~S"
msgstr "~S para la clase ~S: la lista de superclase directa debería pertenecer de clase y símbolos, no ~S"

#: clos-class3.lisp:479
#, lisp-format
msgid "Cannot redefine ~S with a different metaclass ~S"
msgstr "No puede redefinir ~S con una metaclase diferente ~S"

#: clos-class3.lisp:568
#, lisp-format
msgid "Wrong ~S result for ~S: not a class: ~S"
msgstr "Resultado de ~S equivocado para ~S: no una clase: ~S"

#: clos-class3.lisp:598
#, lisp-format
msgid "Redefining metaobject class ~S has no effect."
msgstr "Redefiniendo clase metaobjeto ~S no tiene efecto."

#: clos-class3.lisp:796
#, lisp-format
msgid "(~S ~S): superclass ~S should be of class ~S"
msgstr "(~S ~S): la superclase ~S debería ser de clase ~S"

#: clos-class3.lisp:819
#, lisp-format
msgid "(~S ~S) for class ~S: ~S does not allow ~S to become a subclass of ~S. You may define a method on ~S to allow this."
msgstr "(~S ~S) para la clase ~S: ~S no permite ~S para convertirse en una subclase de ~S. Quizá define un método en ~S para permitir esto."

#: clos-class3.lisp:852 clos-class3.lisp:1035 clos-class3.lisp:1236 clos-class3.lisp:1366 clos-class3.lisp:1510
#, lisp-format
msgid "Wrong ~S result for class ~S: not a proper list: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: no una lista propia: ~S"

#: clos-class3.lisp:856 clos-class3.lisp:1039
#, lisp-format
msgid "Wrong ~S result for class ~S: list element is not a class: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: elemento listado no es una clase: ~S"

#: clos-class3.lisp:859
#, lisp-format
msgid "Wrong ~S result for class ~S: ~S is not a direct superclass of ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: ~S no una superclase de ~S"

#: clos-class3.lisp:985
#, lisp-format
msgid "~S ~S: inconsistent precedence graph, cycle ~S"
msgstr "~S ~S: grafo de precedencia inconsistente, ciclo ~S"

#: clos-class3.lisp:1017
#, lisp-format
msgid "(class-precedence-list ~S) and (class-precedence-list ~S) are inconsistent"
msgstr "(class-precedence-list ~S) y (class-precedence-list ~S) son inconsistentes"

#: clos-class3.lisp:1042
#, lisp-format
msgid "Wrong ~S result for class ~S: list doesn't start with the class itself: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: la lista no comienza con su misma clase: ~S"

#: clos-class3.lisp:1046
#, lisp-format
msgid "Wrong ~S result for class ~S: list doesn't end with ~S: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: la lista no termina con ~S: ~S"

#: clos-class3.lisp:1049
#, lisp-format
msgid "Wrong ~S result for class ~S: list contains duplicates: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: la lista contiene duplicados: ~S"

#: clos-class3.lisp:1057
#, lisp-format
msgid "Wrong ~S result for class ~S: list doesn't contain the superclass~[~;~:;es~] ~{~S~^, ~}."
msgstr "Resultado de ~S equivocado para la clase ~S: la lista no contiene la(s) superclase~[~;~:;es~] ~{~S~^, ~}."

#: clos-class3.lisp:1061
#, lisp-format
msgid "Wrong ~S result for class ~S: list contains elements that are not superclasses: ~{~S~^, ~}"
msgstr "Resultado de ~S equivocado para la clase ~S: la lista contiene elementos que no son superclase: ~{~S~^, ~}"

#: clos-class3.lisp:1089
#, lisp-format
msgid "~S: argument should be a non-empty proper list, not ~S"
msgstr "~S: un argumento debería ser una lista propia no vacía, no ~S"

#: clos-class3.lisp:1093
#, lisp-format
msgid "~S: argument list element is not a ~S: ~S"
msgstr "~S: el elemento de lista del argumento no es un ~S: ~S"

#: clos-class3.lisp:1099
#, lisp-format
msgid "~S: argument list elements should all have the same name, not ~S and ~S"
msgstr "~S: los elementos de lista del argumento debería tener todos el mismo nombre, no ~S y ~S"

#: clos-class3.lisp:1154
#, lisp-format
msgid "Wrong ~S result for ~S: not a list of keyword/value pairs: ~S"
msgstr "Resultado de ~S equivocado para ~S: no una lista de pares claves/valor: ~S"

#: clos-class3.lisp:1160
#, lisp-format
msgid "Wrong ~S result for ~S: missing ~S"
msgstr "Resultado de ~S equivocado para ~S: ~S faltante"

#: clos-class3.lisp:1162
#, lisp-format
msgid "Wrong ~S result for ~S: invalid ~S value"
msgstr "Resultado de ~S equivocado para ~S: valor no válido ~S"

#: clos-class3.lisp:1222
#, lisp-format
msgid "Wrong ~S result for class ~S, slot ~S: not an ~S instance: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: ranura ~S: no una instancia ~S: ~S"

#: clos-class3.lisp:1241 clos-class3.lisp:1247 clos-class3.lisp:1370
#, lisp-format
msgid "Wrong ~S result for class ~S: list element is not a ~S: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: elemento listado no es una ~S: ~S"

#: clos-class3.lisp:1252 clos-class3.lisp:1375
#, lisp-format
msgid "Wrong ~S result for class ~S: list contains duplicate slot names: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: la lista contiene nombres de ranura duplicado: ~S"

#: clos-class3.lisp:1274
#, lisp-format
msgid "In class ~S, the slot ~S is constrained by incompatible constraints inherited from the superclasses."
msgstr "Interno a clase ~S, la ranura ~S está comprimida por constantes heredadas desde las superclases."

#: clos-class3.lisp:1279
#, lisp-format
msgid "In class ~S, non-local slot ~S is constrained to be a local slot at offset ~S."
msgstr "Interno a clase ~S, ranura no local ~S está comprimida para ser una ranura local en el offset ~S."

#: clos-class3.lisp:1289
#, lisp-format
msgid "In class ~S, the slots ~S and ~S are constrained from the superclasses to both be located at offset ~S."
msgstr "Interno a clase ~S, las ranuras ~S y ~S están contenidas desde las superclases para que ambos sean ubicados en el offset ~S."

#: clos-class3.lisp:1300
#, lisp-format
msgid "In class ~S, a slot constrained from a superclass wants to be located at offset ~S, which is impossible."
msgstr "Interno a clase ~S, una ranura comprimida desde una superclase desea ser ubicado en el offset ~S, lo cual es imposible."

#: clos-class3.lisp:1353
#, lisp-format
msgid "In class ~S, constrained slot locations cause holes to appear."
msgstr "Interno a clase ~S, localizaciones de ranura comprimida causa hoyos para aparecer."

#: clos-class3.lisp:1381
#, lisp-format
msgid "Wrong ~S result for class ~S: no slot location has been assigned to ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: ninguna ubicación de ranura ha sido asignada para ~S"

#: clos-class3.lisp:1514
#, lisp-format
msgid "Wrong ~S result for class ~S: list element is not a canonicalized default initarg: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: elemento de lista no es un initarg predeterminado canonicado: ~S"

# initarg → argumentos iniciales
#: clos-class3.lisp:1518
#, lisp-format
msgid "Wrong ~S result for class ~S: list contains duplicate initarg names: ~S"
msgstr "Resultado de ~S equivocado para la clase ~S: la lista contiene nombres de argumentos iniciales duplicados: ~S"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: clos-class3.lisp:1537
msgid "method"
msgstr "método"

#: clos-class3.lisp:1828
#, lisp-format
msgid "(~S ~S): metaclass ~S does not support shared slots"
msgstr "(~S ~S): la metaclase ~S no mantiene ranuras compartidas"

#: clos-class3.lisp:1951
#, lisp-format
msgid "~S: class definition circularity: ~S depends on itself"
msgstr "~S: definición circular de clase: ~S depende en sí misma"

#: clos-class3.lisp:1959
#, lisp-format
msgid "~S has a direct-superclasses element ~S, which is invalid."
msgstr "~S tiene un elemento de superclase directa ~S, la cual es no válida."

#: clos-class3.lisp:2010
#, lisp-format
msgid "~S: Cannot finalize class ~S. ~:{Class ~S inherits from class ~S. ~}Class ~S is not yet defined."
msgstr "~S: No puede finalizar la clase ~S. ~:{Clase ~S hereda desde clases ~S. ~}Clase  ~S no está ya definida."

#: clos-class3.lisp:2090
#, lisp-format
msgid "~S: Class ~S (or one of its ancestors) is being redefined, but its instances cannot be made obsolete"
msgstr "~S: La clase ~S (o uno de sus ancestros) está siendo redefinida, pero las instancias pueden ser obsoletas"

#: clos-class3.lisp:2100
#, lisp-format
msgid "~S: Class ~S (or one of its ancestors) is being redefined, instances are obsolete"
msgstr "~S: La clase ~S (o uno de sus ancestros) está siendo redefinida, las instancias son obsoletas"

#: clos-class3.lisp:2102
#, lisp-format
msgid "~S: instances of class ~S are made obsolete"
msgstr "~S: instancias de clase ~S se han hecho obsoletas"

#: defstruct.lisp:368
#, lisp-format
msgid "~S ~S: In ~S argument list: ~A"
msgstr "~S ~S: Dentro de la lista de argumento ~S: ~A "

#: defstruct.lisp:536
#, lisp-format
msgid "The class ~S is not a structure class: ~S"
msgstr "La clase de ~S no es una clase de estructura: ~S"

#: defstruct.lisp:544
#, lisp-format
msgid "The class ~S has no slot named ~S."
msgstr "La clase ~S no tiene ninguna ranura llamada ~S."

#: defstruct.lisp:552
#, lisp-format
msgid "The structure type ~S has been defined as a class."
msgstr "El tipo de estructura ~S ha sido definido como una clase."

#: defstruct.lisp:554
#, lisp-format
msgid "The structure type ~S has not been defined."
msgstr "El tipo de estructura ~S no ha sido definido."

#: defstruct.lisp:562
#, lisp-format
msgid "The structure type ~S has no slot named ~S."
msgstr "El tipo de estructura ~S no tiene ninguna ranura llamada ~S."

#: defstruct.lisp:644
#, lisp-format
msgid "~S ~S: argument list should be a list: ~S"
msgstr "~S ~S: la lista de argumentos debe ser una lista: ~S"

#: defstruct.lisp:664
#, lisp-format
msgid "~S ~S: At most one :INCLUDE argument may be specified: ~S"
msgstr "~S ~S: Sólo puede especificarse un argumento :INCLUDE como mucho: ~S"

#: defstruct.lisp:671
#, lisp-format
msgid ""
"~S: Use of ~S implicitly applies FUNCTION.~@\n"
"                                     Therefore using ~S instead of ~S."
msgstr ""
"~S: El empleo de ~S aplica, implícitamente, FUNCTION.~@\n"
"                                     Por lo tanto, se utilizará ~S en vez de ~S."

#: defstruct.lisp:685 condition.lisp:119
#, lisp-format
msgid "~S ~S: unknown option ~S"
msgstr "~S ~S: opción ~S desconocida"

#: defstruct.lisp:690 clos-genfun3.lisp:449 condition.lisp:125
#, lisp-format
msgid "~S ~S: invalid syntax in ~S option: ~S"
msgstr "~S ~S: invalidación de opción sintáctica ~S: ~S"

#: defstruct.lisp:695 clos-genfun3.lisp:323 condition.lisp:130
#, lisp-format
msgid "~S ~S: not a ~S option: ~S"
msgstr "~S ~S: no se trata de una opción ~S: ~S"

# Duda: (y además gorda) Podría parecer que el siguiente mensaje debiera
# traducirse por:
#
# ~S ~S: No hay ningún :PREDICATE sobre estructuras sin nombre.
#
# Sin embargo, el manual "Common Lisp, The Language - 2nd Edition", en
# la página 477 advierte que, en realidad, la opción :PREDICATE no debe
# usarse con estructuras sin nombre:
#
# `A predicate can be defined only if the structure is "named"'
#
# Por lo tanto, he preferido traducir este mensaje de otra manera, tal y
# como veis:
#
#: defstruct.lisp:720
#, lisp-format
msgid "~S ~S: There is no ~S for unnamed structures."
msgstr "~S ~S: no hay un ~S para estructuras sin nombre."

#: defstruct.lisp:743
#, lisp-format
msgid "~S ~S: invalid :TYPE option ~S"
msgstr "~S ~S: Invalidación de opción :TYPE ~S"

#: defstruct.lisp:750
#, lisp-format
msgid "~S ~S: The :INITIAL-OFFSET must be a nonnegative integer, not ~S"
msgstr "~S ~S: El :INITIAL-OFFSET debe ser un entero no negativo, y no ~S"

#: defstruct.lisp:757
#, lisp-format
msgid "~S ~S: :INITIAL-OFFSET must not be specified without :TYPE : ~S"
msgstr "~S ~S: El :INITIAL-OFFSET no debe especificarse sin :TYPE : ~S"

#: defstruct.lisp:779
#, lisp-format
msgid "~S ~S: included structure ~S has not been defined."
msgstr "~S ~S: estructura incluida ~S no ha sido definida."

#: defstruct.lisp:785
#, lisp-format
msgid "~S ~S: included structure ~S is not a structure type."
msgstr "~S ~S: estructura incluida ~S no es un tipo de estructura."

#: defstruct.lisp:798
#, lisp-format
msgid "~S ~S: included structure ~S must be of the same type ~S."
msgstr "~S ~S: estructura incluida ~S debe ser del tipo ~S."

#: defstruct.lisp:828
#, lisp-format
msgid "~S ~S: included structure ~S has no component with name ~S."
msgstr "~S ~S: estructura incluida ~S no tiene ningún componente con el nombre ~S."

#: defstruct.lisp:862
#, lisp-format
msgid "~S ~S: The READ-ONLY slot ~S of the included structure ~S must remain READ-ONLY in ~S."
msgstr "~S ~S: La ranura READ-ONLY ~S de la estructura incluida ~S debe permanecer READ-ONLY en ~S."

#: defstruct.lisp:873
#, lisp-format
msgid "~S ~S: The type ~S of slot ~S should be a subtype of the type defined for the included strucure ~S, namely ~S."
msgstr "~S ~S: El tipo ~S de la ranura ~S debe ser un subtipo del que ha sido definido para la estructura incluida ~S, a saber, ~S."

#: defstruct.lisp:880 defstruct.lisp:987
#, lisp-format
msgid "~S ~S: ~S is not a slot option."
msgstr "~S ~S: ~S no es una opción de ranura."

#: defstruct.lisp:928
#, lisp-format
msgid "~S ~S: structure of type ~S cannot hold the name."
msgstr "~S ~S: una estructura del tipo ~S no puede contener el nombre."

#: defstruct.lisp:973
#, lisp-format
msgid "~S ~S: There may be only one slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura con el nombre ~S."

#: defstruct.lisp:1005
#, lisp-format
msgid "~S ~S: Slot ~S accessor will shadow the predicate ~S."
msgstr "~S ~S: Ranura de accesor ~S cubrirá el predicado ~S."

#: format.lisp:73
msgid "The control string terminates within a format directive."
msgstr "La cadena de control termina dentro de una directiva de formato."

#: format.lisp:130
#, lisp-format
msgid "~A must introduce a number."
msgstr "~A debe introducir un número."

#: format.lisp:139
msgid "The control string terminates in the middle of a parameter."
msgstr "La cadena de control termina en medio de un parámetro."

#: format.lisp:215
msgid "Non-existent format directive"
msgstr "Directiva del formato no existente"

#: format.lisp:222
msgid "Closing '/' is missing"
msgstr "Falta el cierre '/'"

#: format.lisp:236
#, lisp-format
msgid "There is no package with name ~S"
msgstr "No hay ningún paquete con el nombre ~S"

#: format.lisp:254
#, lisp-format
msgid "The closing format directive '~A' does not have a corresponding opening one."
msgstr "La directiva del formato de cierre '~A' no tiene una apertura correspondiente."

#: format.lisp:258
#, lisp-format
msgid "The closing format directive '~A' does not match the corresponding opening one. It should read '~A'."
msgstr "La directiva del formato de cierre '~A' no coincide con la apertura correspondiente. Debería leerse '~A'."

#: format.lisp:265 format.lisp:1494 format.lisp:2287
#, lisp-format
msgid "The ~~; format directive is not allowed at this point."
msgstr "La directiva del formato ~~; no está permitido en este punto."

# Ojo: Estos "ing" no son siempre gerundios.
# Tal vez sea simplemente "...; se esperaba '~A'." sv
#
# Bueno, ..., cuando el mensaje ha salido es que se ha producido un
# error. En tal caso, no se puede estar `esper*ando*', sino que se
# esperaba, ... Si, creo que tienes toda la razón. cll
#
#: format.lisp:289
#, lisp-format
msgid "An opening format directive is never closed; expecting '~A'."
msgstr "Un formato de apertura directivo nunca está cerrado; esperando '~A'."

#: format.lisp:320
msgid "Current point in control string:"
msgstr "Posición en curso en la cadena de control:"

#: format.lisp:339
#, lisp-format
msgid "The ~A format directive cannot take both modifiers."
msgstr "El formato de directiva ~A no puede tomar ambos modificadores."

# Duda: `fill pointer' (puntero de llenado, o de relleno) es un
# recurso que existe en Common Lisp (y por lo tanto, en CLisp) para
# determinar qué parte de un vector está en uso (la que hay desde el
# principio hasta la posición apuntada por el `fill pointer'). Se trata
# de un término que cualquier programador en Lisp debe conocer porque
# esta palabra clave se utiliza en ocasiones, incluso, como palabra
# reservada para indicar una determinada opción en algunas funciones.
#
# Por ese motivo, he decidido dejarla tal cual, sin traducir. Cuando
# pregunté a Bruno Haible sobre esto me respondió:
#
# Imagine a device attached to a bottle or tank, which shows how much full
# the bottle is, in percent. How would you call this device?
#
# ... y francamente, ¡no se me ocurre como!
#
# Bueno, con el tiempo he decidido que (tal y como señala Bruno Haible)
# lo mejor sería: "puntero de relleno".
#
#: format.lisp:362
#, lisp-format
msgid "The destination string ~S should have a fill pointer."
msgstr "La cadena de destino ~S debe tener un puntero de relleno."

#: format.lisp:402
msgid "There are not enough arguments left for this format directive."
msgstr "No hay argumentos suficientes dejados para este formato de directiva."

#: format.lisp:405
#, lisp-format
msgid "The argument list is a dotted list: ~S"
msgstr "La lista de argumento es una lista punteada: ~S"

#: format.lisp:490
#, lisp-format
msgid "The ~~:@R format directive requires an integer in the range 1 - 4999, not ~S"
msgstr "El formato de directiva ~~:@R requiere un entero dentro del rango 1 - 4999, no ~S"

#: format.lisp:506
#, lisp-format
msgid "The ~~@R format directive requires an integer in the range 1 - 3999, not ~S"
msgstr "El formato de directiva ~~@R requiere un entero dentro del rango 1 - 3999, no ~S"

#: format.lisp:563
#, lisp-format
msgid "The argument for the ~~R format directive is too large."
msgstr "El argumento para el formato de directiva ~~R es demasiado largo."

#: format.lisp:1191
#, lisp-format
msgid "The ~~R and ~~:R format directives require an integer argument, not ~S"
msgstr "El formato de directivas ~~R y ~~:R requieren un argumento entero, no ~S"

#: format.lisp:1211
#, lisp-format
msgid "The ~~C format directive requires a character argument, not ~S"
msgstr "El formato de directiva ~~C requiere un carácter como argumento, no ~S"

#: format.lisp:1439
#, lisp-format
msgid "The control string argument for the ~~? format directive is invalid: ~S"
msgstr "La cadena de control argumental para el formato de directiva ~~? es no válido: ~S"

#: format.lisp:1444
#, lisp-format
msgid "The argument list argument for the ~~? format directive is invalid: ~S"
msgstr "La lista de argumento argumentario para el formato de directiva ~~? no es válido: ~S"

#: format.lisp:1499
#, lisp-format
msgid "The ~~[ parameter must be an integer, not ~S"
msgstr "El parámetro  ~~[ debe ser un entero, no ~S"

#: format.lisp:1532
#, lisp-format
msgid "The ~~{ format directive requires a list argument, not ~S"
msgstr "El formato de directiva ~~{ requiere una lista de argumentos, no ~S"

#: format.lisp:1684
msgid "Logical block prefix must be constant"
msgstr "Prefijo de bloque lógico debe ser constante"

#: format.lisp:1696
msgid "Logical block suffix must be constant"
msgstr "Sufijo de bloque lógico debe ser constante"

#: format.lisp:2048
msgid "Too many arguments for this format directive"
msgstr "Demasiados argumentos para esta directiva de formato"

#: international.lisp:46
#, lisp-format
msgid "Language ~S is not defined"
msgstr "El lenguaje ~S no está definido"

#: international.lisp:56
#, lisp-format
msgid "Language ~S inherits from ~S"
msgstr "El lenguaje ~S hereda de ~S"

#: international.lisp:106
#, lisp-format
msgid "~S: Language ~S is not defined"
msgstr "~S: El lenguaje ~S no está definido"

#: international.lisp:129
#, lisp-format
msgid "~S ~S: no value for default language ~S"
msgstr "~S ~S: no hay ningún valor para el lenguaje por defecto ~S"

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#: savemem.lisp:104
#, lisp-format
msgid "Wrote the memory image into ~A (~:D byte~:P)"
msgstr "Escrita la imagen de memoria dentro de ~A (~:D byte~:P)"

#: trace.lisp:41
#, lisp-format
msgid "~S: no local name ~S in ~S"
msgstr "~S: sin nombre local ~S desde ~S"

#: trace.lisp:53
#, lisp-format
msgid "~S: ~S does not name a closure"
msgstr "~S: ~S no nombra una cerradura"

#: trace.lisp:161
#, lisp-format
msgid "~S: cannot trace special operator ~S"
msgstr "~S: no puede trazar operador especial ~S"

#: trace.lisp:189
#, lisp-format
msgid ";; Tracing ~:[function~;macro~] ~S."
msgstr ";; Rastreando la ~:[función~;macro~] ~S."

#: trace.lisp:327
#, lisp-format
msgid "~S: ~S was traced and has been redefined!"
msgstr "~S: ¡~S estaba siendo rastreada y ha sido redefinida!"

#: cmacros.lisp:81
msgid "compiler macro"
msgstr "compilador de macro"

# Aquí también junto las exclamaciones. sv
#: compiler.lisp:651
#, lisp-format
msgid "Compiler bug!! Occurred in ~A~@[ at ~A~]."
msgstr "¡¡Defecto del compilador!! Ocurrido en ~A~@[ en ~A~]."

#: compiler.lisp:1410
#, lisp-format
msgid "Not a valid optimization level for ~S, should be one of 0, 1, 2, 3: ~S"
msgstr "No un nivel de optimación válido para ~S, debería ser uno de 0, 1, 2, 3: ~S"

#: compiler.lisp:1412
#, lisp-format
msgid "~S is not a valid ~S quality."
msgstr "~S no es una cantidad válida ~S."

#: compiler.lisp:1413 compiler.lisp:1524
#, lisp-format
msgid "Not a valid ~S specifier: ~S"
msgstr "No un especificador válido ~S: ~S"

# Soy alérgico al verbo "ignorar". Ignorar en español significa no saber.
# Y eso en inglés se dice "not to know".
# Posibilidades: Descartar, no tener en cuenta. sv
#
# :) Bueno, ... :) Lo cierto es que en el diccionario pone:
#
# "No saber una cosa o muchas cosas, o, de lo contrario, no tener
# noticia de ellas."
#
# O sea, que algo se ignora si no se tienen noticias de ello, ... Creo
# que la traducción está, por lo tanto, correcta. Ahora bien, "no tener
# en cuenta" o "descartar" también me parece muy correcto así que, ¿por
# qué no iba a cambiarlo? :) cll
#
#: compiler.lisp:1439
#, lisp-format
msgid "Bad declaration syntax: ~S~%Will be ignored."
msgstr "Sintaxis de la declaración equivocada:~S~%No se tendrá en cuenta."

#: compiler.lisp:1452 compiler.lisp:1458 compiler.lisp:1464 compiler.lisp:1470
#, lisp-format
msgid "Non-symbol ~S may not be declared ~S."
msgstr "~S no simbólico quizá no sea declarado ~S."

#: compiler.lisp:1482
#, lisp-format
msgid "Non-symbol ~S may not be subject to a TYPE declaration."
msgstr "~S no simbólico quizá no está sujeto a una declaración TYPE."

#: compiler.lisp:1493
#, lisp-format
msgid "~S is not a function name and therefore may not be subject to a FTYPE declaration."
msgstr "~S no es un nombre de función y por lo tanto quizá no es sujeto de una declaración FTYPE."

#: compiler.lisp:1504
#, lisp-format
msgid "~S is not a function name and therefore may not be declared ~S."
msgstr "~S no es un nombre funcional y por lo tanto puede no ser declarado ~S."

#: compiler.lisp:1535
#, lisp-format
msgid "Non-symbol ~S may not be subject to a DECLARATION declaration."
msgstr "~S no simbólico quizá no está sujeto a una declaración DECLARATION."

#: compiler.lisp:1544
#, lisp-format
msgid "The argument of a COMPILE declaration must be a function name: ~S"
msgstr "El argumento de una declaraciones COMPILE debe ser una nombre de función: ~S"

#: compiler.lisp:1548
#, lisp-format
msgid "Unknown declaration ~S.~%The whole declaration will be ignored."
msgstr "Declaración desconocida ~S.~%La declaración completa será ignorada."

#: compiler.lisp:1897
#, lisp-format
msgid " in file ~S "
msgstr " en el fichero ~S"

#: compiler.lisp:1899
#, lisp-format
msgid " in line ~D "
msgstr " en la línea ~D"

#: compiler.lisp:1900
#, lisp-format
msgid " in lines ~D..~D "
msgstr " en las líneas ~D..~D"

#: compiler.lisp:1919
#, lisp-format
msgid "in ~S "
msgstr "en ~S"

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: compiler.lisp:1928
#, lisp-format
msgid "WARNING: ~A"
msgstr "ADVERTENCIA: ~A"

#: compiler.lisp:1945
#, lisp-format
msgid "ERROR: ~A"
msgstr "ERROR: ~A"

#: compiler.lisp:2098
#, lisp-format
msgid "Code contains dotted list ~S"
msgstr "El código contiene la lista punteada ~S"

# En ocasiones como esta hemos puesto a veces:
# "insuficiente número de argumentos" sv
#
# ¡Pues no me gusta nada!, todavía si dijeses "número insuficiente de
# argumentos". No se, ..., la verdad es que a mí me gusta mucho más "muy
# pocos argumentos" o, si quieres, "pocos argumentos" pero eso de la
# "insuficiencia", ... (me trae otros recuerdos). cll
#
#: compiler.lisp:2100
#, lisp-format
msgid "Form too short, too few arguments: ~S"
msgstr "Forma demasiado corta, muy pocos argumentos: ~S"

#: compiler.lisp:2103
#, lisp-format
msgid "Form too long, too many arguments: ~S"
msgstr "Forma demasiado larga, demasiados argumentos: ~S"

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#: compiler.lisp:2360
#, lisp-format
msgid "Not the name of a function: ~S"
msgstr "No es el nombre de una función: ~S"

#: compiler.lisp:2425 compiler.lisp:2488
#, lisp-format
msgid ""
"~S is neither declared nor bound,~@\n"
"                     it will be treated as if it were declared SPECIAL."
msgstr ""
"~S no está ni declarado ni ligado,~@\n"
"                      será tratado como si hubiese sido declarado SPECIAL."

#: compiler.lisp:2505
#, lisp-format
msgid ""
"The constant ~S may not be assigned to.~@\n"
"                                        The assignment will be ignored."
msgstr ""
"La constante ~S quizá no es asignado a.~@\n"
"                                        La asignación será ignorada."

#: compiler.lisp:2758
#, lisp-format
msgid "argument list to function ~S is dotted: ~S"
msgstr "el argumento de la función ~S es una lista punteada: ~S"

#: compiler.lisp:2763
#, lisp-format
msgid "~S was called with ~S~:[~; or more~] arguments, but it requires ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] argument~:p."
msgstr "~S fue invocado con ~S~:[~; o más~] argumentos, pero requiere ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumento~:p."

#: compiler.lisp:2773
#, lisp-format
msgid "keyword arguments to function ~S should occur pairwise: ~S"
msgstr "los argumentos clave de la función ~S deben aparecer por pares: ~S"

#
# Afortunadamente, la convención ~#[, para imprimir los términos de una
# lista (en inglés, como dice el estándar) sirve perfectamente para el
# español
#
#: compiler.lisp:2782
#, lisp-format
msgid ""
"illegal keyword~P ~{~S~#[~; and ~S~:;, ~]~} for function ~S.~\n"
"                             ~%The only allowed keyword~[s are~; is~:;s are~] ~{~S~#[~; and ~S~:;, ~]~}."
msgstr ""
"la palabra clave~P ~{~S~#[~; y ~S~:;, ~]~} para la función ~S.~\n"
"                              ~%La única palabra clave permitida~[s son~; es~:;s son~] ~{~S~#[~; y ~S~:;, ~]~}."

#: compiler.lisp:2793
#, lisp-format
msgid "argument ~S to function ~S is not a symbol"
msgstr "el argumento ~S a función ~S no es un símbolo"

#: compiler.lisp:2814
#, lisp-format
msgid "Run time error expected: ~@?"
msgstr "¿Tiempo de ejecución esperada: ~@?"

#: compiler.lisp:2965
#, lisp-format
msgid "~S: ignored duplicate keyword ~S ~S"
msgstr "~S comodín duplicado ignorado ~S ~S"

#: compiler.lisp:2969
#, lisp-format
msgid "~S: ignored keyword ~S ~S"
msgstr "~S: comodín ignorado ~S ~S"

#: compiler.lisp:3263
#, lisp-format
msgid "Apparently passing &KEY arguments without &OPTIONAL arguments in ~S"
msgstr "Aparientemente pasa &KEY argumentos sin argumentos &OPTIONAL en ~S"

#: compiler.lisp:3323
#, lisp-format
msgid "Function ~s is not defined"
msgstr "Función ~s no está definida"

#: compiler.lisp:3330
#, lisp-format
msgid "Function ~S is deprecated."
msgstr "Ffunción ~S es obsoleta."

#: compiler.lisp:3407
#, lisp-format
msgid "Function ~s~% was already defined~a"
msgstr "Función ~s~% ya estaba definida~a"

#: compiler.lisp:3409
#, lisp-format
msgid "Function ~s~% was already defined~a~% with the signature~%~a~% it is being re-defined with a new signature~%~a"
msgstr "Función ~s~% ya ha sido definido~a~% con la firma~%~a~% siendo redefinido con una firma~%~a"

#: compiler.lisp:3453
#, lisp-format
msgid "Cannot find file ~S required by feature ~S"
msgstr "No pueda encontrad ~S requerido por característica ~S"

#: compiler.lisp:3556
#, lisp-format
msgid "Cannot call ~S on ~D~@[ or more~] argument~P"
msgstr "No puede llamar ~S en ~D~@[ o más~] argumento~P"

#: compiler.lisp:3605
#, lisp-format
msgid "Binding variable ~S can cause side effects despite IGNORE declaration since it is declared SPECIAL."
msgstr "Asociar la variable ~S puede causar otros efectos, a pesar de la declaración IGNORE puesto que está declarada como SPECIAL."

#: compiler.lisp:3610
#, lisp-format
msgid "variable ~S is used despite IGNORE declaration."
msgstr "variable ~S está utilizándose a pesar de la declaración IGNORE."

#: compiler.lisp:3619
#, lisp-format
msgid "variable ~S is not used.~%Misspelled or missing IGNORE declaration?"
msgstr "variable ~S no está utilizándose.~%¿Está mal escrita o es que falta la declaración IGNORE?"

#: compiler.lisp:3621
#, lisp-format
msgid "variable ~S is assigned but not read"
msgstr "variable ~S está asignada pero no leída"

#: compiler.lisp:3625
#, lisp-format
msgid "The variable ~S is assigned to, despite READ-ONLY declaration."
msgstr "La variable ~S está asignada, a pesar de la declaración READ-ONLY."

#: compiler.lisp:3666 compiler.lisp:3781
#, lisp-format
msgid "Constant ~S cannot be bound."
msgstr "La constante ~S no puede ligarse."

#: compiler.lisp:4030
#, lisp-format
msgid "Mixing ~S and ~S in lambda list ~S is bad design"
msgstr "Mezcla ~S y ~S en lista lambda ~S está mal diseñada"

#: compiler.lisp:4488
#, lisp-format
msgid "Misplaced declaration: ~S"
msgstr "Declaración situada incorrectamente: ~S"

#: compiler.lisp:4698
#, lisp-format
msgid "~S: assignment to the internal special variable ~S"
msgstr "~S: asignación a la variable ~S interna especial"

#: compiler.lisp:4706
#, lisp-format
msgid "Odd number of arguments to SETQ: ~S"
msgstr "Número impar de argumentos de SETQ: ~S"

#: compiler.lisp:4736 compiler.lisp:4765 compiler.lisp:4857
#, lisp-format
msgid "Cannot assign to non-symbol ~S."
msgstr "No se puede asignar a un \"no-símbolo\" ~S."

#: compiler.lisp:4745
#, lisp-format
msgid "Odd number of arguments to PSETQ: ~S"
msgstr "Número impar de argumentos de PSETQ: ~S"

#: compiler.lisp:4982
#, lisp-format
msgid "Only symbols may be used as variables, not ~S"
msgstr "Sólo pueden usarse los símbolos como variables, no ~S"

#: compiler.lisp:5076
#, lisp-format
msgid "Block name must be a symbol, not ~S"
msgstr "El nombre de un bloque debe ser un símbolo, no ~S"

#: compiler.lisp:5119
#, lisp-format
msgid "RETURN-FROM block ~S is impossible from here."
msgstr "No es posible hacer RETURN-FROM del bloque ~S desde aquí."

#: compiler.lisp:5177
#, lisp-format
msgid "Only numbers and symbols are valid tags, not ~S"
msgstr "Sólo son etiquetas de salto válidas los números y los símbolos, no ~S"

#: compiler.lisp:5249
#, lisp-format
msgid "Tag must be a symbol or a number, not ~S"
msgstr "Una etiqueta de salto debe ser un símbolo o un número, no ~S"

#: compiler.lisp:5252
#, lisp-format
msgid "GO to tag ~S is impossible from here."
msgstr "No es posible ir (GO) a la etiqueta de salto ~S desde aquí."

#: compiler.lisp:5327
#, lisp-format
msgid "~S is not a function. It is a locally defined macro."
msgstr "~S no es una función. Se trata de una macro definida localmente."

#: compiler.lisp:5341
#, lisp-format
msgid "Only symbols and lambda expressions are function names, not ~S"
msgstr "Sólo los símbolos y las expresiones lambda son nombres de funciones válidos, no ~S"

#: compiler.lisp:5391
#, lisp-format
msgid "Illegal function definition syntax in ~S: ~S"
msgstr "La sintaxis para la definición de la función en ~S es no válida: ~S"

#: compiler.lisp:5810
#, lisp-format
msgid "~S: Illegal syntax: ~S"
msgstr "~S: sintaxis no legal: ~S"

#: compiler.lisp:5826
#, lisp-format
msgid "~S: symbol ~S is declared SPECIAL and must not be declared a macro"
msgstr "~S: símbolo ~S está declarado ESPECIAL y no debe ser declarado como macro"

#: compiler.lisp:5851
#, lisp-format
msgid "~S situation must be ~S, ~S or ~S, but not ~S"
msgstr "~S situado debe ser ~S, ~S o ~S, pero no ~S"

#: compiler.lisp:5868
#, lisp-format
msgid "COND clause without test: ~S"
msgstr "Cláusula COND sin prueba condicional: ~S"

#: compiler.lisp:5890
#, lisp-format
msgid "CASE clause without objects: ~S"
msgstr "Cláusula CASE sin objetos: ~S"

#: compiler.lisp:5899
#, lisp-format
msgid "~S: the ~S clause must be the last one: ~S"
msgstr "~S: la clausula ~S debe ser la última: ~S"

#: compiler.lisp:5907
#, lisp-format
msgid "Duplicate ~S label ~S : ~S"
msgstr "~S : La etiqueta ~S se repite: ~S"

#: compiler.lisp:6200
#, lisp-format
msgid "Too many arguments to ~S"
msgstr "Demasiados argumentos para ~S"

#: compiler.lisp:6211
#, lisp-format
msgid "Too few arguments to ~S"
msgstr "Muy pocos argumentos para ~S"

#: compiler.lisp:6650
#, lisp-format
msgid "Arithmetic operand ~s must evaluate to a number, not ~s"
msgstr "Operando aritmético ~s debe evaluar a un número, no ~s"

#: compiler.lisp:7180
#, lisp-format
msgid "The ~S destination is invalid (not NIL or T or a stream or a string with fill-pointer): ~S"
msgstr "El destino ~S es no válido (ni NIL, ni T, ni un flujo ni una cadena con puntero de relleno): ~S"

#: compiler.lisp:7204
#, lisp-format
msgid "First argument to ~S should be sequence, not ~S"
msgstr "Primer argumento para ~S debería ser secuencia, no ~S"

#: compiler.lisp:7207
#, lisp-format
msgid "~S is destructive, should not be called on a constant ~S"
msgstr "~S es destructivo, no debería ser llamado en una constante ~S"

#: compiler.lisp:8100
#, lisp-format
msgid "function ~S is used despite IGNORE declaration."
msgstr "función ~S está utilizada a pesar de declaración IGNORE."

#: compiler.lisp:10857
#, lisp-format
msgid "function ~S is not used.~%Misspelled or missing IGNORE declaration?"
msgstr "función ~S no está empleada.~%¿Está mal escrita o es que falta la declaración IGNORE?"

#: compiler.lisp:10893
#, lisp-format
msgid "~S cannot be compiled"
msgstr "~S no puede ser compilado"

#: compiler.lisp:10944
#, lisp-format
msgid "~S: redefining ~S; it was traced!"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: compiler.lisp:10949
#, lisp-format
msgid "~S is already compiled."
msgstr "~S ya está compilada."

#: compiler.lisp:10964 disassem.lisp:9
#, lisp-format
msgid "Undefined function ~S"
msgstr "La función ~S no está definida"

# Sugerencia: No es blabla ni bla bla. sv
# El ni se ponía la segunda pero no la primera vez, ¿no?
#
# ¡No, hombre, no! Creo que estas equivocado, ..., en el diccionario
# Larousse de Inglés-Español pone:
#
# "nor conj. Ni: he is neither big nor small, no es ni grande ni
# pequeño; neither you nor I, ni tú ni yo || ..."
#
# O sea, que es " ... ni ... ni ..." cll
#
#: compiler.lisp:10979
#, lisp-format
msgid "Not a lambda expression nor a function: ~S"
msgstr "Ni es una expresión lambda ni es una función: ~S"

#: compiler.lisp:11037
msgid "A function compiled with errors cannot be executed."
msgstr "Una función compilada con errores no puede ser ejecutada."

#: compiler.lisp:11166
#, lisp-format
msgid "[~s was defined~a]"
msgstr "[~s fue definido~a]"

#: compiler.lisp:11173
#, lisp-format
msgid "There were errors in the following functions:~%~{~<~%~:; ~S~>~^~}"
msgstr "Ha habido errores en las siguientes funciones:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:11179
#, lisp-format
msgid "The following functions were used but not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "Las siguientes funciones han sido utilizadas pero no definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:11187
#, lisp-format
msgid "The following special variables were not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "Las siguientes variables especiales no han sido definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:11190
#, lisp-format
msgid "The following special variables were defined too late:~%~{~<~%~:; ~S~>~^~}"
msgstr "Las siguientes variables especiales fueron definidas demasiado tarde:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lisp:11193
#, lisp-format
msgid "The following functions were used but are deprecated:~%~:{~<~%~:; ~S - ~@?~>~^~}"
msgstr "Las siguientes funciones han sido utilizadas pero no definidas:~%~:{~<~%~:; ~S - ~@?~>~^~}"

#
# Duda: ¡atención a la utilización de la directiva ~P!
#
# La siguiente traducción funcionará si, para el caso del español (como
# para el alemán), se pasa el parámetro (eql *error-count* 1), en
# segundo lugar.
#
# Ya no hace falta. Tal y como está hecho no es necesario pasar ningún
# parámetro extra. Así funciona correctamente.
#
# Aquí dudo porque atención no es tan "pluralizable" como aviso. sv
#
# Claro, de hecho, a mí también me pasa lo mismo. He preferido cambiar
# la traducción de "aviso" por "advertencia", en este mensaje y en aquél
# en el que se sacan los mensajes del compilador. ¿No os suena muchísimo
# mejor esta segunda alternativa? - cll
#
#: compiler.lisp:11198
#, lisp-format
msgid "~D error~:P, ~D warning~:P"
msgstr "~D error~:*~[es~;~:;es~], ~D advertencia~:P"

#: compiler.lisp:11366
#, lisp-format
msgid "Listing of compilation of file ~A~%on ~A by ~A, version ~A"
msgstr "Listando desde compilador de fichero ~A~%en ~A por ~A, versión ~A"

#: compiler.lisp:11398
#, lisp-format
msgid ";; Compiling file ~A ..."
msgstr ";; Fichero compilado ~A ..."

#: compiler.lisp:11433
#, lisp-format
msgid ";; Wrote file ~A"
msgstr ";; Fichero escrito ~A"

#: compiler.lisp:11441
#, lisp-format
msgid ";; Deleted file ~A"
msgstr ";; Fichero eliminado ~A"

#: compiler.lisp:11491
#, lisp-format
msgid "Disassembly of function ~S"
msgstr "Desensamblación de función ~S"

#: compiler.lisp:11501
#, lisp-format
msgid "~S required argument~:P"
msgstr "~S argumento requerido~:P"

#: compiler.lisp:11503
#, lisp-format
msgid "~S optional argument~:P"
msgstr "argumento opcional ~S~:P"

#: compiler.lisp:11506
msgid "Rest parameter"
msgstr "Parámetro resto"

#: compiler.lisp:11507
msgid "No rest parameter"
msgstr "Sin parámetro de resto"

#
# aAtención a la utilización de la directiva ~P!!
#
# Bueno, en este caso es perfecta :) No hay ningún problema de ningún
# tipo
#
#: compiler.lisp:11511
#, lisp-format
msgid "~S keyword parameter~:P: "
msgstr "~S comodín parametrizado~:P: "

#: compiler.lisp:11518
msgid "Other keywords are allowed."
msgstr "Se permiten otras palabras clave."

#: compiler.lisp:11521
msgid "No keyword parameters"
msgstr "Sin parámetros clave"

#: compiler.lisp:11537
#, lisp-format
msgid "reads special variable~P: ~{~S~^ ~}"
msgstr "lee variable especial~P: ~{~S~^ ~}"

#: compiler.lisp:11541
#, lisp-format
msgid "writes special variable~P: ~{~S~^ ~}"
msgstr "escribe variable especial~P: ~{~S~^ ~}"

#: compiler.lisp:11544
#, lisp-format
msgid "~S byte-code instruction~:P:"
msgstr "~S instrucción~:P de código bit"

#: defs2.lisp:62
#, lisp-format
msgid "The object to be destructured should be a list with at most ~S elements, not the circular list ~S"
msgstr "Los objetos a ser destruidos deberían ser una lista como máximo ~S elementos, no como la lista circular ~S"

#: defs2.lisp:65
#, lisp-format
msgid "The object to be destructured should be a list with ~:[at least ~*~S~;~:[from ~S to ~S~;~S~]~] elements, not ~4@*~S."
msgstr "Los objetos a desmontar deben ser una lista ~:[con al menos ~*~S~;de ~:[~S a ~S~;~S~]~] elementos, y no ~4@*~S."

#: defs2.lisp:142
#, lisp-format
msgid "~S: macro name should be a symbol, not ~S"
msgstr "~S: nombre de macro debería ser un símbolo, no ~S"

#: defs2.lisp:256 defs2.lisp:279
#, lisp-format
msgid "~S: element types of ~S and ~S are ambiguous. Please use ~S or ~S."
msgstr "~S: tipos de elementos de ~S y ~S son ambiguos. Emplee ~S o ~S."

#: loop.lisp:51
#, lisp-format
msgid "~S: syntax error after ~A in ~S"
msgstr "~S: error de sintaxis después de ~A en ~S"

#: loop.lisp:314
#, lisp-format
msgid "~S: variable ~S is used in incompatible clauses~{ ~A ~S~} and~{ ~A ~S~}"
msgstr "~S: la variable ~S está empleada en cláusulas de incompatibilidad~{ ~A ~S~} y~{ ~A ~S~}"

#: loop.lisp:356
#, lisp-format
msgid "~S: missing variable."
msgstr "~S: variable ausente."

#: loop.lisp:365
#, lisp-format
msgid "~S: After ~S, ~S is interpreted as a type specification"
msgstr "~S: Después de ~S, ~S es interpretado como una especificación de tipo"

#: loop.lisp:386
#, lisp-format
msgid "~S: missing forms after ~A: permitted by CLtL2, forbidden by ANSI CL."
msgstr "~S: formatos perdidos después de ~A: permitidos por CLtL2, prohibido por ANSI CL."

#: loop.lisp:559
#, lisp-format
msgid "~S: duplicate iteration variable ~S"
msgstr "~S: variable de iteración duplicada ~S"

#: loop.lisp:636
#, lisp-format
msgid "~S: loop keyword immediately after ~A: permitted by CLtL2, forbidden by ANSI CL."
msgstr "~S: bucle de clave inmediatamente tras ~A: permitido por CLtL2, olvidado por ANSI CL."

#: loop.lisp:643
#, lisp-format
msgid "~S: ~A clauses should occur before the loop's main body"
msgstr "~S: las claúsulas ~A deben aparecer antes del cuerpo principal del bucle"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lisp:796
#, lisp-format
msgid "~S: After ~S a plural loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un plural, y no ~A"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lisp:801
#, lisp-format
msgid "~S: After ~S a singular loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un singular, y no ~A"

#: loop.lisp:957
#, lisp-format
msgid "~S: questionable iteration direction after ~A"
msgstr "~S: dirección incierta de la iteración después de ~A"

#: loop.lisp:965
#, lisp-format
msgid "~S: invalid keyword ~A after ~A"
msgstr "~S: palabra clave no válida ~A tras ~A"

#: loop.lisp:975
#, lisp-format
msgid "~S: specifying ~A requires FROM or DOWNFROM"
msgstr "~S: especificar ~A requiere FROM o DOWNFROM"

#: loop.lisp:1022
#, lisp-format
msgid "~S: illegal syntax near ~S in ~S"
msgstr "~S: sintaxis no válida cerca de ~S desde ~S"

#: loop.lisp:1028
#, lisp-format
msgid "~S: ambiguous result:~:{~%~S from ~@{~{~A ~S~}~^, ~}~}"
msgstr "~S: resultado ambiguo:~:{~%~S desde ~@{~{~A ~S~}~^, ~}~}"

#: loop.lisp:1106
#, lisp-format
msgid "~S: accumulation variable ~S is already bound"
msgstr "~S: variable de acumulación ~S está ya alojada"

#: loop.lisp:1178
#, lisp-format
msgid "~S is possible only from within ~S"
msgstr "~S sólo es posible desde ~S"

#: loop.lisp:1181
#, lisp-format
msgid "Use of ~S in FINALLY clauses is deprecated because it can lead to infinite loops."
msgstr "Emplee de ~S en las cláusulas FINALLY está desaconsejada puesto que puede provocar bucles infinitos."

#: loop.lisp:1184
#, lisp-format
msgid "~S is not possible here"
msgstr "~S es imposible aquí"

#: clos-specializer2.lisp:15 clos-methcomb3.lisp:33
#, lisp-format
msgid "~S: It is not allowed to reinitialize ~S"
msgstr "~S: no están permitidas para reinicializar ~S"

#: clos-class5.lisp:663
#, lisp-format
msgid "~S cannot change a funcallable object to a non-funcallable object: ~S"
msgstr "~S no puede cambiar un objeto llamable a un objeto no llamable: ~S"

#: clos-class5.lisp:671
#, lisp-format
msgid "~S cannot change a non-funcallable object to a funcallable object: ~S"
msgstr "~S no puede cambiar un objeto no llamable a un objeto llamable: ~S"

#: clos-class5.lisp:785
#, lisp-format
msgid "~S: The MOP does not allow changing the class of metaobject ~S"
msgstr "~S: El MOP no permite cambiar la clase de metaobjeto ~S"

#: clos-class6.lisp:51
#, lisp-format
msgid "The class ~S has not yet been initialized."
msgstr "La clase ~S aún no ha sido inicializado."

#: clos-class6.lisp:57
#, lisp-format
msgid "The class ~S has not yet been finalized."
msgstr "La clase ~S aún no ha sido finalizado."

#: clos-class6.lisp:82
#, lisp-format
msgid "~S: The name of a class must be a symbol, not ~S"
msgstr "~S: el nombre de una clase debe ser un símbolo, no ~S"

#: clos-class6.lisp:86
#, lisp-format
msgid "~S: The name of the built-in class ~S cannot be modified"
msgstr "~S: El nombre de la clase interna ~S no puede ser modificada"

#: clos-class6.lisp:112
#, lisp-format
msgid "~S being called on ~S, but class ~S is not yet defined."
msgstr "~S siendo llamado en ~S, pero clase ~S no está aún definida."

#: clos-class6.lisp:388
#, lisp-format
msgid "~S: ~S is an abstract class and therefore does not have a direct instance"
msgstr "~S: ~S es una clase abstracta y por lo tanto no tiene una instancia directa"

#: clos-slotdef2.lisp:44 clos-method3.lisp:46
#, lisp-format
msgid "~S: The MOP does not allow reinitializing ~S"
msgstr "~S: la MOP no permite reinicializando ~S"

#: clos-slots1.lisp:143 clos-slots1.lisp:186
#, lisp-format
msgid "~S: not a list of slots: ~S"
msgstr "~S: no es una lista de ranuras: ~S"

#: clos-slots1.lisp:152
#, lisp-format
msgid "~S: invalid slot and variable specification ~S"
msgstr "~S: invalidada especificación de ranura y variable: ~S"

#: clos-slots1.lisp:159 clos-slots1.lisp:199
#, lisp-format
msgid "~S: variable ~S should be a symbol"
msgstr "~S: la variable ~S debe ser un símbolo"

#: clos-slots1.lisp:165
#, lisp-format
msgid "~S: slot name ~S should be a symbol"
msgstr "~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos-slots1.lisp:193
#, lisp-format
msgid "~S: invalid slot and accessor specification ~S"
msgstr "~S: invalidada ranura y especificación del acceso ~S"

#: clos-slots1.lisp:205
#, lisp-format
msgid "~S: accessor name ~S should be a symbol"
msgstr "~S: el nombre de la función de acceso ~S debe ser un símbolo"

#: clos-slots2.lisp:15
#, lisp-format
msgid "~S: The class ~S has no slot named ~S"
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: clos-slots2.lisp:26
#, lisp-format
msgid "~S: The slot ~S of ~S has no value"
msgstr "~S: La ranura ~S de ~S no tiene ningún valor"

#: clos-method1.lisp:130 clos-method1.lisp:158
#, lisp-format
msgid "(~S ~S): The ~S argument should be a proper list, not ~S"
msgstr "(~S ~S): el argumento ~S debería ser una lista propia, no ~S"

#: clos-method1.lisp:133
#, lisp-format
msgid "(~S ~S): The qualifiers list should consist of non-NIL atoms, not ~S"
msgstr "(~S ~S): La lista de cualificadores deberían consistir átomos no-NIL, no ~S"

#: clos-method1.lisp:137 clos-method1.lisp:155 clos-method1.lisp:173 clos-method1.lisp:265
#, lisp-format
msgid "(~S ~S): Missing ~S argument."
msgstr "(~S ~S): argumento ~S faltante."

#: clos-method1.lisp:142
#, lisp-format
msgid "(~S ~S): Invalid ~S argument: ~A"
msgstr "(~S ~S): argumento ~S no válido: ~A"

#: clos-method1.lisp:150
#, lisp-format
msgid "(~S ~S): Lambda-list ~S and signature ~S are inconsistent."
msgstr "(~S ~S): lista-lamda para ~S y firma ~S son inconsistentes."

#: clos-method1.lisp:163
#, lisp-format
msgid "(~S ~S): The element ~S of the ~S argument is not yet defined."
msgstr "(~S ~S): el elemento ~S del argumento ~S no está aún definido."

#: clos-method1.lisp:165
#, lisp-format
msgid "(~S ~S): The element ~S of the ~S argument is not of type ~S."
msgstr "(~S ~S): el elemento ~S del argumento ~S no es del tipo ~S."

#: clos-method1.lisp:168
#, lisp-format
msgid "(~S ~S): The lambda list ~S has ~S required arguments, but the specializers list ~S has length ~S."
msgstr "(~S ~S): La lista lambda ~S tiene ~S argumentos requeridos, pero la lista de especializaciones ~S tiene longitud ~S."

#: clos-method1.lisp:177 clos-method1.lisp:181
#, lisp-format
msgid "(~S ~S): The ~S argument should be a function, not ~S"
msgstr "(~S ~S): el argumento ~S debería ser una función, no ~S"

#: clos-method1.lisp:184
#, lisp-format
msgid "(~S ~S): The ~S argument should be a NIL or T, not ~S"
msgstr "(~S ~S): el argumento ~S debería ser un NIL o T, no ~S"

#: clos-method1.lisp:194
#, lisp-format
msgid "(~S ~S): The ~S argument should be a string or NIL, not ~S"
msgstr "(~S ~S): el argumento ~S debería ser una cadena o NIL, no ~S"

#: clos-method1.lisp:268
#, lisp-format
msgid "(~S ~S): Argument ~S is not of type ~S."
msgstr "(~S ~S): un argumento ~S no es de tipo ~S."

#: clos-method2.lisp:35
#, lisp-format
msgid "Invalid specialized parameter in method lambda list ~S: ~S"
msgstr "Parámetro especializado invalidado en lista de método lambda ~S: ~S"

#: clos-method2.lisp:82
#, lisp-format
msgid "~S ~S: missing lambda list"
msgstr "~S ~S: falta la lista lambda"

#: clos-method2.lisp:111
#, lisp-format
msgid "~S ~S: Invalid specializer ~S in lambda list ~S"
msgstr "~S ~S: ~S no válida especializada en lista lambda ~S"

#: clos-method3.lisp:81
#, lisp-format
msgid "Invalid ~S result for ~S: ~:S: ~A"
msgstr "Resultado de ~S no válido para ~S: ~:S: ~A"

#: clos-methcomb1.lisp:21
#, lisp-format
msgid "~S: The method combination ~S is not defined."
msgstr "~S: La combinación de métodos ~S no está definido."

#: clos-methcomb2.lisp:81
#, lisp-format
msgid "The method function of ~S cannot be called before the method has been added to a generic function."
msgstr "La función de método de ~S no puede ser llamada antes del método haya sido añadido a una función genérica."

#: clos-methcomb2.lisp:123
#, lisp-format
msgid "For function ~S applied to argument list ~S:~%While computing the effective method through ~S:~%Invalid method: ~S~%~?"
msgstr "Para función ~S aplicada a lista de argumento ~S:~%Mientras calcula el método efectivo a través de ~S:~%¿Método no válido: ~S~%~?"

#: clos-methcomb2.lisp:137
#, lisp-format
msgid "For function ~S applied to argument list ~S:~%While computing the effective method through ~S:~%Impossible to combine the methods:~%~?"
msgstr "Para función ~S aplicado a lista de argumento ~S:~%Mientrad calcula el método efectivo a través de ~S:~%¿Imposible combinar los métodos:~%~?"

#: clos-methcomb2.lisp:144 clos-methcomb2.lisp:158
#, lisp-format
msgid "The value of ~S is ~S, should be ~S or ~S."
msgstr "El valor de ~S es ~S, debería ser ~S o ~S."

#: clos-methcomb2.lisp:151
#, lisp-format
msgid "Method ~S has the same specializers and different qualifiers than other methods in method group ~S, and is actually used in the effective method."
msgstr "Método ~S tiene la misma especialización y distinta calificación que otros métodos dentro del grupo de métodos ~S, y actualmente se emplea en los métodos efectivos."

#: clos-methcomb2.lisp:168
#, lisp-format
msgid "~S ~S: Invalid method-combination options ~S for ~S: ~A"
msgstr "~S ~S: opciones de combinación de método no válido ~S para ~S: ~A"

#: clos-methcomb2.lisp:203 clos-methcomb2.lisp:218
#, lisp-format
msgid "~S ~S: Invalid syntax for ~S option: ~S"
msgstr "~S ~S: sintaxis no válida para opción ~S: ~S"

#: clos-methcomb2.lisp:290
#, lisp-format
msgid "~S is possible only from within the context of an effective method function. See ~S."
msgstr "~S es posible solo desde donde el contexto de una función de método efectivo. Vea ~S."

#: clos-methcomb2.lisp:299
#, lisp-format
msgid "~S is possible only at particular places from within the context of an effective method function. See ~S."
msgstr "~S es posible solo en lugares particulares desde donde el contexto de una función de método efectiva. Vea ~S."

#: clos-methcomb2.lisp:306
#, lisp-format
msgid "~S cannot be used here: ~S"
msgstr "~S no puede ser empleado aquí: ~S"

#: clos-methcomb2.lisp:318
#, lisp-format
msgid "~S: The first argument is neither a method nor a (MAKE-METHOD ...) form: ~S"
msgstr "~S: El primer argumento ni es un método ni un formato (MAKE-METHOD ...): ~S"

#: clos-methcomb2.lisp:325
#, lisp-format
msgid "~S: The second argument is not a list: ~S"
msgstr "~S: El segundo argumento no es una lista: ~S"

#: clos-methcomb2.lisp:332
#, lisp-format
msgid "~S: The second argument is not a list of methods or (MAKE-METHOD ...) forms: ~S"
msgstr "~S: El segundo argumento no es una lista de métodos o (MAKE-METHOS) ...) forma: ~S"

#: clos-methcomb2.lisp:479
#, lisp-format
msgid "In ~S ~S lambda list: ~A"
msgstr "ln ~S ~S lista lambda: ~A"

#: clos-methcomb2.lisp:645
#, lisp-format
msgid "~S ~S: The ~S method combination permits no options: ~S"
msgstr "~S ~S: el método de combinación ~S no permite ninguna opción: ~S"

#: clos-methcomb2.lisp:722
#, lisp-format
msgid "~S method combination, used by ~S, allows no method qualifiers except ~S: ~S"
msgstr "combinación de método ~S, empleada por ~S, no permite ninguna cualificación de método excepto ~S: ~S"

#: clos-methcomb2.lisp:725
#, lisp-format
msgid "~S method combination, used by ~S, does not allow method qualifiers: ~S"
msgstr "combinación de método ~S, empleada por ~S, no permite cualificaciones de método: ~S"

#: clos-methcomb2.lisp:729
#, lisp-format
msgid "~S method combination, used by ~S, does not allow more than one method qualifier on a method: ~S"
msgstr "combinación de método ~S, empleada por ~S, no permite más que un cualificador de método sobre un método: ~S"

#: clos-methcomb2.lisp:793
#, lisp-format
msgid "~S method combination, used by ~S, does not allow less than one method qualifier on a method: ~S"
msgstr "combinación de método ~S, empleada por ~S, no permite menos que un cualificador de método sobre un método: ~S"

#: clos-methcomb2.lisp:864
#, lisp-format
msgid "~S ~S: invalid method group specifier ~S: ~A"
msgstr "~S ~S: especificador de grupo de métodos no válido ~S: ~A"

#: clos-methcomb2.lisp:875
msgid "Not a list of length at least 2"
msgstr "No una lista de longitud de al menos 2"

#: clos-methcomb2.lisp:884
#, lisp-format
msgid "Not a variable name: ~S"
msgstr "No un nombre de variable: ~S"

#: clos-methcomb2.lisp:895 clos-methcomb2.lisp:905
#, lisp-format
msgid "In method group ~S: Cannot specify both qualifier patterns and a predicate."
msgstr "Dentro del grupo de método ~S: no puede especificar ambos patrones de calificación y un predicado."

#: clos-methcomb2.lisp:903
#, lisp-format
msgid "In method group ~S: Cannot specify more than one predicate."
msgstr "Dentro del grupo de método ~S: no puede especificar más que un predicado."

#: clos-methcomb2.lisp:908
#, lisp-format
msgid "In method group ~S: Neither a qualifier pattern nor a predicate: ~S"
msgstr "Dentro del grupo de método ~S: ni un patrón de calificador ni un predicado; ~S"

#: clos-methcomb2.lisp:913
#, lisp-format
msgid "In method group ~S: options must come in pairs"
msgstr "Dentro del grupo de método ~S: opciones deben venir por pares"

#: clos-methcomb2.lisp:919 clos-methcomb2.lisp:923 clos-methcomb2.lisp:927
#, lisp-format
msgid "In method group ~S: option ~S may only be given once"
msgstr "Dentro del grupo de método ~S: opción ~S sólo puede ser dado una vez"

#: clos-methcomb2.lisp:929
#, lisp-format
msgid "In method group ~S: ~S is not a string"
msgstr "Dentro del grupo de método ~S: ~S no es una cadena"

#: clos-methcomb2.lisp:932
#, lisp-format
msgid "In method group ~S: Invalid option ~S"
msgstr "Dentro del grupo de método ~S: opción ~S no válida"

#: clos-methcomb2.lisp:935
#, lisp-format
msgid "In method group ~S: Missing pattern or predicate."
msgstr "Dentro del grupo de método ~S: patrón o predicado faltantes. "

#: clos-methcomb2.lisp:1098
#, lisp-format
msgid "~S: method combination name ~S should be a symbol"
msgstr "~S: el nombre de la combinación de método ~S debería ser un símbolo"

#: clos-methcomb2.lisp:1103
msgid "method combination"
msgstr "combinación de método"

#: clos-methcomb2.lisp:1114 clos-methcomb2.lisp:1125
#, lisp-format
msgid "~S ~S: options must come in pairs"
msgstr "~S ~S: opciones deben venir por pares"

#: clos-methcomb2.lisp:1141
#, lisp-format
msgid "~S ~S: ~S is not a string"
msgstr "~S ~S: ~S no es una cadena"

#: clos-methcomb2.lisp:1170
#, lisp-format
msgid "~S ~S: ~S is not a valid short-form option"
msgstr "~S ~S: ~S no es una opción de formato corto válida"

#: clos-methcomb2.lisp:1192
#, lisp-format
msgid "~S ~S: invalid syntax for long form: ~S"
msgstr "~S ~S: sintaxis no válida para formato largo: ~S"

#: clos-methcomb2.lisp:1202
#, lisp-format
msgid "~S ~S: invalid lambda-list: ~A"
msgstr "~S ~S: invalidación lista-lambda: ~A"

#: clos-methcomb2.lisp:1271
#, lisp-format
msgid "~S ~S: invalid syntax, neither short form nor long form syntax: ~S"
msgstr "~S ~S: invalidación de opción sintáctica, forma corta o larga: ~S"

#: clos-genfun2a.lisp:154 clos-genfun2b.lisp:58
#, lisp-format
msgid "~S: ~S has ~S required argument~:P, but only ~S arguments were passed to ~S: ~S"
msgstr "~S: ~S tiene ~S argumento~:P requerido, pero solo los argumentos ~S fueron pasados a ~S: ~S"

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: clos-genfun2a.lisp:170
#, lisp-format
msgid "~S: argument should be a proper list of classes, not ~S"
msgstr "~S: un argumento debería ser una lista propia de clases, no ~S"

#: clos-genfun2a.lisp:211
#, lisp-format
msgid "~S: ~S has ~S required argument~:P, but ~S classes were passed to ~S: ~S"
msgstr "~S: ~S tiene ~S argumento~:P requerido, pero solo ~S clases fueron pasadas a ~S: ~S"

#
# "~S: el argumento debe ser un símbolo o una lista de símbolos, no ~S" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: clos-genfun2a.lisp:229
#, lisp-format
msgid "~S: argument should be a proper list of specifiers, not ~S"
msgstr "~S: un argumento debería ser una lista propia de especificaciones, no ~S"

#: clos-genfun2a.lisp:324 clos-genfun2b.lisp:88
#, lisp-format
msgid "~S: ~S has ~S required argument~:P"
msgstr "~S: ~S tiene ~S argumentos~:P requerido"

#: clos-genfun2a.lisp:335
#, lisp-format
msgid "~S: Invalid method specializer ~S on ~S in ~S"
msgstr "~S: Especificador de método no válido ~S sobre ~S dentro de ~S"

#: clos-genfun2b.lisp:46
#, lisp-format
msgid "Wrong ~S result for generic function ~S: not a proper list: ~S"
msgstr "Resultado de ~S equivocado para función común ~S: listado propietario: ~S"

#: clos-genfun2b.lisp:50
#, lisp-format
msgid "Wrong ~S result for generic function ~S: list element is not a method: ~S"
msgstr "Resultado de ~S equivocado para función común ~S: listado de elementos no es un método: ~S"

#: clos-genfun2b.lisp:537
#, lisp-format
msgid "~S is not one of the required parameters: ~S"
msgstr "~S no es uno de los parámetros requeridos: ~S"

#: clos-genfun2b.lisp:547
#, lisp-format
msgid "Some variable occurs twice in ~S"
msgstr "Alguna variable ha aparecido dos veces en ~S"

#: clos-genfun2b.lisp:552
#, lisp-format
msgid "The variables ~S are missing in ~S"
msgstr "Las variables ~S están faltadas en ~S"

#: clos-genfun2b.lisp:569
#, lisp-format
msgid "Invalid generic function lambda-list: ~A"
msgstr "Lista-lambda de función común no válida: ~A"

#: clos-genfun2b.lisp:578 clos-genfun2b.lisp:594
#, lisp-format
msgid "The ~S argument should be a proper list, not ~S"
msgstr "El argumento ~S debería ser una lista propia, no ~S"

#: clos-genfun2b.lisp:585
#, lisp-format
msgid "Incorrect ~S argument: ~A"
msgstr "Argumento ~S incorrecto: ~A"

#: clos-genfun2b.lisp:598
#, lisp-format
msgid "In the ~S argument, only ~S declarations are permitted, not ~S"
msgstr "Dentro del argumento ~S, solo están permitidas las declaraciones ~S, no ~S"

#: clos-genfun2b.lisp:607
#, lisp-format
msgid "~S has ~D, but ~S has ~D required parameter~:P"
msgstr "~S tiene ~D, pero ~S tiene ~D parámetros obligatorios~:P"

#: clos-genfun2b.lisp:611
#, lisp-format
msgid "~S has ~D, but ~S has ~D optional parameter~:P"
msgstr "~S tiene ~D, pero ~S tiene ~D parámetro opcional~:P"

#: clos-genfun2b.lisp:615 clos-genfun2b.lisp:619
#, lisp-format
msgid "~S accepts &REST or &KEY, but ~S does not."
msgstr "~S acepta &REST o &KEY, pero ~S no."

# keyword
#: clos-genfun2b.lisp:628
#, lisp-format
msgid "~S does not accept the keywords ~S of ~S"
msgstr "~S no acepta la palabra ~S de ~S"

#: clos-genfun2b.lisp:638
#, lisp-format
msgid "~S method combination, used by ~S, does not allow the method qualifiers ~:S: ~S"
msgstr "combinación de método ~S, empleada por ~S, no permite cualificaciones de método ~:S: ~S"

#: clos-genfun2b.lisp:659
#, lisp-format
msgid "(~S ~S) for generic function ~S: ~S argument specified without a ~S argument."
msgstr "(~S ~S) para función genérica ~S: ~S argumento especificado sin un argumento ~S."

#: clos-genfun2b.lisp:670 clos-genfun2b.lisp:736
#, lisp-format
msgid "(~S ~S) for generic function ~S: ~A"
msgstr "(~S ~S) para función genérica ~S: ~A"

#: clos-genfun2b.lisp:688
#, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S argument should be a class, not ~S"
msgstr "(~S ~S) para función genérica ~S: El argumento ~S debería ser una clase, no ~S"

#: clos-genfun2b.lisp:693
#, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S argument should be a subclass of ~S, not ~S"
msgstr "(~S ~S) para función genérica ~S: El argumento ~S debería ser una subclase de ~S, no ~S"

#: clos-genfun2b.lisp:710
#, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S argument should be a ~S object, not ~S"
msgstr "(~S ~S) para función genérica ~S: El argumento ~S debería ser un objeto ~S, no ~S"

#: clos-genfun2b.lisp:721
#, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S argument should be a string or NIL, not ~S"
msgstr "(~S ~S) para función genérica ~S: El argumento ~S debería ser una cadena o NIL, no ~S"

#: clos-genfun2b.lisp:729
#, lisp-format
msgid "(~S ~S) for generic function ~S: The ~S and ~S arguments cannot be specified together."
msgstr "(~S ~S) para función genérica ~S: los argumentos ~S y ~S no pueden ser especificados juntos."

#: clos-genfun2b.lisp:849
#, lisp-format
msgid "Adding method ~S to an already called generic function ~S"
msgstr "Añadiendo método ~S a una función común ~S ya llamada"

#: clos-genfun2b.lisp:854
#, lisp-format
msgid "Replacing method ~S in ~S"
msgstr "Reemplazando el método ~S de ~S"

#: clos-genfun2b.lisp:861
#, lisp-format
msgid "Wrong ~S behaviour: ~S has not been removed from ~S"
msgstr "Comportamiento ~S equivocado: ~S no ha sido quitado de ~S"

#: clos-genfun2b.lisp:907
#, lisp-format
msgid "Removing method ~S from an already called generic function ~S"
msgstr "Quitando método ~S desde una función genérica ya llamada ~S"

#: clos-genfun2b.lisp:947
#, lisp-format
msgid "~S: the specializers argument is not a list: ~S"
msgstr "~S: los argumentos cualificadores no es una lista: ~S"

#: clos-genfun2b.lisp:956
#, lisp-format
msgid "~S: the specializers argument has length ~D, but ~S has ~D required parameter~:P"
msgstr "~S: el argumento cualificado tiene longitud ~D, pero ~S tiene ~D parámetro~:P requerido"

#: clos-genfun2b.lisp:976
#, lisp-format
msgid "~S has no method with qualifiers ~:S and specializers ~:S"
msgstr "~S no tiene ningún método con cualificadores ~:S y especializadores ~:S"

#: clos-genfun2b.lisp:1270
#, lisp-format
msgid "Wrong ~S result for generic-function ~S: not a function: ~S"
msgstr "Resultado de ~S equivocado para función común ~S: no una función: ~S"

#: clos-genfun3.lisp:35
#, lisp-format
msgid "~S in ~S: bug in determination of effective methods"
msgstr "~S dentro de ~S: defecto en la determinación de métodos efectivos"

#: clos-genfun3.lisp:42
#, lisp-format
msgid "~S in ~S: the new arguments ~S have a different effective method than the old arguments ~S"
msgstr "~S desde ~S: los argumentos nuevos ~S tienen un método en vigor diferente que los argumentos antiguos ~S"

#: clos-genfun3.lisp:60 clos-genfun3.lisp:434
#, lisp-format
msgid "~S ~S: invalid ~S option ~S"
msgstr "~S ~S: invalidado ~S con opción ~S"

#: clos-genfun3.lisp:106 clos-genfun3.lisp:120
#, lisp-format
msgid "~S for generic-function ~S: ~S ~S is neither a class or a symbol"
msgstr "~S para función genérica ~S: ~S ~S no es ni una clase o ni un símbolo"

#: clos-genfun3.lisp:110
#, lisp-format
msgid "~S for generic-function ~S: ~S ~S is not a subclass of ~S"
msgstr "~S para función genérica ~S: ~S ~S no es una subclase de ~S"

#: clos-genfun3.lisp:135
#, lisp-format
msgid "Redefining an already called generic function ~S"
msgstr "Redefiniendo una función genérica ~S ya llamada"

#: clos-genfun3.lisp:189 clos-genfun3.lisp:239
#, lisp-format
msgid "~S: ~S does not name a generic function"
msgstr "~S: ~S no nombra una función genérica"

#: clos-genfun3.lisp:198
#, lisp-format
msgid "Wrong ~S result for ~S: not a generic-function: ~S"
msgstr "Resultado de ~S equivocado para ~S: no una función genérica: ~S"

#: clos-genfun3.lisp:352 clos-genfun3.lisp:374
#, lisp-format
msgid "~S ~S: ~S may only be specified once."
msgstr "~S ~S: ~S sólo puede especificarse una vez."

#: clos-genfun3.lisp:360
#, lisp-format
msgid "~S ~S: A string must be specified after ~S : ~S"
msgstr "~S ~S: Debe especificarse una cadena de caracteres después de ~S: ~S"

#: clos-genfun3.lisp:366
#, lisp-format
msgid "~S ~S: Only one ~S string is allowed."
msgstr "~S ~S: Sólo está permitida una cadena ~S única."

#: clos-genfun3.lisp:386
#, lisp-format
msgid "~S ~S: A method combination type name must be specified after ~S : ~S"
msgstr "~S ~S: un nombre de tipo de método de combinación debe ser especificado después de ~S: ~S"

#: clos-genfun3.lisp:394
#, lisp-format
msgid "~S ~S: Invalid method combination specification: ~S"
msgstr "~S ~S: especificación de combinación de método no válido: ~S"

#: clos-genfun3.lisp:402 clos-genfun3.lisp:416
#, lisp-format
msgid "~S ~S: A class name must be specified after ~S : ~S"
msgstr "~S ~S: un nombre de clase debe ser especificada después de ~S: ~S"

#: clos-genfun3.lisp:408 clos-genfun3.lisp:422 clos-genfun3.lisp:443
#, lisp-format
msgid "~S ~S: Only one ~S option is allowed."
msgstr "~S ~S: Sólo está permitida una opción ~S única."

#: clos-genfun3.lisp:518
#, lisp-format
msgid "~S ~S: invalid generic function lambda-list: ~A"
msgstr "~S ~S: invalidación de función genérica lista-lambda: ~A"

#: clos-genfun3.lisp:641
#, lisp-format
msgid "~S: ~S is not a generic function specification"
msgstr "~S: ~S no es una especificación de función genérica"

#: clos-genfun4.lisp:101 clos-genfun4.lisp:105
#, lisp-format
msgid "~S: When calling ~S with arguments ~S, no method is applicable."
msgstr "~S: Durante invocación ~S con argumentos ~S, ningún método es aplicable."

#: clos-genfun4.lisp:122 clos-genfun4.lisp:126
#, lisp-format
msgid "~S: When calling ~S with arguments ~S, no method of group ~S (from ~S) is applicable."
msgstr "~S: Durante invocación ~S con argumentos ~S, ningún método de grupo ~S (desde ~S) es aplicable."

#: clos-genfun4.lisp:146 clos-genfun4.lisp:150
#, lisp-format
msgid "~S: When calling ~S with arguments ~S, no primary method is applicable."
msgstr "~S: Durante invocación ~S con argumentos ~S, ningún método primario es aplicable."

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: clos-genfun4.lisp:159
#, lisp-format
msgid "ignore ~S"
msgstr "ignora ~S"

#: clos-genfun4.lisp:165
#, lisp-format
msgid "~S: When calling ~S with arguments ~S, there is no next method after ~S, and ~S was called."
msgstr "~S: Durante invocación ~S con argumentos ~S, no hay ningún método después de ~S, y ~S fue llamado."

#: clos-genfun4.lisp:171
#, lisp-format
msgid "~S: ~S is invalid within ~{~S~^ ~} methods"
msgstr "~S: ~S no es válido dentro de los métodos ~{~S~^ ~}"

#: clos-genfun4.lisp:174
#, lisp-format
msgid "~S: ~S is invalid within primary methods"
msgstr "~S: ~S no es válido dentro de los métodos primarios"

#: clos-genfun4.lisp:248
#, lisp-format
msgid "~S: Overriding a standardized method is not allowed. You need to call ~S."
msgstr "~S: Sobreponiendo un método normalizado no está permitido. Requiere llamar ~S."

#: clos-genfun4.lisp:253
#, lisp-format
msgid "~S: Extending a standardized method is only allowed if it returns the same values as the next method.~%Original value: ~{~S~^, ~}~%Value returned by the extending method: ~{~S~^, ~}"
msgstr "~S: Extendiendo un método normalizado sólo está permitido si devuelve los mismos valores que en el siguiente método. ~%Valores originales: ~{~S~^, ~}~%Valores devueltos por el método extendido: ~{~S~^, ~}"

#: clos-genfun4.lisp:254
#, lisp-format
msgid "~S: Extending a standardized method is only allowed if it returns the same values as the next method.~%Original values: ~{~S~^, ~}~%Values returned by the extending method: ~{~S~^, ~}"
msgstr "~S: Extendiendo un metodo especificado está permitido únicamente si devuelve los mismos valores que en el siguiente método. ~%Valores originales: ~{~S~^, ~}~%Valores devueltos por el método extendido: ~{~S~^, ~}"

#: clos-genfun4.lisp:349
#, lisp-format
msgid "The generic function ~S has not yet been initialized."
msgstr "La función genérica ~S aún no ha sido inicializada."

#: clos-genfun4.lisp:364
#, lisp-format
msgid "~S: The name of a generic function must be a function name, not ~S"
msgstr "~S: El nombre de una función genérica debe ser un nombre de función, no ~S"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~S. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#: clos-genfun4.lisp:390
#, lisp-format
msgid "~S: the lambda-list of ~S is not yet known"
msgstr "~S: la lista-lambda de ~S aún no es conocida"

#: clos-genfun4.lisp:408 clos-genfun4.lisp:464
#, lisp-format
msgid "Invalid ~S result ~S: ~A"
msgstr "Invalidar ~S resuelve ~S: ~A"

#: clos-print.lisp:16
#, lisp-format
msgid "No ~S method for ~S (~S (~S))"
msgstr "Ningún método ~S para ~S (~S (~S))"

#: disassem.lisp:56
#, lisp-format
msgid "Cannot disassemble natively compiled function ~S"
msgstr "No puede desensamblar de modo nativo la función compilada ~S"

#: disassem.lisp:84
#, lisp-format
msgid "Cannot show machine instructions: gdb not found."
msgstr "No puedo mostrar instrucciones de máquina: gdb no encontrado."

# En este mensaje, el término `parent-type' se refiere al segundo
# argumento de la macro `define-condition' que, según el estándar, se
# utiliza como lista de super-tipos del que se obtiene una nueva
# condición.
#
# Por ese motivo, he añadido la expresión "super-tipos" - cll
#
#: condition.lisp:97
#, lisp-format
msgid "~S: the parent-type list must be a list of symbols, not ~S"
msgstr "~S: la lista de \"tipos-matrices\" debe ser una lista de símbolos, y no ~S"

#: condition.lisp:103
#, lisp-format
msgid "~S: the slot description list must be a list, not ~S"
msgstr "~S: la lista de descripción de la ranura debe ser una lista, y no ~S"

#: condition.lisp:187
#, lisp-format
msgid "~S: cannot find a ~S class that is a subtype of ~S"
msgstr "~S: no puede encontrar una clase ~S que es un subtipo de ~S"

#: condition.lisp:201
#, lisp-format
msgid "~S ~S: superfluous arguments ~S"
msgstr "~S ~S: argumentos superfluos ~S"

#: condition.lisp:216
#, lisp-format
msgid "~S: the condition argument must be a string, a symbol or a condition, not ~S"
msgstr "~S: el argumento de la condición debe ser una cadena de caracteres, un símbolo o una condición, y no ~S"

#: condition.lisp:682
#, lisp-format
msgid "~S: illegal syntax of clause ~S"
msgstr "~S: la sintaxis de la clausula ~S es no válida"

#: condition.lisp:687
#, lisp-format
msgid "~S: multiple ~S clauses: ~S and ~S"
msgstr "~S: ~S múltiples cláusulas: ~S y ~S"

#: condition.lisp:695
#, lisp-format
msgid "~S: too many variables ~S in clause ~S"
msgstr "~S: demasiadas variables ~S en la clausula ~S"

# Duda: ¿y cómo traduzco `restart'?
#
# He decidido dejar `restart' sin traducir, ... :(
#
#: condition.lisp:857
#, lisp-format
msgid "~S: ~S is not a valid restart name here. Use ~S instead."
msgstr "~S: ~S no es válido como nombre de `restart' aquí. En su lugar, use ~S."

#: condition.lisp:879
#, lisp-format
msgid "~S: invalid restart name ~S"
msgstr "~S: ~S es un nombre no válido de `restart'"

#: condition.lisp:884
#, lisp-format
msgid "~S: No restart named ~S is visible."
msgstr "~S: No hay ningún `restart' visible llamado ~S"

#: condition.lisp:940 condition.lisp:1000
#, lisp-format
msgid "~S: not a list: ~S"
msgstr "~S: no es una lista: ~S"

#: condition.lisp:951 condition.lisp:1011
#, lisp-format
msgid "~S: invalid restart specification ~S"
msgstr "~S: ~S no es una especificación válida de `restart'"

#: condition.lisp:964 condition.lisp:1048
#, lisp-format
msgid "~S: unnamed restarts require ~S to be specified: ~S"
msgstr "~S: es necesario especificar ~S en los `restart' sin nombre: ~S"

#: condition.lisp:1033
#, lisp-format
msgid "~S: missing lambda list in restart specification ~S"
msgstr "~S: falta la lista lambda en la especificación del `restart' ~S"

#: condition.lisp:1054
#, lisp-format
msgid "~S: restart cannot be invoked interactively because it is missing a ~S option: ~S"
msgstr "~S: el `restart' no puede invocarse interactivamente porque falta la opción ~S: ~S"

#: condition.lisp:1219
#, lisp-format
msgid "Use instead~@[ of ~S~]"
msgstr "Emplee en vez ~@[ de ~S~]"

#: condition.lisp:1229
#, lisp-format
msgid "Use instead of ~S [value ~D of ~D]~A"
msgstr "Emplee en lugar de ~S [valor ~D de ~D]~A"

#: condition.lisp:1230
#, lisp-format
msgid "New ~S [value ~D of ~D]~A"
msgstr "Crear ~S [valor ~D de ~D]~A"

#: condition.lisp:1367
#, lisp-format
msgid "Discard this directory entry"
msgstr "Descarta este registro del directorio"

#: condition.lisp:1406
#, lisp-format
msgid "try calling ~S again"
msgstr "intentar llamar a ~S otra vez"

#: condition.lisp:1412
#, lisp-format
msgid "specify return values"
msgstr "especificación devuelve valores"

# Duda: Francamente, no sé porqué motivo esto no fué traducido al
# FRANCÉS o al INGLÉS (compruébese en el código, ...) porque en
# realidad, queda pero que muy bien poner `paso' cuando se hace la
# depuración paso a paso, ...
#
# Este mensaje, de hecho, aparece cuando se hace algo del tipo:
#
# > (step (+ 2 3))
# step 1 --> (+ 2 3)
# Step 1>
#
# ..., donde, traduciendo el primer `step' al español, queda algo muy
# propio:
#
# > (step (+ 2 3))
# paso 1 --> (+ 2 3)
# Step 1>
#
# A mi me gusta así, ..., aA SACO!!
#
#: condition.lisp:1434
msgid "skip "
msgstr "omitir"

#: condition.lisp:1438
msgid "retry "
msgstr "reintentar"

#: condition.lisp:1442
#, lisp-format
msgid "stop loading file ~A"
msgstr "detener la carga del fichero ~A"

#: condition.lisp:1530
#, lisp-format
msgid "In form ~S~%~A"
msgstr "En formato ~S~%~A"

#: condition.lisp:1582 condition.lisp:1683
#, lisp-format
msgid "Return from ~S loop"
msgstr "Retorno del bucle ~S"

#
# En este caso he tenido que traducir `warning' por `advertencia', en
# vez de `atención'. ¿No querreis que diga algo así como "Esto es más
# serio que un toque de atención"? Así parecería que el compilador le va
# a meter una paliza al pobre programador, ... :) - cll
#
#: condition.lisp:1663
#, lisp-format
msgid "~S: This is more serious than a warning: ~A"
msgstr "~S: Esto es más serio que una advertencia: ~A"

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: condition.lisp:1673
msgid "WARNING: "
msgstr "ADVERTENCIA: "

#: condition.lisp:1700
msgid "Ignore the error and proceed"
msgstr "Ignorar el error y proceder"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#: condition.lisp:1891
#, lisp-format
msgid "~S: ~S defines a type, cannot be declared a ~S"
msgstr "~S: ~S define un tipo, no puede ser declarado un ~S"

#: condition.lisp:1907
#, lisp-format
msgid "~S: ~S names a ~S, cannot name a type"
msgstr "~S: ~S nombra un ~S, no puede nombrar un tipo"

#: loadform.lisp:42
#, lisp-format
msgid "A method on ~S for class ~S is necessary for externalizing the object ~S, according to ANSI CL 3.2.4.4, but no such method is defined."
msgstr "Un método en ~S para la clase ~S es necesaria para externalizar el objeto ~S, de acuerdo con ANSI CL 3.2.4.4, pero sin dicho método está definido."

#: xcharin.lisp:57
#, lisp-format
msgid "~S: the font argument should be an integer, not ~S"
msgstr "~S: el argumento de origen debería ser un entero, no ~S"

#: xcharin.lisp:65
#, lisp-format
msgid "~S: the bits argument should be an integer, not ~S"
msgstr "~S: el argumento de los bit deberían ser un entero, no ~S"

# Ya, ya se que eso de "los nombres de bit" puede sonar muy raro, pero
# es que realmente es así en Common Lisp.  Consúltese el Cltl2, 13.5
# Character Control-Bit Functions, página 385
#
#: xcharin.lisp:85
#, lisp-format
msgid "~S: the only bit names are ~S, ~S, ~S, ~S, not ~S"
msgstr "~S: los únicos nombres de bit son ~S, ~S, ~S, ~S, no ~S"

# Con un poco de suerte, aquí se podría poner directamente " (s/n) ".
# En fileutils ya se puede. sv
#
# Bueno, pues sí, ..., sí podría hacerse. Ahora bien, para eso es
# necesario modificar el código fuente del clisp (lo cual no es nada
# complicado gracias a la localizacion de codigo fuente del modo .PO
# desde Emacs :). De momento, lo dejo tal cual (aunque queda pachín,
# pachán, ... :( ) y luego lo modificaré, ..., ¿vale?. cll
#
#: query.lisp:12
msgid " (y/n) "
msgstr " (si(y)/no(n)) "

#: query.lisp:21
msgid "Please answer with y or n : "
msgstr "Por favor, responda con y(si) o n(no) : "

#: query.lisp:31
msgid " (yes/no) "
msgstr " (si(yes)/no(no)) "

#: query.lisp:39
msgid "Please answer with yes or no : "
msgstr "Por favor, responda con yes(si) o no(no) : "

# paquete (?) sv
#
# Bueno, podría parecer muy conveniente. Sin embargo, verás, ..., lo de
# *package* está puesto a nivel de programa. Es decir, Bruno Haible y
# compañÂía lo tienen puesto así desde su propio programa. Por lo tanto,
# si lo cambio en un par de mensajes seguirá apareciendo en muchos otros
# sitios. Prefiero ser consistente y dejarlo así. cll
#
# Además, no está traducido ni en alemán ni en inglés. cll
#
#: reploop.lisp:77
msgid "[*package* invalid]"
msgstr "[*package* no válido]"

#: reploop.lisp:119
#, lisp-format
msgid "Reset *PACKAGE* to ~s"
msgstr "Restablecer *PAQUETE* a ~s"

#: reploop.lisp:213
#, lisp-format
msgid "Printed ~D frame~:P"
msgstr "Enseñado ~D marco~:P"

#: reploop.lisp:255
msgid "The last error:"
msgstr "El último error:"

# Me suele gustar más "utilice" (porque me parece más "fino"). sv
#
# De acuerdo, ..., cambiado `use' por `utilice'. A mí también me gusta más. cll
#
# Y además, (recomendación tuya, Santiago), `command' por `orden', en
# vez de `comando' - cll
#
#: reploop.lisp:278
msgid ""
"You are in the top-level Read-Eval-Print loop.\n"
"Help (abbreviated :h) = this list\n"
"Use the usual editing capabilities.\n"
"(quit) or (exit) leaves CLISP."
msgstr ""
"Está dentro del bucle Read-Eval-Print.\n"
"Help (abr. :h) = esta lista\n"
"Utilice las capacidades de edición habituales.\n"
"(quit) o (exit) abandona CLISP."

#: reploop.lisp:292
msgid ""
"\n"
"Commands may be abbreviated as shown in the second column.\n"
"COMMAND        ABBR     DESCRIPTION\n"
"Help           :h, ?    print this command list\n"
"Error          :e       print the last error message\n"
"Inspect        :i       inspect the last error\n"
"Abort          :a       abort to the next recent input loop\n"
"Unwind         :uw      abort to the next recent input loop\n"
"Reset          :re      toggle *PACKAGE* and *READTABLE* between the\n"
"                          local bindings and the sane values\n"
"Quit           :q       quit to the top-level input loop\n"
"Where          :w       inspect this frame\n"
"Up             :u       go up one frame, inspect it\n"
"Top            :t       go to top frame, inspect it\n"
"Down           :d       go down one frame, inspect it\n"
"Bottom         :b       go to bottom (most recent) frame, inspect it\n"
"Mode mode      :m       set stack mode for Backtrace: 1=all the stack elements\n"
"             2=all the frames                         3=only lexical frames\n"
"             4=only EVAL and APPLY frames (default)   5=only APPLY frames\n"
"Frame-limit n  :fl      set the frame-limit for Backtrace. This many frames\n"
"                          will be printed in a backtrace at most.\n"
"Backtrace [mode [limit]] :bt  inspect the stack\n"
"Break+         :br+     set breakpoint in EVAL frame\n"
"Break-         :br-     disable breakpoint in EVAL frame\n"
"Redo           :rd      re-evaluate form in EVAL frame\n"
"Return value   :rt      leave EVAL frame, prescribing the return values"
msgstr ""
"\n"
"Las funciones pueden ser abreviadas como se muestra en la segunda columna.\n"
"FUNCIÓN   ABR      DESCRIPCIÓN\n"
"Help            :h, ?      enseña esta lista de órdenes\n"
"Error           :e          enseña la último mensaje de error\n"
"Inspect        :i           inspecciona el último error\n"
"Abort           :a          aborta al bucle reciente siguiente\n"
"Unwind        :uw        aborta al siguiente bucle de entrada\n"
"Reset          :re         activa *PACKAGE* y *READTABLE* entre el\n"
"                                  enlace local y los mismos valores\n"
"Quit             :q          quita para el bucle de entrada bucle de entrada techo\n"
"Where          :w         inspecciona este borde\n"
"Up                :u         sube un marco, inspeccionarlo\n"
"Top               :t          ir a un marco superior, inspeccionarlo\n"
"Down            :d         baja un marco, inspeccionarlo\n"
"Bottom          :b         ir al marco inferior (más reciente), inspeccionarlo\n"
"Modo mode   :m        establece modo de pila para Backtrace: 1=todos los elementos de la pila\n"
"                                    2=todos los marcos 3=solo marcos léxicos\n"
"                                    4=solo marcos EVAL y APPLY (predeterminados)\n"
"                                    5=solo marcos APPLY\n"
"Frame-limit n :fl         establece el límite-marcas para Backtrace. Esta cantidad de marcos\n"
"                                    serán enseñadas en un backtrace como mucho.\n"
"Backtrace\n"
"  [modo [límite]] :bt      inspecciona la pila\n"
"Break+              :br+   activa punto de ruptura en el marco EVAL \n"
"Break-               :br-    desactiva punto de ruptura en el marco EVAL\n"
"Redo                 :rd     re-evalúa formato en marco EVAL\n"
"Return value      :rt      abandona marco EVAL, prescribiendo los valores devueltos"

#: reploop.lisp:365
msgid ""
"\n"
"Continue       :c       continue evaluation"
msgstr ""
"\n"
"Continúe       :c       continuar evaluación"

# ¿form no era formulario? (o a lo mejor es algo de lisp que no sé). sv
#
# En Visual Basic (y los lenguajes orientados a eventos), form es formulario.
# Sin embargo, en Lisp form es forma. Se refiere a las sentencias Lisp. cll
#
#: reploop.lisp:372
msgid ""
"\n"
"Step           :s       step into form: evaluate this form in single step mode\n"
"Next           :n       step over form: evaluate this form at once\n"
"Over           :o       step over this level: evaluate at once up to the next return\n"
"Continue       :c       switch off single step mode, continue evaluation\n"
"-- Step-until :su, Next-until :nu, Over-until :ou, Continue-until :cu --\n"
"           same as above, specify a condition when to stop"
msgstr ""
"\n"
"Step          :s       entrar en una forma: evaluar esta forma en el modo paso a paso\n"
"Next          :n       saltarse una forma: evaluar esta forma en un solo paso\n"
"Over          :o       saltarse este nivel: evaluar hasta el siguiente retorno\n"
"Continue    :c       desactivar el modo paso a paso y continuar la evaluación\n"
"-- Step-until :su, Next-until :nu, Over-until :ou, Continue-until :cu --\n"
"           lo mismo que antes, especifique una condición de parada"

#: reploop.lisp:433
msgid "Abort main loop"
msgstr "Abortar bucle principal"

#: reploop.lisp:507
msgid "You can continue (by typing 'continue')."
msgstr "Puede continuar (tecleando `continue')."

#: reploop.lisp:521
msgid "The following restarts are also available:"
msgstr "Los inicios siguientes también están disponibles:"

#: reploop.lisp:522
msgid "The following restarts are available:"
msgstr "Es posible continuar en los siguientes puntos:"

#: reploop.lisp:571
msgid "Abort debug loop"
msgstr "Abortar bucle de depuración"

# Duda: Francamente, no sé porqué motivo esto no fué traducido al
# FRANCÉS o al INGLÉS (compruébese en el código, ...) porque en
# realidad, queda pero que muy bien poner `paso' cuando se hace la
# depuración paso a paso, ...
#
# Este mensaje, de hecho, aparece cuando se hace algo del tipo:
#
# > (step (+ 2 3))
# step 1 --> (+ 2 3)
# Step 1>
#
# ..., donde, traduciendo el primer `step' al español, queda algo muy
# propio:
#
# > (step (+ 2 3))
# paso 1 --> (+ 2 3)
# Step 1>
#
# A mi me gusta así, ..., aA SACO!!
#
#: reploop.lisp:618 reploop.lisp:659
msgid "step "
msgstr "paso "

#: reploop.lisp:622
msgid "no values"
msgstr "sin valores"

#: reploop.lisp:623
msgid "value: "
msgstr "valor: "

#: reploop.lisp:626
msgid " values: "
msgstr " valores: "

#: reploop.lisp:671
msgid "Abort stepper"
msgstr "Abortar descanso"

#: reploop.lisp:688
msgid "condition when to stop: "
msgstr "condición de parada: "

#: dribble.lisp:34
#, lisp-format
msgid "~S: ~S should be a ~S"
msgstr "~S: ~S debería ser un ~S"

# Nota: La utilización de dribbling viene de la función dribble de Lisp.
#       Dicha función graba una sesión Lisp en el archivo que se indique en la
#       llamada a la función.
#
# La traducción no juega, de esa manera, con las palabras.
#
#: dribble.lisp:45
#, lisp-format
msgid "Already dribbling ~S to ~S"
msgstr "Actualmente dribbling ~S hasta ~S"

# Nota: `is finished' debería traducirse por `está finalizado' o `est
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: dribble.lisp:47
#, lisp-format
msgid "~&;; Dribble of ~S finished on ~A.~%"
msgstr "~&;; Dirigido de ~S finalizado en ~A.~%"

# Nota: `is finished' debería traducirse por `está finalizado' o `est
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: dribble.lisp:59
#, lisp-format
msgid ";; Dribble of ~S started on ~A.~%"
msgstr ";; Dirigido de ~S iniciado en ~A.~%"

#: dribble.lisp:62
#, lisp-format
msgid "Currently not dribbling from ~S."
msgstr "Actualmente no desconectado desde ~S."

#: describe.lisp:54
msgid "symbol-macro"
msgstr "macro-simbólico"

#: describe.lisp:57
msgid "constant"
msgstr "constante"

#: describe.lisp:58
msgid "variable"
msgstr "variable"

#: describe.lisp:64
msgid "type"
msgstr "tipo"

# Duda: Lo que he dicho unos pocos mensajes más arriba --> Slot por
# slot, ...
#
# Pues no, ... A partir de la versión 1.4, `slot' es "ranura", tal y
# como se propone en la lista de spanglish.
#
#: describe.lisp:90
#, lisp-format
msgid "Slots:"
msgstr "Ranuras:"

#: describe.lisp:97
#, lisp-format
msgid "unbound"
msgstr "sin asociar"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: describe.lisp:102
#, lisp-format
msgid "No slots."
msgstr "Sin ranuras."

#: describe.lisp:130
#, lisp-format
msgid "a thread object."
msgstr "un objeto de hilo."

#: describe.lisp:133
#, lisp-format
msgid "a mutually exclusive thread lock."
msgstr "un bloqueo de hilo mutualmente exclusivo."

#: describe.lisp:136
#, lisp-format
msgid "a thread condition variable."
msgstr "una condición variable de hilo."

#: describe.lisp:139
#, lisp-format
msgid "a foreign pointer."
msgstr "un puntero externo."

#: describe.lisp:142
#, lisp-format
msgid "a foreign address."
msgstr "una dirección externa."

#: describe.lisp:145
#, lisp-format
msgid "a foreign variable of foreign type ~S."
msgstr "una variable externa del tipo externo ~S."

#: describe.lisp:149
#, lisp-format
msgid "a server socket accepting connections."
msgstr "un socket de servidor aceptando conexiones."

#: describe.lisp:151
#, lisp-format
msgid "a byte specifier, denoting the ~S bits starting at bit position ~S of an integer."
msgstr "un especificador de byte que denota los ~S bits que comienzan en el bit ~S de un entero"

#: describe.lisp:154
#, lisp-format
msgid "a special form handler."
msgstr "un manipulador de forma especial."

#: describe.lisp:156
#, lisp-format
msgid "a load-time evaluation promise."
msgstr "una promesa de evaluación en tiempo de carga."

#: describe.lisp:158
#, lisp-format
msgid "a symbol macro handler."
msgstr "un manipulador de macro simbólico."

#: describe.lisp:160
#, lisp-format
msgid "a global symbol macro handler."
msgstr "un manipulador de macro simbólico global."

#: describe.lisp:162
#, lisp-format
msgid "a macro expander."
msgstr "una macro expandidora."

#: describe.lisp:166 describe.lisp:366 describe.lisp:576
#, lisp-format
msgid "For more information, evaluate ~{~S~^ or ~}."
msgstr "Para más información, evalúe ~{~S~^ o ~}."

#: describe.lisp:169
#, lisp-format
msgid "a function with alternative macro expander."
msgstr "una función con expandidor de macro alternativo."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lisp:171
#, lisp-format
msgid "an encoding."
msgstr "una codificación."

#: describe.lisp:176
#, lisp-format
msgid "a GC-invisible pointer to ~S."
msgstr "un puntero GC-invisible a ~S"

#: describe.lisp:179
#, lisp-format
msgid "a GC-invisible pointer to a now defunct object."
msgstr "un puntero GC-invisible para un objeto defunct actual."

#: describe.lisp:183
#, lisp-format
msgid "a list of GC-invisible pointers to ~{~S~^, ~}."
msgstr "una lista de punteros GC-invisible a ~{~S~^, ~}."

#: describe.lisp:185
#, lisp-format
msgid "a list of GC-invisible pointers, all defunct by now."
msgstr "una lista de punteros GC-invisible, todos defunct por ahora."

#: describe.lisp:189
#, lisp-format
msgid "a weak \"and\" relation between ~{~S~^, ~}."
msgstr "una relación débil “Y” entre ~{~S~^, ~}."

#: describe.lisp:191
#, lisp-format
msgid "a weak \"and\" relation, no longer referring to its objects."
msgstr "una relación débil “Y”, no más allá referenciada a sus objetos."

#: describe.lisp:195
#, lisp-format
msgid "a weak \"or\" relation between ~{~S~^, ~}."
msgstr "una relación débil “O” entre ~{~S~^, ~}."

#: describe.lisp:197
#, lisp-format
msgid "a weak \"or\" relation, all elements defunct by now."
msgstr "una relación débil “O”, todas los elementos defunct por ahora."

#: describe.lisp:201
#, lisp-format
msgid "a weak association from ~S to ~S."
msgstr "una asociación débil desde ~S a ~S."

#: describe.lisp:202
#, lisp-format
msgid "a weak association, the key value being defunct by now."
msgstr "una asociación débil, el valor clave siendo defunct por ahora."

#: describe.lisp:206
#, lisp-format
msgid "a weak \"and\" mapping from ~:S to ~S."
msgstr "una distribución débil “Y” desde ~:S hasta ~S."

#: describe.lisp:207
#, lisp-format
msgid "a weak \"and\" mapping, some key value being defunct by now."
msgstr "una distribución débil \"Y\", algún valor clave estando defunct por ahora."

#: describe.lisp:211
#, lisp-format
msgid "a weak \"or\" mapping from ~:S to ~S."
msgstr "una distribución débil “O” desde ~:S hasta ~S."

#: describe.lisp:212
#, lisp-format
msgid "a weak \"or\" mapping, all keys being defunct by now."
msgstr "una distribución débil “O”, todas las claves siendo defunct por ahora "

#: describe.lisp:216
#, lisp-format
msgid "a weak association list, of type ~S "
msgstr "una lista asociación débil, de tipo ~S "

#: describe.lisp:218
#, lisp-format
msgid "(i.e. a list of ~S key/value pairs)"
msgstr "(ej: una lista de ~S pares clave/valor)"

#: describe.lisp:219
#, lisp-format
msgid "(i.e. a list of ~S value/key pairs)"
msgstr "(ej: una lista de pares valor/clave ~S) "

#: describe.lisp:220 describe.lisp:221
#, lisp-format
msgid "(i.e. a list of (key . value) pairs each combined into a ~S)"
msgstr "(ej: una lista de pares (clave . valor) cada uno combinado dentro de un ~S)"

#: describe.lisp:223
#, lisp-format
msgid ", containing ~S."
msgstr ", conteniendo ~S."

#: describe.lisp:224
#, lisp-format
msgid ", no longer referring to any pairs."
msgstr ", no más largo que refiriéndose a cualquier par."

#: describe.lisp:226
#, lisp-format
msgid "a label used for resolving #~D# references during READ."
msgstr "una etiqueta para resolver #~D# referencias en READ."

#: describe.lisp:230
#, lisp-format
msgid "a pointer into the stack. It points to:"
msgstr "Un puntero a la pila. Apunta a:"

#: describe.lisp:233
#, lisp-format
msgid "a special-purpose object."
msgstr "un objeto de propósito especial."

#: describe.lisp:235
#, lisp-format
msgid "a machine address."
msgstr "una dirección de máquina."

#: describe.lisp:237
#, lisp-format
msgid "an instance of the CLOS class ~S."
msgstr "una instancia de la clase CLOS ~S."

#: describe.lisp:241
#, lisp-format
msgid "an instance of the CLOS class ~S, can be used as a function."
msgstr "una instancia de la clase CLOS ~S, puede utilizarse como una función."

#: describe.lisp:245
#, lisp-format
msgid "a structure of type ~S."
msgstr "una estructura del tipo ~S."

#: describe.lisp:250
#, lisp-format
msgid "As such, it is also a structure of type ~{~S~^, ~}."
msgstr "Como tal, también es una estructura del tipo ~{~S~^, ~}."

#: describe.lisp:258
#, lisp-format
msgid "a dotted list of length ~S."
msgstr "una lista punteada de longitud ~S."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lisp:261
#, lisp-format
msgid "a cons."
msgstr "un cons."

#: describe.lisp:264
#, lisp-format
msgid "a list of length ~S."
msgstr "una lista de longitud ~S."

#: describe.lisp:266
#, lisp-format
msgid "a cyclic list."
msgstr "una lista cíclica."

#: describe.lisp:268
#, lisp-format
msgid "the empty list, "
msgstr "la lista vacía, "

#: describe.lisp:271
#, lisp-format
msgid "the symbol ~S, "
msgstr "el símbolo ~S, "

#: describe.lisp:275
#, lisp-format
msgid "lies in ~S"
msgstr "está en el ~S"

# Duda: He traducido al estilo del mensaje en francés: "n'appartient
# aucun paquetage"
#
#: describe.lisp:278
#, lisp-format
msgid "is uninterned"
msgstr "no aparece en ningún paquete"

# Nota: Caso brillante de la generación de mensajes diferentes gracias a las
#       directivas condicionales del Clisp (y del Common Lisp en general).
#
#: describe.lisp:292
#, lisp-format
msgid ", is accessible in ~:d package~:p ~{~A~^, ~}"
msgstr ", es accesible en ~:d paquete~:p ~{~A~^, ~}"

#: describe.lisp:297
#, lisp-format
msgid ", is a keyword"
msgstr ", es una palabra clave"

#: describe.lisp:299
#, lisp-format
msgid ", symbol-macro expanding to: ~S"
msgstr ", symbol-macro expandiendo a: ~S"

#: describe.lisp:304
#, lisp-format
msgid ", a constant"
msgstr ", una constante"

#: describe.lisp:306
#, lisp-format
msgid ", a variable declared SPECIAL"
msgstr ", una variable declarada SPECIAL"

#: describe.lisp:307
#, lisp-format
msgid ", a variable"
msgstr ", una variable"

#: describe.lisp:308
#, lisp-format
msgid ", value: ~s"
msgstr ", valor: ~s"

#: describe.lisp:311
#, lisp-format
msgid ", an unbound variable declared SPECIAL"
msgstr ", una variable declarada ESPECIAL"

#: describe.lisp:313
#, lisp-format
msgid ", names "
msgstr ", nombra "

#: describe.lisp:315
#, lisp-format
msgid "a special operator"
msgstr "un operador especial"

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: describe.lisp:317
#, lisp-format
msgid " with macro definition"
msgstr " con definición de macro"

#: describe.lisp:319
#, lisp-format
msgid "a~:[~; deprecated~] function"
msgstr "una función~:[~; obsoleta~]"

#: describe.lisp:322
#, lisp-format
msgid "a~:[~; deprecated~] macro"
msgstr "una macro~:[~; obsoleta~]"

#: describe.lisp:326
#, lisp-format
msgid " (use ~S instead)"
msgstr " (emplee ~S en su lugar)"

#: describe.lisp:331
#, lisp-format
msgid ", names a type"
msgstr ", nombra un tipo"

#: describe.lisp:335
#, lisp-format
msgid ", names a class"
msgstr ", nombra una clase"

#: describe.lisp:341
#, lisp-format
msgid ", names a built-in foreign type"
msgstr ", nombra un tipo externo compilado"

#: describe.lisp:342
#, lisp-format
msgid ", names a foreign type"
msgstr ", nombra un tipo externo"

#: describe.lisp:349
#, lisp-format
msgid ", has ~:D propert~@:P ~{~S~^, ~}"
msgstr ", tiene ~:D propiedad~@:P ~{~S~^, ~}"

#: describe.lisp:352 describe.lisp:394 describe.lisp:428 describe.lisp:450 describe.lisp:525
#, lisp-format
msgid "."
msgstr "."

#: describe.lisp:357
#, lisp-format
msgid "Documentation as a ~A:"
msgstr "Documentación como un ~A:"

#: describe.lisp:361 describe.lisp:363 describe.lisp:473
#, lisp-format
msgid "~%~A Documentation is at~% ~S"
msgstr "Documento ~%~A está en~% ~S"

#: describe.lisp:370
#, lisp-format
msgid "an integer, uses ~S bit~:P, is represented as a ~:[bignum~;fixnum~]."
msgstr "un entero, emplea ~S bit~:P, representado como un ~:[bignum~;fixnum~]."

#: describe.lisp:373
#, lisp-format
msgid "a rational, not integral number."
msgstr "un racional, no un número entero."

#: describe.lisp:375
#, lisp-format
msgid "a float with ~S bits of mantissa (~(~A~))."
msgstr "un número en coma flotante con ~S bits de mantisa (~(~A~))."

#: describe.lisp:378
#, lisp-format
msgid "a complex number "
msgstr "un número complejo "

#: describe.lisp:383
#, lisp-format
msgid "at the origin"
msgstr "en el origen"

#: describe.lisp:384
#, lisp-format
msgid "on the ~:[posi~;nega~]tive real axis"
msgstr "en el eje real ~:[posi~;nega~]tivo"

#: describe.lisp:387
#, lisp-format
msgid "on the ~:[posi~;nega~]tive imaginary axis"
msgstr "en el eje imaginario ~:[posi~;nega~]tivo"

#: describe.lisp:389
#, lisp-format
msgid "in the ~:[~:[first~;fourth~]~;~:[second~;third~]~] quadrant"
msgstr "dentro de ~:[~:[primer~;cuarto~]~;~:[segundo~;tercer~]~] cuadrante"

# Si es lo que me imagino, tal vez sería mejor poner "del plano complejo".
# (como matemático que soy, me suena mejor :-). sv
#
# Pues sí, es exactamente lo que te imaginas, ..., "el plano de los números
# gaussianos" era una >>horrible<< traducción, ... ¡Gracias! cll
#
#: describe.lisp:391
#, lisp-format
msgid " of the Gaussian number plane."
msgstr " del plano complejo."

#: describe.lisp:393
#, lisp-format
msgid "a character"
msgstr "un carácter"

#: describe.lisp:399
#, lisp-format
msgid "Unicode name: ~A"
msgstr "Nombre Unicode: ~A"

#: describe.lisp:400
#, lisp-format
msgid "It is not defined by the Unicode standard."
msgstr "No estádefinido por el Unicode común."

#: describe.lisp:402
#, lisp-format
msgid "It is a ~:[non-~;~]printable character."
msgstr "Se trata de un carácter ~:[no ~;~]imprimible."

#: describe.lisp:406
#, lisp-format
msgid "Its use is non-portable."
msgstr "Su utilización no es portable."

#: describe.lisp:408
#, lisp-format
msgid "a~:[~:[ closed ~;n output-~]~;~:[n input-~;n input/output-~]~]stream."
msgstr "un flujo ~:[~:[cerrado~;de salida~]~;~:[de entrada~;de entrada/salida~]~]."

#: describe.lisp:414
#, lisp-format
msgid " It reads from ~S from ~:D to ~:D at ~:D."
msgstr "    Lee desde ~S desde ~:D hasta ~:D en ~:D."

#: describe.lisp:417
#, lisp-format
msgid " It appends to ~S."
msgstr " Se agrega a ~S"

#: describe.lisp:422
#, lisp-format
msgid "the package named ~A"
msgstr "el paquete ~A"

#: describe.lisp:426
#, lisp-format
msgid ". It has ~:D nickname~:P ~{~A~^, ~}"
msgstr ". Tiene ~:D apodos~:P ~{~A~^, ~}"

# Duda: Debo comprobarlo en el código fuente de CLisp pero estoy casi
# seguro que esto es mucho mejor dejarlo sin traducir, ... cll
#
#: describe.lisp:432
#, lisp-format
msgid "It "
msgstr " "

#: describe.lisp:434
#, lisp-format
msgid "imports the external symbols of ~:D package~:P ~{~A~^, ~} and "
msgstr "importa los símbolos externos de ~:D paquete~:P ~{~A~^, ~} y "

#: describe.lisp:440
#, lisp-format
msgid "exports ~[no symbols~:;~:*~:D symbol~:P~]"
msgstr "exporta ~[ningún simbolo~:;~:*~:D símbolos~:P~]"

#: describe.lisp:443
#, lisp-format
msgid "~{ ~S~^,~}"
msgstr "~{ ~S~^,~}"

#: describe.lisp:446
#, lisp-format
msgid " to ~:D package~:P ~{~A~^, ~}"
msgstr " para ~:D paquete~:P ~{~A~^, ~}"

#: describe.lisp:449
#, lisp-format
msgid ", but no package uses these exports"
msgstr ", pero ningún paquete emplea estas exportaciones"

#: describe.lisp:459
#, lisp-format
msgid "It is a modern case-sensitive package."
msgstr "Esto es un paquete moderno que distingue mayúsculas."

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: describe.lisp:462
#, lisp-format
msgid "ATTENTION: "
msgstr "ATENCIÓN: "

#: describe.lisp:465
#, lisp-format
msgid "It is a modern case-sensitive package, but uses the symbols from the traditional ~S!"
msgstr "Esto es un paquete moderno que distingue mayúsculas, ¡pero utiliza el símbolo desde la ~S tradicional!"

#: describe.lisp:467
#, lisp-format
msgid "It is case-inverted, but not case-sensitive!"
msgstr "¡Es inversión de mayúsculas, pero no distinguible!"

#: describe.lisp:469
#, lisp-format
msgid "It is case-sensitive, but not case-inverted!"
msgstr "¡Es distinción de mayúsculas, pero no invertible!"

#: describe.lisp:470
#, lisp-format
msgid "It is a traditional ANSI CL compatible package, but uses the symbols from the modern ~S!"
msgstr "¡Es un paquete de ANSI CL tradicional, pero ¡emplea los símbolos desde el ~S moderno!"

#: describe.lisp:474
#, lisp-format
msgid "a deleted package."
msgstr "un paquete borrado."

#: describe.lisp:477
#, lisp-format
msgid "an ~S hash table with ~[no entries~:;~:*~:D entr~@:P~]."
msgstr "y tabla hash ~S con ~[sin registros~:;~:*~:D registr~@:P~]."

# Este mensaje tiene una especial dificultad, porque de el deberían
# salir cosas del tipo: "una tabla de lectura" (con `tabla de lectura'
# al final del mensaje) o "la tabla de lectura de Common Lisp" (con
# `tabla de lectura' al principio).
#
# Afortunadamente, la situación puede salvarse sin ningún problema
# gracias a la directiva ~:* de format
#
#: describe.lisp:480
#, lisp-format
msgid "~:[a~;the Common Lisp~] readtable."
msgstr "~:[una~;la~] tabla de lectura~:*~:[~; de Common Lisp~]"

#: describe.lisp:483
#, lisp-format
msgid "a ~:[~;portable ~]pathname~:[.~;~:*, with the following components:~{~A~}~]"
msgstr "una trayectoria~:[~; portátil~]~:[.~;~:*, constituída por: ~{~A~}~]"

#: describe.lisp:497
#, lisp-format
msgid "a random-state."
msgstr "un estado aleatorio."

#: describe.lisp:501
#, lisp-format
msgid "a~:[~; simple~] ~A dimensional array"
msgstr "una matriz~:[~; simple~] de dimensión ~A"

#: describe.lisp:504
#, lisp-format
msgid " (vector)"
msgstr " (vector)"

#: describe.lisp:507
msgid " with no storage"
msgstr " sin almacén"

#: describe.lisp:508
#, lisp-format
msgid " of ~As"
msgstr " de ~As"

#: describe.lisp:510
#, lisp-format
msgid ", adjustable"
msgstr ", ajustable"

#: describe.lisp:512
#, lisp-format
msgid ", of size ~{~S~^ x ~}"
msgstr ", de tamaño ~{~S~^ x ~}"

#: describe.lisp:515
#, lisp-format
msgid " and current length (fill-pointer) ~S"
msgstr " y longitud actual (fill-pointer) ~S"

#: describe.lisp:519
#, lisp-format
msgid " (a string)"
msgstr " (una cadena)"

#: describe.lisp:522
#, lisp-format
msgid " (a~:[~;n immutable~] ~:[~;reallocated ~]~A string)"
msgstr " (a~:[~;n inmutable~] ~:[~;reubicado ~]~A cadena)"

#: describe.lisp:527
#, lisp-format
msgid "a generic function."
msgstr "una función genérica."

#: describe.lisp:530 describe.lisp:655
#, lisp-format
msgid "Argument list: ~:S"
msgstr "Lista de argumentos: ~:S"

#: describe.lisp:535
#, lisp-format
msgid "Method combination: ~S"
msgstr "Combinación de método: ~S"

#: describe.lisp:540
#, lisp-format
msgid "Methods:"
msgstr "Métodos:"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: describe.lisp:551
#, lisp-format
msgid "No methods."
msgstr "Sin métodos."

#: describe.lisp:556
#, lisp-format
msgid "a foreign function of foreign type ~S."
msgstr "una función externa del tipo externo ~S."

#: describe.lisp:565
msgid "a built-in system function."
msgstr "una función predefinida del sistema."

#: describe.lisp:566
msgid "a compiled function."
msgstr "una función compilada."

#: describe.lisp:581
#, lisp-format
msgid "an interpreted function."
msgstr "una función interpretada."

#: describe.lisp:592
#, lisp-format
msgid "~A [see above]"
msgstr "~A [ver arriba]"

#: describe.lisp:596
#, lisp-format
msgid "~A is "
msgstr "~A es "

#: describe.lisp:601
#, lisp-format
msgid "Documentation:"
msgstr "Documentación:"

#: describe.lisp:663
#, lisp-format
msgid "Documentation: ~A"
msgstr "Documentación: ~A"

#: describe.lisp:675
#, lisp-format
msgid "~S: file ~S does not exist - adjust ~S"
msgstr "~S: el fichero ~S no existente - ajuste ~S"

#: room.lisp:17
#, lisp-format
msgid "~S: argument must be ~S, ~S or ~S, not ~S"
msgstr "~S: un argumento debe ser ~S, ~S o ~S, pero no ~S"

#: room.lisp:48 room.lisp:218
msgid "Total"
msgstr "Total"

#: room.lisp:54
#, lisp-format
msgid ""
"Number of garbage collections: ~16:D~%~\n"
"                       Bytes freed by GC:             ~16:D~%~\n"
"                       Time spent in GC:              ~16F sec"
msgstr ""
"Número de colecciones de basura: ~16:D~%~\n"
"                       Bytes liberados por GC:\t~16:D~%~\n"
"                       Tiempo gastado en GC:\t~16F seg."

#: room.lisp:60
#, lisp-format
msgid ""
"Bytes permanently allocated:   ~16:D~%~\n"
"                     Bytes currently in use:        ~16:D~%~\n"
"                     Bytes available until next GC: ~16:D"
msgstr ""
"Bytes permanentemente asignados:   ~9D:D~%\n"
"                     Bytes actualmente empleados:        ~16:D~%~\n"
"                     Bytes disponibles hasta el siguiente GC: ~16:D"

#: edit.lisp:28
msgid "No external editor installed."
msgstr "No hay ningún editor externo instalado"

#: edit.lisp:82
#, lisp-format
msgid "~S cannot be edited."
msgstr "~S no puede ser editado."

#: edit.lisp:101
#, lisp-format
msgid "~S: source code for ~S not available."
msgstr "~S: el código fuente de ~S no está disponible."

#: macros3.lisp:14
#, lisp-format
msgid ""
"The form ~S yielded ~:[no values~;~:*~{~S~^ ; ~}~] ,~@\n"
"                       that's not of type ~S."
msgstr ""
"La forma ~S ~:[no produjo ningún valor~;produjo ~:*~{~S~^ ; ~}~] ,~@\n"
"                       que no es del tipo ~S."

#: macros3.lisp:66
#, lisp-format
msgid "LETF* code contains a dotted list, ending with ~S"
msgstr "El código del LETF* contiene una lista punteada que termina con ~S"

#: macros3.lisp:240
#, lisp-format
msgid "LETF code contains a dotted list, ending with ~S"
msgstr "El código de LETF contiene una lista punteada que termina con ~S"

#: clhs.lisp:189
#, lisp-format
msgid "~S: error ~D: ~S"
msgstr "~S: error ~D: ~S"

#: clhs.lisp:251
#, lisp-format
msgid "~S is not found"
msgstr "~S no se ha encontrado"

# Ya, ya se que eso de "los nombres de bit" puede sonar muy raro, pero
# es que realmente es así en Common Lisp.  Consúltese el Cltl2, 13.5
# Character Control-Bit Functions, página 385
#
#: clhs.lisp:272 clhs.lisp:312
#, lisp-format
msgid "~S returns invalid value ~S, fix it, ~S, ~S, or ~S"
msgstr "~S devuelve valor no válido ~S, arréglelo, ~S, ~S, o ~S"

#: clhs.lisp:344
#, lisp-format
msgid "~S: invalid symbol ~S with id ~S: ~A"
msgstr "~S: invalado símbolo ~S con ID ~S: ~A"

#: clhs.lisp:347
#, lisp-format
msgid "~S: invalid id ~S for symbol ~S"
msgstr "~S: ID no válido ~S para símbolos ~S"

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: clhs.lisp:357
#, lisp-format
msgid "Ignore"
msgstr "Ignorar"

#: clhs.lisp:357
#, lisp-format
msgid "~S(~S): ~S does not know about ~S; the Implementation Notes must be regenerated"
msgstr "~S(~S): ~S no conoce acerca de ~S; las Notas de Implementación deben ser regeneradas"

#: threads.lisp:83
msgid "[Timed out] "
msgstr "[Tiempo agotado] "

# Creo que si ~S es un sólo carácter, te cabe en la misma línea :-) sv
#
#: foreign1.lisp:106
#, lisp-format
msgid "Cannot map string ~S to C since it contains a character ~S"
msgstr "La cadena ~S no puede asignarse a C puesto que contiene un carácter ~S"

#: foreign1.lisp:146
#, lisp-format
msgid "Invalid ~S component: ~S"
msgstr "Componente ~S no válida: ~S"

#: foreign1.lisp:212
#, lisp-format
msgid "Incomplete FFI type ~S is not allowed here."
msgstr "El tipo incompleto FFI ~S no está permitido aquí"

#: foreign1.lisp:220
#, lisp-format
msgid "FFI type should be a symbol, not ~S"
msgstr "Un tipo FFI debe ser un símbolo, no ~S"

# Duda: pues un poco lo de siempre. FFI significa Foreign Function
# Interface y todo el mundo sabe que es el módulo de llamadas a
# funciones escritas en otro lenguaje (lo que yo he traducido como
# llamadas extranjeras). Los programadores avanzados en Lisp (y sólo
# ellos podrían ver un mensaje como este, ...) saben muy bien lo que es
# FFI. ¿Lo dejo así?, ...
#
# Uno de nuestros revisores (César Ballardini) dijo en cierta ocasión:
# "No es necesario explicar la terminología dentro de su propio contexto."
# Es decir: Si finalmente te decides por FFI (que por lo que dices
# parece lo más razonable), pon cuidado de no explicarlo tanto, por ejemplo,
# en el mensaje anterior al anterior a este. sv
#
# Vale, pues entonces se queda como FFI ¡y listo! cll
#
#: foreign1.lisp:223
#, lisp-format
msgid "Invalid FFI type: ~S"
msgstr "Tipo FFI no válido: ~S"

#: foreign1.lisp:328
#, lisp-format
msgid "Invalid option in ~S: ~S"
msgstr "Opción no válida en ~S: ~S"

#: foreign1.lisp:331
#, lisp-format
msgid "Only one ~S option is allowed: ~S"
msgstr "Sólo se permite una opción ~S: ~S"

#: foreign1.lisp:387
#, lisp-format
msgid "Invalid parameter specification in ~S: ~S"
msgstr "Especificación de parámetro no válida en ~S: ~S"

#: foreign1.lisp:401
#, lisp-format
msgid "~S argument ~S is not a pointer in ~S"
msgstr "~S argumento ~S no es un puntero dentro de ~S"

#: foreign1.lisp:426
#, lisp-format
msgid "~S: No ~S argument and no ~S form in this compilation unit; ~S assumed now and for the rest of this unit"
msgstr "~S: Ningún argumento ~S y ningún formato ~S dentro de esta unidad de compilación; ahora se asume ~S y para el resto de esta unidad "

#: foreign1.lisp:432
#, lisp-format
msgid "The name must be a string, not ~S"
msgstr "El nombre debe ser una cadena, no ~S"

#: foreign1.lisp:436
#, lisp-format
msgid "The name ~S is not a valid C identifier"
msgstr "El nombre ~S no es un identificador válido en C"

#: foreign1.lisp:685
#, lisp-format
msgid "illegal foreign data type ~S"
msgstr "el tipo de datos externo ~S es no válido"

#: foreign1.lisp:920
#, lisp-format
msgid "~S(~S) requires writing to a C file"
msgstr "~S(~S) requiere escribir a un fichero C"

#: foreign1.lisp:940
#, lisp-format
msgid "~S(~S): CPP constant ~A is not defined"
msgstr "~S(~S): constante CPP ~A no está definido"

#: foreign1.lisp:956
#, lisp-format
msgid "~S: ~S option missing in ~S"
msgstr "~S: opción ~S ausente dentro de ~S"

#: foreign1.lisp:1079 foreign1.lisp:1136
#, lisp-format
msgid "~S is deprecated, use ~S instead"
msgstr "~S está obsoleto, emplee ~S en su lugar"

#: foreign1.lisp:1310
#, lisp-format
msgid "~S (~S): value ~S will be assigned to both ~S and ~S"
msgstr "~S (~S): valor ~S será asignado a ambos ~S y ~S"

#: foreign1.lisp:1319
#, lisp-format
msgid "~S does not name a C enum type"
msgstr "~S no nombra un tipo enumerado C"

#: foreign1.lisp:1322
#, lisp-format
msgid "~S is not of C enum type ~S"
msgstr "~S no es un tipo enumerado C ~S"

#: foreign1.lisp:1326
#, lisp-format
msgid "~S symbol value (~S) does not match its table value (~S) in ~S"
msgstr "~S valor simbóloco (~S) no coincide con su valor unido (~S) dentro de ~S"

#: foreign1.lisp:1331
#, lisp-format
msgid "~S is not a valid value of type ~S"
msgstr "~S no es un valor válido de tipo ~S"

#: foreign1.lisp:1349
#, lisp-format
msgid "~S is only allowed after ~S: ~S"
msgstr "~S sólo está permitido después de ~S: ~S"

#
# "%s fuera de intervalo\n"
# No me gusta del todo. A lo mejor:
# "%s fuera de limites\n" - lsg
#
# Al final me he decidido por:
#
# "%s se ha salido del rango\n"
#
# ¿No te mola más? - cll
#
#~ msgid "%s out of range"
#~ msgstr "%s se ha salido del rango"

# "msync(0x%x,0x%x,MS_INVALIDATE) fracasó." - lsg
#
# O "falló" en vez de "fracasó". ¿Qué te parece? - cll
#
#, fuzzy
#~ msgid "msync(0x%lx,0x%x,MS_INVALIDATE) failed."
#~ msgstr "msync(0x%x,0x%x,MS_INVALIDATE) falló."

#, fuzzy
#~ msgid "Cannot delete <%s>."
#~ msgstr "No se puede borrar %s ."

# He seguido la propuesta de Santiago Vila. A partir de ahora, y siempre
# que sea posible, el término "warning" se traducirá por "atención". En
# aquellos casos en que esto no es posible, lo he indicado
# explícitamente con un comentario indicando el motivo. - cll
#
#, fuzzy
#~ msgid "** WARNING: ** Too little free disk space for <%s>."
#~ msgstr "** ATENCIÓN: ** Hay muy poco espacio libre en disco para %s ."

#, fuzzy
#~ msgid "Please restart LISP with less memory (option -m)."
#~ msgstr "Por favor, vuelva a ejecutar LISP con menos memoria (opción -m)."

#, fuzzy
#~ msgid "Cannot make <%s> long enough."
#~ msgstr "No es posible agrandar %s lo suficiente."

#, fuzzy
#~ msgid "Cannot fill <%s>."
#~ msgstr "No se puede rellenar %s ."

#, fuzzy
#~ msgid "Cannot close <%s>."
#~ msgstr "No se puede cerrar %s ."

#
# Muy buena tu sugerencia, Leo. Se queda tal y como tu propones - lsg
#
# ¿Apoyo o soporte? sv
#
# Bueno, si, tienes razón. De hecho ésta era una de esas traducciones
# "raras". El problema es que no estaba seguro de que el término
# "soporte" fuese aceptado. Pero si es así, pues perfecto - cll
#
#~ msgid "Recompile your operating system with SYSV IPC support."
#~ msgstr "Recompile su sistema operativo con soporte para SYSV IPC."

#
# "no se puede asignar un segmento privado en la memoria compartida" - lsg
#
#, fuzzy
#~ msgid "Cannot allocate private shared memory segment of size %d."
#~ msgstr "No se puede asignar un segmento privado en la memoria compartida."

#, fuzzy
#~ msgid "Cannot map shared memory to address 0x%lx."
#~ msgstr "No se puede asignar la memoria compartida a la direccion 0x%x."

#, fuzzy
#~ msgid "%s: Cannot fill shared memory."
#~ msgstr "No se puede rellenar la memoria compartida."

#
# En este y en otros tantos mensajes, he seguido tu consejo, Leo. He
# traducido `remove' por `desechar' en todos los sitios. - cll
#
#~ msgid "Cannot remove shared memory segment."
#~ msgstr "No se puede desechar el segmento de memoria compartida."

#
# "EVAL/APPLY: no se han pasado suficientes argumentos a ~S" - lsg
#
# Hmmm, ... Si me gusta, es más "explicativo". Si, me gusta, si, si
# Lo único que te trastoco es lo de "pasado" por "entregado". Ya sabes,
# un toque de distinción :) - cll
#
#~ msgid "EVAL/APPLY: too few arguments given to ~S"
#~ msgstr "EVAL/APPLY: no se han entregado suficientes argumentos a ~S"

#
# "EVAL: la lista de argumentos pasada a ~S es punteada: ~S" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#, fuzzy
#~ msgid "~S: argument list given to ~S is dotted (terminated by ~S)"
#~ msgstr "EVAL: la lista de argumentos entregada a ~S está punteada: ~S"

#
# "el símbolo ~S no tiene valor asignado" - lsg
#
# En algún otro sitio ha aparecido algo parecido a esto. Verás, como me
# parece evidente que si un símbolo no tiene valor, es que no tiene
# valor asignado, pues prefiero omitir lo de "asignado" y evitar que el
# usuario lea términos innecesarios - cll
#
#, fuzzy
#~ msgid "~S: symbol ~S has no value"
#~ msgstr "el símbolo ~S no tiene valor"

#
# "~S: se ha invocado ~S con demasiados argumentos" - lsg
#
# a¡ Traducción brillantísima !!! Te ha quedado perfecto. Lo que yo había puesto:
#
# "~S: se han entregado demasiados argumentos a ~S"
#
# queda como más "indio". Tu traducción me encanta - cll
#
#~ msgid "~S: too many arguments given to ~S"
#~ msgstr "~S: se ha invocado ~S con demasiados argumentos"

#~ msgid "~S: ~S has no dynamic value"
#~ msgstr "~S: ~S no tiene ningún valor dinámico"

#~ msgid "dotted list given to ~S : ~S"
#~ msgstr "lista punteada entregada a ~S: ~S"

#~ msgid "~S: too many values"
#~ msgstr "~S: demasiados valores"

#~ msgid "~S: too many arguments to ~S"
#~ msgstr "~S: se han entregado demasiados argumentos a ~S"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#~ msgid "~S: host should be NIL, not ~S"
#~ msgstr "~S: el anfitrión debe ser NIL, no ~S"

#~ msgid "nonexistent directory: ~S"
#~ msgstr "directorio inexistente: ~S"

#, fuzzy
#~ msgid "~S: file ~S already exists"
#~ msgstr "~S: El fichero ~S ya existe"

#~ msgid "~S: package SCREEN is not implemented"
#~ msgstr "~S: el paquete SCREEN no está implementado"

#~ msgid "~S: invalid code-vector ~S"
#~ msgstr "~S: CODE-VECTOR inválido ~S"

#~ msgid "~S: ~S should be an integer >=0, not ~S"
#~ msgstr "~S: ~S debe ser un entero >=0, no ~S"

#~ msgid "~S: :update must not be specified without :initial-element"
#~ msgstr "~S: no debe especificarse :update sin :initial-element"

#~ msgid "~S: :start-index ~S must not be greater than :end-index ~S"
#~ msgstr "~S: El índice :start ~S no debe ser mayor que el índice :end ~S"

#~ msgid "~S: :start1-index ~S must not be greater than :end1-index ~S"
#~ msgstr "~S: El índice start1 ~S no debe ser mayor que el índice :end1 ~S"

#~ msgid "~S: :start2-index ~S must not be greater than :end2-index ~S"
#~ msgstr "~S: El índice :start2 ~S no debe ser mayor que el índice :end2 ~S"

#, fuzzy
#~ msgid "~S: the symbol ~S names a global special variable"
#~ msgstr "~S: el símbolo ~S nombra una variable global"

#~ msgid "~S: ~S is not an 8-bit number"
#~ msgstr "~S: ~S no es un número de 8 bits"

#~ msgid "~S: ~S is not a 16-bit number"
#~ msgstr "~S: ~S no es un número de 16 bits"

#, fuzzy
#~ msgid "~S: ~S is not a 32-bit number"
#~ msgstr "~S: ~S no es un número de 32 bits"

#, fuzzy
#~ msgid "~S: ~S is not a 64-bit number"
#~ msgstr "~S: ~S no es un número de 64 bits"

#~ msgid "Operation not permitted"
#~ msgstr "Operación no permitida"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
# "No existe ese archivo o directorio" - lsg
#
# Pues si, me gusta más la traducción de Leo, que la de Enrique, salvo
# que, tal y como tu mismo apuntas, Leo, se debe decir "fichero" y no
# "archivo" - cll
#
#~ msgid "No such file or directory"
#~ msgstr "No existe ese fichero o directorio"

#~ msgid "No such process"
#~ msgstr "No existe tal proceso"

#~ msgid "Interrupted system call"
#~ msgstr "Llamada al sistema interrumpida"

# Sugerencia: E/S. sv
#
# Vaya, tu sugerencia es tan informática que me impresiona que se me
# haya escapado. cll
#
#~ msgid "I/O error"
#~ msgstr "Error de E/S"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "No such device or address"
#~ msgstr "Dispositivo no configurado"

#~ msgid "Arg list too long"
#~ msgstr "Lista de argumentos demasiado larga"

#~ msgid "Exec format error"
#~ msgstr "Formato de programa no ejecutable"

#~ msgid "Bad file number"
#~ msgstr "Número de fichero equivocado"

# Sugerencia: No hay ningún proceso hijo. sv
#
# Bueno, Enrique tradujo este mensaje como "Ningún proceso hijo" en libc
# asi que, si te parece bien, lo pondré como él puesto que lo suyo es
# una traducción ya aceptada y que además, resulta de mezclar lo que yo
# he puesto y de tu sugerencia. cll
#
#~ msgid "No child processes"
#~ msgstr "Ningún proceso hijo"

#~ msgid "No more processes"
#~ msgstr "No hay más procesos"

#~ msgid "Not enough memory"
#~ msgstr "No hay memoria suficiente"

#~ msgid "Permission denied"
#~ msgstr "Permiso denegado"

#~ msgid "Bad address"
#~ msgstr "Dirección equivocada"

# Pongo esto un poco más en español.
# Antes decía "Dispositivo de bloque requerido".
# Por cierto, en otros sitios hemos puesto "dispositivo de bloques".
# ¿cómo es? sv
#~ msgid "Block device required"
#~ msgstr "Se requiere un dispositivo de bloque"

#~ msgid "Device busy"
#~ msgstr "Dispositivo ocupado"

#~ msgid "File exists"
#~ msgstr "El fichero ya existe"

#~ msgid "Cross-device link"
#~ msgstr "Enlace cruzado entre dispositivos"

#~ msgid "No such device"
#~ msgstr "No existe tal dispositivo"

#~ msgid "Not a directory"
#~ msgstr "No es un directorio"

#~ msgid "Is a directory"
#~ msgstr "Es un directorio"

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# a¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#~ msgid "Invalid argument"
#~ msgstr "Argumento inválido"

#~ msgid "File table overflow"
#~ msgstr "Desbordamiento de la tabla de ficheros"

#~ msgid "Too many open files"
#~ msgstr "Demasiados ficheros abiertos"

#~ msgid "Inappropriate ioctl for device"
#~ msgstr "El dispositivo no acepta la llamada `ioctl'"

#~ msgid "Text file busy"
#~ msgstr "Fichero de texto en uso"

#~ msgid "File too large"
#~ msgstr "Fichero demasiado grande"

#~ msgid "No space left on device"
#~ msgstr "No queda espacio en el dispositivo"

#~ msgid "Illegal seek"
#~ msgstr "Desplazamiento inválido"

#~ msgid "Read-only file system"
#~ msgstr "Sistema de ficheros de sólo lectura"

#~ msgid "Too many links"
#~ msgstr "Demasiados enlaces"

#~ msgid "Argument out of domain"
#~ msgstr "Argumento fuera del dominio"

#
# "El resultado es demasiado grande" - lsg
#
# Si, ya he cambiado `largo' por `grande' en todos los mensajes. Un
# fallo realmente infantil :( - cll
#
#~ msgid "Result too large"
#~ msgstr "El resultado es demasiado grande"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "Operation would block"
#~ msgstr "La operación se bloquearía"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "Operation now in progress"
#~ msgstr "Operación en curso"

# Already sería "ya". aún sería still.
# Sugerencia: La operación ya se está realizando. sv
#
# Más aún, echando un ojo a la traducción de Enrique Melero en el glibc,
# me he encontrado con el mismo mensaje y el dice: "La operación ya se
# está llevando a cabo". Me gusta bastante. cll
#
#~ msgid "Operation already in progress"
#~ msgstr "La operación ya se está llevando a cabo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "Too many levels of symbolic links"
#~ msgstr "Demasiados niveles de enlaces simbólicos"

#~ msgid "File name too long"
#~ msgstr "Nombre de fichero demasiado largo"

#~ msgid "Directory not empty"
#~ msgstr "El directorio no está vacío"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "Stale NFS file handle"
#~ msgstr "Fichero NFS bloqueado"

# Duda: Aquí he seguido el consejo de Enrique Melero.
#
# En la versión 1.5 he decidido cambiar el término `camino' por
# `trayectoria', tal y como recomiendan los traductores del libro Lisp,
# (3ra edición) de Winston y Horn en el "Vocabulario bilingüe de
# términos técnicos", en la página 650.
#
#~ msgid "Too many levels of remote in path"
#~ msgstr "Demasiados niveles de profundidad en la trayectoria"

#~ msgid "Socket operation on non-socket"
#~ msgstr "Operación de `sockets' sobre un \"no-socket\""

#~ msgid "Destination address required"
#~ msgstr "Se necesita la dirección del destino"

#~ msgid "Message too long"
#~ msgstr "Mensaje demasiado largo"

#~ msgid "Protocol wrong type for socket"
#~ msgstr "Tipo de protocolo incorrecto para el `socket'"

#~ msgid "Option not supported by protocol"
#~ msgstr "Opción no soportada por el protocolo"

#~ msgid "Protocol not supported"
#~ msgstr "Protocolo no soportado"

#~ msgid "Socket type not supported"
#~ msgstr "Tipo de `socket' no soportado"

# Pongo `socket' en vez de socket. sv
#~ msgid "Operation not supported on socket"
#~ msgstr "Acción no permitida en un `socket'"

#~ msgid "Protocol family not supported"
#~ msgstr "Familia de protocolos no soportada"

#~ msgid "Address family not supported by protocol family"
#~ msgstr "Familia de direcciones no soportada por el protocolo"

#~ msgid "Address already in use"
#~ msgstr "Dirección en uso"

# Sugerencia: No se puede asignar. sv
#
# ¡Vale!, "No puede asignarse ..." es demasiado, ..., ¿impersonal? cll
#~ msgid "Cannot assign requested address"
#~ msgstr "No se puede asignar la dirección requerida"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#~ msgid "Network is down"
#~ msgstr "La red no está operativa"

#~ msgid "Network is unreachable"
#~ msgstr "No es posible conectarse con la red"

#~ msgid "Network dropped connection on reset"
#~ msgstr "Se ha perdido la conexión con la red debido a una reinicialización"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#~ msgid "Software caused connection abort"
#~ msgstr "El software ha provocado la interrupción de la conexión"

#~ msgid "Connection reset by peer"
#~ msgstr "Conexión reinicializada por el otro extremo"

#
# Duda: ¿Y buffer? ¿Como traduzco buffer?
#
# Yo he visto a menudo 'memoria tampón', que es el término usado por los
# franceses. - lsg
#
# Tienes toda la razón, ... Sin embargo, en este caso, la traducción
# francesa es:
#
# "Pas d'espace disponible pour un buffer"
#
# Además, como en spanglish.txt pone:
#
# "buffer - memoria intermedia, tampón, buffer"
#
# pues he utilizado `buffer' tal cual, ... - cll
#
#~ msgid "No buffer space available"
#~ msgstr "No queda espacio en el buffer"

# Lo de socket, si te parece. sv
#
# Te digo lo mismo que te dije antes. Cuando hay finalizado con la
# traducción me pondré a cambiar todas estas cosas con macros. cll
#
#~ msgid "Socket is already connected"
#~ msgstr "El `socket' ya está conectado"

#~ msgid "Socket is not connected"
#~ msgstr "El `socket' no está conectado"

# Añado comitas a `socket'. Es una especie de convenio que seguimos
# cuando no nos queda más remedio que poner la palabra inglesa.
# Así al menos reconocemos que es una palabra extraña. sv
#~ msgid "Cannot send after socket shutdown"
#~ msgstr "No se puede enviar después de la ruptura del `socket'"

# Duda: ¿ Se excedió el tiempo para la conexión ?
#~ msgid "Connection timed out"
#~ msgstr "Se excedió el tiempo para la conexión"

#~ msgid "Connection refused"
#~ msgstr "Conexión rechazada"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#, fuzzy
#~ msgid "Remote peer released connection"
#~ msgstr "El software ha provocado la interrupción de la conexión"

# Estas dos darán que hablar, pero otro día las discutiremos... sv
#
# Al decir tú eso, he leído la traducción de este término en libc
# (traducido por Enrique Melero) y, madre mía, me he quedado
# "flipao". Aquello fue una discusión encarnizada, ...
#
# Para mas inri, yo no estoy de acuerdo con ninguno de los dos :) Verás,
# un host puede estar "caído" (que así es como se suele decir aunque es,
# evidentemente, incorrecto) y por ello no tiene por qué no estar
# operativo (en libc lo habeis traducido como "el `host' no est
# operativo"). De hecho, puede estar operando pero, por algún problema
# de la red o de tu propia transmisión, resultar inalcanzable, ... En
# fin, por este motivo prefiero "El `host' no está disponible"
#
# Por otra parte, no estoy muy de acuerdo con Enrique, ..., a mí lo de
# poner host no me gusta. Ciertamente, un `host' no tiene por qué ser un
# servidor, necesariamente, pero es el caso más común. En cualquier
# caso, todo el mundo comprende perfectamente que el `host' es un
# servidor. cll
#
#~ msgid "Host is down"
#~ msgstr "El servidor no está disponible"

# Aquí, pues idem de idem, ... :) cll
#
#~ msgid "Host is unreachable"
#~ msgstr "No se puede conectar con el servidor"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#, fuzzy
#~ msgid "Networking error"
#~ msgstr "La red no está operativa"

#~ msgid "Too many processes"
#~ msgstr "Demasiados procesos"

#~ msgid "Too many users"
#~ msgstr "Demasiados usuarios"

#~ msgid "Disk quota exceeded"
#~ msgstr "Cuota de disco excedida"

#~ msgid "Not a stream device"
#~ msgstr "No es un dispositivo de flujo"

#~ msgid "Timer expired"
#~ msgstr "El temporizador expiró"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "Out of stream resources"
#~ msgstr "Alcanzado el límite de recursos de `streams'"

#~ msgid "No message of desired type"
#~ msgstr "No hay mensajes del tipo deseado"

#~ msgid "Not a data message"
#~ msgstr "No es un mensaje de datos"

#~ msgid "Identifier removed"
#~ msgstr "Identificador desechado"

# Duda: Eso del `inter-bloqueo' ¿estará bien?
#
#~ msgid "Resource deadlock would occur"
#~ msgstr "Podría ocurrir un interbloqueo entre recursos"

# Duda: Aunque Bruno Haible me ha asegurado que la etiqueta
# sys_errlist[ENOLCK] del glibc.po en español contiene la traduccion que
# yo debiera usar, me he decidido por las indicaciones de Santiago Vila
# en su respuesta a mi mail y he puesto, simplemente: "No quedan
# registros de bloqueo disponibles"
#
#~ msgid "No record locks available"
#~ msgstr "No quedan registros de bloqueo disponibles"

#~ msgid "Machine is not on the network"
#~ msgstr "La máquina no está en la red"

#~ msgid "Object is remote"
#~ msgstr "El objeto es remoto"

#~ msgid "Link has been severed"
#~ msgstr "El enlace ha sido destruído"

#~ msgid "Advertise error"
#~ msgstr "Error de anuncio"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "Srmount error"
#~ msgstr "Error de `srmount'"

#~ msgid "Communication error on send"
#~ msgstr "Error de comunicaciones en el envío"

#~ msgid "Protocol error"
#~ msgstr "Error de protocolo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "Multihop attempted"
#~ msgstr "Se ha intentado un multihop"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "Remote address changed"
#~ msgstr "La dirección remota ha cambiado"

#~ msgid "Function not implemented"
#~ msgstr "Función no implementada"

#~ msgid "Winsock error "
#~ msgstr "Error de `winsock'"

#, fuzzy
#~ msgid "~S: C value ~S is not found in table ~S: ~S"
#~ msgstr "~S: el argumento ~S no es un carácter"

#~ msgid "~S: Unsupported call mechanism: ~S"
#~ msgstr "~S: mecanismo de llamado no soportado: ~S"

#~ msgid "~S: Bad function prototype: ~S"
#~ msgstr "~S: Prototipo de función equivocado: ~S"

#~ msgid "~S: Wrong number of arguments for prototype ~S"
#~ msgstr "~S: número incorrecto de argumentos para el prototipo ~S"

#~ msgid "~S: Bad argument for prototype ~S: ~S"
#~ msgstr "~S: Argumento equivocado para el prototipo ~S: ~S"

#~ msgid "~S: Bad argument: ~S"
#~ msgstr "~S: El argumento ~S está equivocado"

#~ msgid "~S: ~S is not a valid address"
#~ msgstr "~S: ~S no es una dirección válida"

#~ msgid "illegal syntax in MACROLET: ~S"
#~ msgstr "sintaxis inválida en MACROLET: ~S"

#~ msgid "illegal syntax in SYMBOL-MACROLET: ~S"
#~ msgstr "sintaxis inválida en SYMBOL-MACROLET: ~S"

#~ msgid "illegal syntax in FLET/LABELS: ~S"
#~ msgstr "sintaxis inválida en FLET/LABELS: ~S"

#, fuzzy
#~ msgid "illegal syntax in FUNCTION-MACRO-LET: ~S"
#~ msgstr "sintaxis inválida en MACROLET: ~S"

#~ msgid "The lambda list of macro ~S contains a dot after &KEY."
#~ msgstr "La lista lambda de la macro ~S contiene un punto después de &KEY"

#~ msgid "type name should be a symbol, not ~S"
#~ msgstr "el nombre del tipo debe ser un símbolo, no ~S"

#, fuzzy
#~ msgid "Lambda list element ~S is superfluous. Only one variable is allowed after &ENVIRONMENT."
#~ msgstr "El elemento ~S de la lista lambda es innecesario."

#, fuzzy
#~ msgid "Missing &ENVIRONMENT parameter in lambda list ~S"
#~ msgstr "La lista lambda ~S necesita un parámetro &REST"

#, fuzzy
#~ msgid "Missing &WHOLE parameter in lambda list ~S"
#~ msgstr "La lista lambda ~S necesita un parámetro &REST"

#~ msgid "~S: argument to UNSIGNED-BYTE must be an integer or * : ~S"
#~ msgstr "~S: el argumento de UNSIGNED-BYTE debe ser un entero o * : ~S"

#~ msgid "~S ~S, option ~S may only be given once"
#~ msgstr "~S ~S, la opción ~S sólo se puede indicar una vez"

#~ msgid "~S ~S: option ~S should be written ~S"
#~ msgstr "~S ~S: la opción ~S debe escribirse como ~S"

#~ msgid "~S: invalid syntax for name and options: ~S"
#~ msgstr "~S: la sintáxis del nombre y las opciones es inválida: ~S"

#, fuzzy
#~ msgid "The ~~newline format directive cannot take both modifiers."
#~ msgstr "La directiva ~~newline no puede tomar ambos modificadores."

#, fuzzy
#~ msgid "~s: no local name ~s in ~s"
#~ msgstr "~: anfitrión ~ desconocido en ~"

#~ msgid "Non-symbol ~S may not be declared IGNORE."
#~ msgstr "El \"no símbolo\" ~S no debe declararse IGNORE."

#~ msgid "Non-symbol ~S may not be declared IGNORABLE."
#~ msgstr "El \"no-símbolo\" ~S no debe declararse IGNORABLE."

#, fuzzy
#~ msgid "Non-symbol ~S may not be declared READ-ONLY."
#~ msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#
# Duda: He querido traducir la palabra `warning' por `aviso' que es como
# debería decirse en español, ¿no?. ¿Hay algún término adoptado en
# es@li.org, para esta palabra?.
#
# Sí, atención. sv
#
# Si, si, ya lo he hecho, ... En todas partes he puesto "WARNING" por
# "ATENCIÓN". No es exactamente lo mismo, pero me parece una sugerencia
# genial, de hecho me gusta muchísimo más que aquello de "AVISO:". De
# esta manera, parecía que te estaban hablando los "super-tacañones" :) - cll
#
# Sin embargo, Santiago, este caso es bastante peculiar. Verás, si dejo
# "ATENCIÓN" aquí, entonces, durante la compilación de un proyecto con
# varios ficheros en Lisp, podría salir, por ejemplo, un mensaje como el
# siguiente (tomado de un ejemplo real, que conste, ...):
#
# --------------
# ATENCIÓN en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
# Y yo pregunto, en este caso ¿no es mejor poner "ADVERTENCIA"? La
# verdad es que "ADVERTENCIA" me suena mucho mejor que "ATENCIÓN" y que
# "AVISO". En este caso, lo que se tendría es:
#
# --------------
# ADVERTENCIA en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
#
#, fuzzy
#~ msgid "WARNING~@[ in ~A~]~A :"
#~ msgstr "ADVERTENCIA~@[ en la función ~S~]~A :~%"

#, fuzzy
#~ msgid "ERROR~@[ in ~S~]~A :"
#~ msgstr "ERROR~@[ en la función ~S~]~A : ~%~?"

#~ msgid "Illegal syntax in COMPILER-LET: ~S"
#~ msgstr "Sintaxis inválida en COMPILER-LET: ~S"

#, fuzzy
#~ msgid "~s situation must be ~s, ~s or ~s, but not ~s"
#~ msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#, fuzzy
#~ msgid "~S: ~S should be a symbol"
#~ msgstr "~S: la variable ~S debe ser un símbolo"

#, fuzzy
#~ msgid "(~S ~S): The slot-definition argument is not of type ~S."
#~ msgstr "~S: el INITIAL-ELEMENT ~S no es del tipo ~S"

#, fuzzy
#~ msgid "~S: ~A"
#~ msgstr "~S: incorrecto ~S"

#~ msgid "Removing method ~S in ~S"
#~ msgstr "Borrando el método ~S de ~S"

#~ msgid "The generic function ~S is being modified, but has already been called."
#~ msgstr "La función genérica ~S está siendo modificada, pero ya ha sido invocada."

#, fuzzy
#~ msgid "~S ~S: invalid ~S option: ~S"
#~ msgstr "~S ~S: la opción ~S es inválida"

#~ msgid "~S: the name of a condition must be a symbol, not ~S"
#~ msgstr "~S: el nombre de una condición debe ser un símbolo, y no ~S"

#, fuzzy
#~ msgid "~A is not a number. Try again."
#~ msgstr "~: ~ no es un número de 8 bits"

#, fuzzy
#~ msgid "Values: "
#~ msgstr "valores: "

#, fuzzy
#~ msgid "Unprintable error message."
#~ msgstr "Mensaje de error no imprimible"

#, fuzzy
#~ msgid "~%CLISP Documentation is at~% ~S"
#~ msgstr "documentación: ~SA"

#, fuzzy
#~ msgid "Argument list: ~A"
#~ msgstr "~%lista de argumentos: "

#~ msgid "illegal syntax in LETF* binding: ~S"
#~ msgstr "sintaxis inválida en la ligadura de LETF*: ~S"

#~ msgid "illegal syntax in LETF binding: ~S"
#~ msgstr "sintaxis inválida en la ligadura de LETF: ~S"

#, fuzzy
#~ msgid "~S: ~S does not own ~S"
#~ msgstr "~S: ~S no nombra una clase"

#, fuzzy
#~ msgid "~s is deprecated, use ~s instead"
#~ msgstr "Función no implementada"

#~ msgid "Basename ~S not a keyword or libraryname ~S not a string"
#~ msgstr "La base ~S no es una palabra clave o el nombre de la biblioteca ~S no es una cadena de caracteres"

#~ msgid "Library redefinition: old ~S, new ~S"
#~ msgstr "La biblioteca llamada ~S ha sido redefinida como ~S"

#~ msgid "Unknown library: ~S"
#~ msgstr "Biblioteca desconocida: ~S"

#~ msgid "Library ~S is not open"
#~ msgstr "La biblioteca ~S no está abierta"

#~ msgid "Unknown function of library ~S: ~S"
#~ msgstr "No se conoce ninguna función en la biblioteca ~S con el nombre ~S"

#~ msgid "Offset must be a fixnum: ~S"
#~ msgstr "El desplazamiento no es del tipo FIXNUM: ~S"

#~ msgid ";; redefining foreign library function ~S~%;;  from ~S to ~S"
#~ msgstr ";; redefiniendo la función ~S de la biblioteca externa~%;;  de ~S a ~S"

#~ msgid "Unknown register: ~S"
#~ msgstr "Registro desconocido: ~S"

#~ msgid "Invalid parameter specification ~S in function ~S"
#~ msgstr "La especificación de parámetros ~S de la función ~S es incorrecta"

#~ msgid "Unknown library function: ~S"
#~ msgstr "La función de biblioteca ~S no está definida"

#~ msgid "Bad number of arguments for ~S: ~S"
#~ msgstr "Número de argumentos equivocado para ~S: ~S"

#~ msgid "~S: variable specification after ~S too long : ~S"
#~ msgstr "~S: especificacion de variable tras ~S demasiado larga : ~S"

#~ msgid "~S from ~S: bit vector is longer than the explicitly given length ~S"
#~ msgstr "~S en ~S: la longitud del vector de bits es mayor que la longitud explícitamente indicada ~S"

#~ msgid "~S from ~S: must specify element of bit vector of length ~S"
#~ msgstr "~S en ~S: debe especificar un elemento para el vector de bits de longitud ~S"

#~ msgid "~S from ~S: invalid bit-vector length ~S"
#~ msgstr "~S desde 4S: longitud no válida de BIT-VECTOR ~S"

# Junto las ¡! sv
# Sugerencia "¡Se estaba trazando!" (es como más "en español") sv
#
# Sí, tu sugerencia me gusta. Como se nota que tienes experiencia, ...,
# ¿eh? cll
#
#~ msgid "DEFUN/DEFMACRO: redefining ~S; it was traced!"
#~ msgstr "DEFUN/DEFMACRO: redefiniendo ~S; ¡se estaba rastreando!"

#~ msgid "~S: ~S is not a library"
#~ msgstr "~S: ~S no es una biblioteca"

#~ msgid "too long sequence ~S"
#~ msgstr "secuencia demasiado larga ~S"

# Duda: En Common Lisp existe lo que se denominan "Listas de asociación"
# (Common Lisp, The Language, 2nd Edition - Guy L. Steel, página 431) o,
# en inglés, "Association Lists" que abreviadamente se conocen como
# "alist" o "a-list". En realidad, aunque en español, mucha gente dice
# "alistas", esto no me parece correcto y me parece mucho más formal
# decir "listas de asociación".
#
# De hecho, el término "listas de asociación" será facílisimamente
# reconocible por el programador, mientras que "alista" exige estar un
# poquito más experimentado con el Lisp.
#
# Más aún, los traductores del libro "Lisp" (3ra edición) de Winston y
# Horn, utilizan la expresión "lista de asociación" en la presentación
# de la función ASSOC en la página 34, aunque luego también se refieran
# a ellas como "listas-a".
#
#~ msgid "~S from ~S: the value of ~S has been altered arbitrarily, it is not an alist: ~S"
#~ msgstr "~S en ~S: el valor de ~S ha sido modificado arbitrariamente, no es una lista de asociación: ~S"

#~ msgid "~S: array ~S has no fill-pointer"
#~ msgstr "~S: la matriz ~S no tiene ningún puntero de relleno"

#, fuzzy
#~ msgid "Argument list: ~A."
#~ msgstr "~%lista de argumentos: "

#, fuzzy
#~ msgid "~: argument ~S is not a character"
#~ msgstr "~: el argumento ~ no es un carácter"

#, fuzzy
#~ msgid "~S: argument ~S is neither an open SOCKET-STREAM nor a positive FIXNUM"
#~ msgstr "~S: el argumento ~S no es un SOCKET-STREAM"

#~ msgid "~S: argument ~S should be a vector of type (ARRAY (UNSIGNED-BYTE 8) (*))"
#~ msgstr "~S: el argumento ~S debe ser un vector del tipo (ARRAY (UNSIGNED-BYTE 8) (*)) "

#, fuzzy
#~ msgid "Loading logical host ~S from file ~A ..."
#~ msgstr "La carga del fichero "

#~ msgid "~S ~S, slot option for slot ~S must have the value ~S or ~S, not ~S"
#~ msgstr "~S ~S, la opción de ranura para ~S debe tener el valor ~S o ~S, y no ~S"

#, fuzzy
#~ msgid "service does not exist: ~A/~A"
#~ msgstr "el fichero ~ no existe"

#, fuzzy
#~ msgid "~S: ~S is not a 1:1 encoding"
#~ msgstr "~S: ~S no es un registro"

#~ msgid "~S from ~S: label #~S? too large"
#~ msgstr "~S en ~S: la etiqueta #~S? es demasiado grande"

#, fuzzy
#~ msgid " (macro: ~s)"
#~ msgstr " (macro)"

#~ msgid "stack size"
#~ msgstr "tamaño de la pila"

#~ msgid "no doc-strings allowed here: ~S"
#~ msgstr "no se permite la utilización de cadenas de documentación aquí: ~S"

#~ msgid "~S: :VERSION-argument should be NIL or :WILD or :NEWEST, not ~S"
#~ msgstr "~S: el argumento :VERSION debe ser o bien NIL, o :WILD o :NEWEST, pero no ~S"

#~ msgid "~S: stream must be a generic-stream, not ~S"
#~ msgstr "~S: el flujo debe ser un `generic-stream', no ~S"

#~ msgid "~S: stream must be a socket-stream, not ~S"
#~ msgstr "~S: el flujo debe ser un `socket-stream' y no ~S"

# "~S: ~S no es una formación" - lsg
#
# Aunque en la lista de spanglish.txt pone "formación", en este caso
# creo que será mucho más conveniente poner "matriz" porque de hecho,
# los mensajes se refieren a matrices, ... - cll
#
#~ msgid "~S: ~S is not an array"
#~ msgstr "~S: ~S no es una matriz"

#~ msgid "ANSI C program"
#~ msgstr "programa ANSI C"

#, fuzzy
#~ msgid "~s: compiled file ~s was created by an older CLISP version and needs to be recompiled"
#~ msgstr "Este fichero fue producido por otra versión de lisp. Debe recompilarse."

#~ msgid "~S: ~S is not a symbol."
#~ msgstr "~S: ~S no es un símbolo."

#, fuzzy
#~ msgid "~S: Missing store variable."
#~ msgstr "~S: variable ausente"

#, fuzzy
#~ msgid "~S ~S: &REST variable ~S should be a symbol."
#~ msgstr "~S: la variable ~S debe ser un símbolo"

#, fuzzy
#~ msgid "~S(~S): Only one variable is allowed after &REST, not ~S"
#~ msgstr "Sólo se permite una variable después de &REST, no ~S"

#, fuzzy
#~ msgid "~s: ~s is not a function name"
#~ msgstr "~: ~ no es el nombre de una función"

#, fuzzy
#~ msgid "Function ~s is deprecated~@[, use ~s instead~]"
#~ msgstr "Función no implementada"

# eso de función "a compilar" siempre
# me pareció un vicio moderno.
# Sugerencia: El nombre de la función que hay que compilar ... sv
#
# Perfecto, ... cll
#
#~ msgid "Name of function to be compiled must be a symbol, not ~S"
#~ msgstr "El nombre de una función que hay que compilar debe ser un símbolo, no ~S"

#, fuzzy
#~ msgid "~S: missing forms after ~A"
#~ msgstr "~S: variable ausente"

#~ msgid "~S ~S: The only valid generic function class name is ~S : ~S"
#~ msgstr "~S ~S: El único nombre válido de una clase de función genérica es ~S : ~S"

#~ msgid "~S ~S: The only valid method class name is ~S : ~S"
#~ msgstr "~S ~S: El único nombre válido de una clase de métodos es ~S : ~S"

#~ msgid "~S ~S: ~S is missing some required parameter"
#~ msgstr "~S ~S: ~S necesita algunos parámetros obligatorios"

#~ msgid "~S ~S: variable name ~S should be a symbol"
#~ msgstr "~S ~S: el nombre de la variable ~S debe ser un símbolo"

#, fuzzy
#~ msgid "~S is not a valid a ~S designator"
#~ msgstr "~: ~ no es un índice válido en ~"

#~ msgid "Cannot disassemble ~S"
#~ msgstr "No se puede desensamblar ~S"

#, fuzzy
#~ msgid "~%Argument list: ~A"
#~ msgstr "~%lista de argumentos: "

#, fuzzy
#~ msgid "~: ~ should be a lambda expression"
#~ msgstr "~S: ~S debe ser una expresión lambda"

#, fuzzy
#~ msgid "~: symbol ~ is declared special and must not be declared a macro"
#~ msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#~ msgid "~: symbol ~ must not be declared SPECIAL and a macro at the same time"
#~ msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#~ msgid "~: the ~ clause must be the last one"
#~ msgstr "~: la clausula ~ debe ser la última"

#, fuzzy
#~ msgid "~: file ~ already exists"
#~ msgstr "~: El fichero ~ ya existe"

#, fuzzy
#~ msgid "~ from ~: character read should be a character: ~"
#~ msgstr "~ en ~: el carácter leído debe ser un STRING-CHAR: ~"

#~ msgid "~: input stream ~ ends within read macro beginning to ~"
#~ msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba una macro de lectura en ~"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#~ msgid "~ from ~: After ~ is ~ an undefined dispatch macro character"
#~ msgstr "~ en ~: Después de ~ está ~, que no es un macro carácter secundario"

#~ msgid "~: index ~ too large for ~"
#~ msgstr "~: el índice ~ es demasiado grande para ~"

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#, fuzzy
#~ msgid "~: There is no package with name ~"
#~ msgstr "~S: No hay ningún paquete con el nombre ~S."

#~ msgid "~: ~ is not a closure"
#~ msgstr "~: ~ no es una cerradura"

#, fuzzy
#~ msgid "~: ~ is not a class"
#~ msgstr "~S: ~S no es una clase"

#~ msgid "~: index should be an integer, not ~"
#~ msgstr "~: el índice debe ser un entero, no ~"

#~ msgid "~: User break"
#~ msgstr "~: Interrupción del usuario"

#, fuzzy
#~ msgid "~: ~ is not a symbol"
#~ msgstr "~S: ~S no es un símbolo."

#, fuzzy
#~ msgid "~: argument ~ is not a character"
#~ msgstr "~: el argumento ~ no es un carácter"

#~ msgid "~: undefined function ~"
#~ msgstr "~: la función ~ no está definida"

#, fuzzy
#~ msgid "~: invalid type specification ~"
#~ msgstr "~S: la especificación de tipo ~S es inválida"

#~ msgid "illegal foreign data type ~"
#~ msgstr "el tipo de datos extranjero ~ es inválido"

#~ msgid "~: :OUT argument is not a pointer: ~"
#~ msgstr "~: el argumento :OUT no es un puntero: ~"

#, fuzzy
#~ msgid "~: ~ is not an output ~"
#~ msgstr "~: ~ no es un par"

#, fuzzy
#~ msgid "~: argument ~ should be ~."
#~ msgstr "~: el argumento ~ debe ser un flujo"

#~ msgid "Please choose:"
#~ msgstr "Por favor, escoja:"

#~ msgid "Please choose one of ~:{~A~:^, ~} ."
#~ msgstr "Por favor, elija uno/a de ~:{~A~:^, ~} ."

#~ msgid "uninterning ~S from ~S uncovers a name conflict."
#~ msgstr "Al sacar ~S de ~S se ha puesto de manifiesto un conflicto entre nombres."

#~ msgid "You may choose how to proceed."
#~ msgstr "Puede elegir cómo continuar."

#~ msgid "You may choose in favour of which symbol to resolve the conflict."
#~ msgstr "Puede elegir en favor de qué símbolo se debe resolver el conflicto."

#~ msgid "Which symbol should be accessible in ~S ?"
#~ msgstr "¿ Qué símbolo debe ser accesible en ~S ?"

#~ msgid "You may choose for every conflict in favour of which symbol to resolve it."
#~ msgstr "Puede elegir en favor de qué símbolo se debe resolver cada conflicto."

#
# Es una traducción un poco libre (literalmente sería "el nombre = ~S
# entra en conflicto...."), pero ésta me parece más corta y correcta. - lsg
#
#~ msgid "~S name conflicts while executing USE-PACKAGE of ~S into package ~S."
#~ msgstr "Conflicto de nombre ~S al ejecutar USE-PACKAGE de ~S al paquete ~S"

#
# Si fuera inglés corriente, estaría bien tu traducción, pero es inglés
# 'telegráfico', y en realidad quieren decir lo que te he escrito, es
# decir, 'nuevo' afecta a 'nombre', no a 'paquete'.
#
# Eres un gran maestro, algo así como un quinto dan de las traducciones,
# ... ¡Tienes toda la razón! :) - cll
#
#~ msgid "Please input new package name:"
#~ msgstr "Por favor, introduzca un nuevo nombre de paquete:"

#~ msgid "Please input new package nickname:"
#~ msgstr "Por favor, introduzca un nuevo apodo de paquete:"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# A partir de la versión 1997-05-03, este mensaje ha cambiado y se
# refiere a elementos que serán ignorados. Como no puede anticiparse
# cual será el género del objeto que se ignora, he preferido poner lo de
# os/as. ¿Qué os parece?
#
#~ msgid "Both will be ignored."
#~ msgstr "Ambos/as serán ignorados/as."

#~ msgid "Invalid keyword-value-pair: ~S ~S"
#~ msgstr "Par argumento clave y valor inválido: ~S ~S"

#~ msgid "COND code contains a dotted list, ending with ~S"
#~ msgstr "El código de COND contiene una lista punteada que termina con ~S"

#, fuzzy
#~ msgid " from file "
#~ msgstr ""
#~ "#-#-#-#-#  es1.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
#~ " de la fuente ~S\n"
#~ "#-#-#-#-#  es2.po (GNU clisp 1996-03-31)  #-#-#-#-#\n"
#~ " de la fuente ~SS"

#, fuzzy
#~ msgid "Error: ~~:@> not implemented"
#~ msgstr "función no implementada"

#, fuzzy
#~ msgid "~S: ~S must name a closure"
#~ msgstr "~: ~ no es una cerradura"

#, fuzzy
#~ msgid "~S: ~S must be a closure"
#~ msgstr "~: ~ no es una cerradura"

#~ msgid "instance ~S of class ~S has no slots (wrong metaclass)"
#~ msgstr "la instancia ~S de la clase ~S no tiene ranuras (metaclase errónea)"

#~ msgid "Too few arguments to ~S: ~S"
#~ msgstr "Muy pocos argumentos para ~S: ~S"

#, fuzzy
#~ msgid "~: malloc() failed"
#~ msgstr "mprotect() falló."

#
# Muy bueno el apunte sobre ese acento en "cómo". Gracias, Santiago - cll
#
#, fuzzy
#~ msgid ""
#~ "Internal error: statement in file ~, line ~ has been reached!!\n"
#~ "Please send the authors of the program a description how you produced this error!"
#~ msgstr ""
#~ "error interno: aen la sentencia del fichero ~, línea ~!!\n"
#~ "¡Por favor, envíe a los autores del programa una descripción de cómo\n"
#~ "se produjo este error!"

#
# "EVAL: la variable ~ no tiene asignado ningún valor" - lsg
#
# Bueno, he quitado lo de "asignado" porque parece de "perogrullo", pero
# lo demás se queda - cll
#
#~ msgid "EVAL: variable ~ has no value"
#~ msgstr "EVAL: la variable ~ no tiene ningún valor"

#~ msgid "Too many documentation strings in ~"
#~ msgstr "Demasiadas cadenas de documentación en ~"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#, fuzzy
#~ msgid "~: lambda-list for ~ is missing"
#~ msgstr "FUNCTION: falta la lista lambda de ~"

#
# "FUNCTION: la lista lambda de ~ debe ser una lista, no un(a) ~" - lsg
#
# Lo de "un(a)" no me mola, aunque sin esa palabra el mensaje queda más
# "telegráfico", me parece más apropiado para tratarse del "diálogo con
# un ordenador" :) - cll
#
#, fuzzy
#~ msgid "~: lambda-list for ~ should be a list, not ~"
#~ msgstr "FUNCTION: la lista lambda de ~ debe ser una lista, no ~"

#, fuzzy
#~ msgid "~: illegal declaration ~"
#~ msgstr "FUNCTION: declaración inválida ~"

#, fuzzy
#~ msgid "~: variable specification after ~ too long: ~"
#~ msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#, fuzzy
#~ msgid "~: ~ var must be followed by ~ or ~ or end of list: ~"
#~ msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~"

#
# Igualmente: "FUNCTION: &REST debe ir seguido de una variable: ~" - lsg
#
# Pues si, es que cuando uno está mucho tiempo traduciendo del inglés,
# llega un momento en que empieza coger los hábitos de ese lenguaje y
# empieza a expresarse de una manera extraña, ... - cll
#
#, fuzzy
#~ msgid "~: ~ must be followed by a variable: ~"
#~ msgstr "FUNCTION: &REST debe ir seguido de una variable: ~"

#, fuzzy
#~ msgid "~: incorrect variable specification after ~: ~"
#~ msgstr "FUNCTION: especificación de variable incorrecta después de &KEY: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#~ msgid "~: ~ must be followed by ~ or end of list: ~"
#~ msgstr "~: ~ debe estar seguida por ~ o final de lista: ~"

#~ msgid "~: variable specification after ~ too long : ~"
#~ msgstr "~: especificacion de variable tras ~ demasiado larga : ~"

#~ msgid "~: badly placed lambda-list keyword ~: ~"
#~ msgstr "~: palabra clave ~ malamente situada de lista lambda ~: ~"

#~ msgid "~: too many parameters in the lambda-list ~"
#~ msgstr "~: demasiados parámetros dentro de la lista lambda ~"

#~ msgid "~: a dot in a lambda-list is allowed only for macros, not here: ~"
#~ msgstr "~: sólo en las macros se permite utilizar un punto en la lista lambda, no aquí: ~"

#~ msgid "~: ~ is a special operator, not a function"
#~ msgstr "~: ~ es una forma especial, no una función"

#~ msgid "~: ~ is a macro, not a function"
#~ msgstr "~: ~ es una macro, no una función"

#
# "EVAL/APPLY: no se han pasado suficientes argumentos a ~" - lsg
#
# Hmmm, ... Si me gusta, es más "explicativo". Si, me gusta, si, si
# Lo único que te trastoco es lo de "pasado" por "entregado". Ya sabes,
# un toque de distinción :) - cll
#
#~ msgid "EVAL/APPLY: too few arguments given to ~"
#~ msgstr "EVAL/APPLY: no se han entregado suficientes argumentos a ~"

#
# 'Se han pasado demasiados argumentos a ~" - lsg
#
# Bueno, tu traducción es absolutamente válido. Tal vez, algo más
# informal que la mía, por aquello de "pasado" en vez de
# "entregado". Bueno, pues si te parece, esta vez lo dejo como lo tenía
# yo - cll
#
#~ msgid "EVAL/APPLY: too many arguments given to ~"
#~ msgstr "EVAL/APPLY: se han entregado demasiados argumentos a ~"

# "EVAL: no se han pasado suficientes argumentos a la forma especial ~:~" - lsg
#
# Bueno, pues te digo lo mismo que en el mensaje eval.d:2572, ... - cll
#
#~ msgid "EVAL: too few parameters for special operator ~: ~"
#~ msgstr "EVAL: no se han entregado suficientes argumentos a la forma especial ~: ~"

#
# "Se han pasado demasiados parámetros a la forma especial ~: ~" - lsg
#
# O sea, que quite lo de "para" y ponga "a". Pues vale, tienes toda la
# razón del mundo - cll
#
#~ msgid "EVAL: too many parameters for special operator ~: ~"
#~ msgstr "EVAL: demasiados parámetros para operador especial ~: ~"

#
#~ msgid "EVAL: dotted parameter list for special operator ~: ~"
#~ msgstr "EVAL: la lista de parámetros para la forma especial ~ está punteada: ~"

#
#
# "EVAL: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Una vez más, te digo lo mismo que en el mensaje eval.d:2572 - cll
#
#~ msgid "EVAL: too few arguments given to ~: ~"
#~ msgstr "EVAL: no se han entregado suficientes argumentos a ~: ~"

#
# "Se han pasado demasiados argumentos a ~: ~" - lsg
#
# Me gusta más "entregado" que "pasado" - cll
#
#~ msgid "EVAL: too many arguments given to ~: ~"
#~ msgstr "EVAL: se han entregado demasiados argumentos a ~: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#~ msgid "EVAL: argument list given to ~ is dotted: ~"
#~ msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#, fuzzy
#~ msgid "~: argument list given to ~ is dotted (terminated by ~)"
#~ msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#
# "Se han pasado demasiados argumentos a ~" - lsg
#
# Una vez más, me gusta más "entregar" que "pasar" - cll
#
#~ msgid "APPLY: too many arguments given to ~"
#~ msgstr "APPLY: se han entregado demasiados argumentos a ~"

#
# "APPLY: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Pues eso, que me gusta más "entregar" - cll
#
#~ msgid "APPLY: too few arguments given to ~"
#~ msgstr "APPLY: se han entregado pocos argumentos a ~"

#
# "el símbolo ~ no tiene valor asignado" - lsg
#
# En algún otro sitio ha aparecido algo parecido a esto. Verás, como me
# parece evidente que si un símbolo no tiene valor, es que no tiene
# valor asignado, pues prefiero omitir lo de "asignado" y evitar que el
# usuario lea términos innecesarios - cll
#
#, fuzzy
#~ msgid "~: symbol ~ has no value"
#~ msgstr "el símbolo ~ no tiene valor"

#, fuzzy
#~ msgid "~: assignment to constant symbol ~ is impossible"
#~ msgstr "no pueden realizarse asignaciones sobre el símbolo constante ~"

#
# "~: se ha invocado ~ con demasiados argumentos" - lsg
#
# a¡ Traducción brillantísima !!! Te ha quedado perfecto. Lo que yo había puesto:
#
# "~: se han entregado demasiados argumentos a ~"
#
# queda como más "indio". Tu traducción me encanta - cll
#
#~ msgid "~: too many arguments given to ~"
#~ msgstr "~: se ha invocado ~ con demasiados argumentos"

# Duda: tagbody es de muy difícil traducción.
#       Echando un ojo a la traducción en francés me he encontrado con que est
#       tal cual, ... De momento se queda así hasta que otros miembros del
#       equipo decidan cualquier otra cosa, ...
#
# No es que sepa lo que es, pero, si tag es etiqueta, tagbody podría ser
# "el cuerpo de la etiqueta" (¿tiene sentido esto?), con lo cual, una
# posibilidad sería (para simplificar) "el cuerpo de las etiquetas..." sv
#
# Otra de las propuestas a esta cuestión en la lista de correo
# es@li.org, ha sido: "el contenido de las etiquetas ~ ya ha sido
# abandonado". Esta traducción me gusta, ... cll
#
# ( Desafortunadamente, no recuerdo el nombre de la persona que lo
# sugirió, ... cll )
#
# "(~ ~): ya se ha salido del cuerpo de etiquetas ~" - lsg
#
# Debo rendirme a la evidencia, ... La propuesta de Leo, no solo para
# este término sino todos cuanto se refieren a la traducción de `tag' y
# `tagbody' es perfecta y, además, sigue los pasos de la de Santiago, de
# modo que "moción aceptada" :)
#
#~ msgid "(~ ~): the tagbody of the tags ~ has already been left"
#~ msgstr "(~ ~): ya se ha salido del cuerpo de etiquetas ~"

#~ msgid "~: there is no CATCHer for tag ~"
#~ msgstr "~: No hay ningún capturador (CATCH) para la etiqueta de salto ~"

#~ msgid "~: ~ is not a correct index into ~"
#~ msgstr "~: ~ no es un índice correcto en ~"

#~ msgid "undefined bytecode in ~ at byte ~"
#~ msgstr "Código de octeto ~ indefinido en el octeto ~"

#~ msgid "Corrupted STACK in ~ at byte ~"
#~ msgstr "Pila corrupta en ~ en el byte ~"

#~ msgid "~: ~ has no dynamic value"
#~ msgstr "~: ~ no tiene ningún valor dinámico"

#~ msgid "~: odd number of arguments: ~"
#~ msgstr "~: número impar de argumentos: ~"

#~ msgid "dotted list given to ~ : ~"
#~ msgstr "lista punteada entregada a ~: ~"

#~ msgid "~: the special operator definition of ~ must not be removed"
#~ msgstr "~: la definición de operador especial de ~ no debe ser quitado"

#~ msgid "~: doc-strings are not allowed here: ~"
#~ msgstr "~: aquí no se permiten cadenas de documentación: ~"

#~ msgid "~: illegal variable specification ~"
#~ msgstr "~: especificación inválida de variable ~"

#~ msgid "~: too many variables and/or declarations"
#~ msgstr "~: demasiadas variables y/o declaraciones"

#~ msgid "~: ~ is not a function specification"
#~ msgstr "~: ~ no es la especificación de una función"

#~ msgid "~: ~ is not a macro specification"
#~ msgstr "~: ~ no es la especificación de una macro"

#~ msgid "~: macro name ~ should be a symbol"
#~ msgstr "~: el nombre de la macro ~ debería ser un símbolo"

#~ msgid "~: ~ is not a function and macro specification"
#~ msgstr "~: ~ no es la especificación de una función y macro"

#~ msgid "~: function and macro name ~ should be a symbol"
#~ msgstr "~: el nombre de la función y macro ~ debería ser un símbolo"

#~ msgid "~: clause ~ should be a list"
#~ msgstr "~: la cláusula ~ debería ser una lista"

#~ msgid "~: missing key list: ~"
#~ msgstr "~: falta la lista de claves: ~"

#~ msgid "~: the block named ~ has already been left"
#~ msgstr "~: el bloque nombrado ~ ya ha sido abandonado"

#~ msgid "~: no block named ~ is currently visible"
#~ msgstr "~: ningún bloque nombrado ~ es visible actualmente"

#~ msgid "~: ~ is neither tag nor form"
#~ msgstr "~: ~ no es ni una etiqueta ni un formulario"

#~ msgid "~: illegal tag ~"
#~ msgstr "~: etiqueta de salto inválida ~"

#~ msgid "~: tagbody for tag ~ has already been left"
#~ msgstr "~: ya se ha salido del cuerpo de etiquetas de ~"

#~ msgid "~: no tag named ~ is currently visible"
#~ msgstr "~: no hay ninguna etiqueta de salto visible con el nombre ~"

#~ msgid "~: too many values"
#~ msgstr "~: demasiados valores"

#~ msgid "~: too many arguments to ~"
#~ msgstr "~: se han entregado demasiados argumentos a ~"

#~ msgid "Argument ~ is not a macroexpansion environment"
#~ msgstr "El argumento ~ no es un entorno para la expansión de macros"

#~ msgid "declarations ~ are not allowed here"
#~ msgstr "las declaraciones ~ no están permitidas aquí"

#~ msgid "~: ~ evaluated to the values ~, not of type ~"
#~ msgstr "~: La forma ~ ha producido los valores ~, ninguno de los cuales es del tipo ~"

#~ msgid "~: bad declaration ~"
#~ msgstr "~: declaración equivocada ~"

#~ msgid "no doc-strings allowed here: ~"
#~ msgstr "no se permite la utilización de cadenas de documentación aquí: ~"

#~ msgid "keyword argument list ~ has an odd length"
#~ msgstr "lista de argumentos clave ~ tiene longitud impar"

#~ msgid ""
#~ "Illegal keyword/value pair ~, ~ in argument list.\n"
#~ "The allowed keywords are ~"
#~ msgstr ""
#~ "Par de argumentos clave/valor ~, ~ dentro de lista de argumentos.\n"
#~ "Las claves permitidas son ~permitidos son ~"

#~ msgid "~: illegal ~ argument ~"
#~ msgstr "~: argumento ~ ilegal ~"

#~ msgid "~: ~ is not a 1:1 encoding"
#~ msgstr "~: ~ no es una codificación 1:1"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#
#~ msgid "~: host should be NIL or a string, not ~"
#~ msgstr "~: el anfitrión debe ser, o bien NIL, o una cadena, pero no ~"

#
# Duda: he traducido hostname por "nombre del `host'". ¿Qué os parece?
#
#~ msgid "~: illegal hostname ~"
#~ msgstr "~: nombre de anfitrión inválido ~"

#~ msgid "~: host should be NIL, not ~"
#~ msgstr "~: el anfitrión debería ser NIL, no ~"

#~ msgid "~: argument ~ should be a pathname designator ~"
#~ msgstr "~: el argumento ~ debería ser un nombre de designador de ruta"

#~ msgid "~: filename for ~ is unknown"
#~ msgstr "~: el nombre de fichero de ~ es desconocido"

#~ msgid "~: there is no user named ~"
#~ msgstr "~: no hay ningún usuario con el nombre ~"

#~ msgid "~: there is no environment variable ~"
#~ msgstr "~: no hay ninguna variable de entorno ~"

#~ msgid "~: syntax error in filename ~ at position ~"
#~ msgstr "~: error de sintáxis en el nombre del fichero ~, en la posición ~"

#~ msgid "~: hosts ~ and ~ of ~ should coincide"
#~ msgstr "~: los anfitriones ~ y ~ de ~ deben coincidir"

#~ msgid "~: argument ~ is not a logical pathname, string, stream or symbol"
#~ msgstr "~: el argumento ~ no es un PATHNAME \"lógica\", una cadena de caracteres, un flujo o un símbolo"

#~ msgid "~: endless loop while resolving ~"
#~ msgstr "~: bucle infinito para ~"

#~ msgid "~: unknown logical host ~ in ~"
#~ msgstr "~: anfitrión ~ desconocido en ~"

#~ msgid "~: No replacement rule for ~ is known."
#~ msgstr "~: No se conoce ninguna regla de sustitución para ~."

#~ msgid "~: :VERSION-argument should be NIL or a positive fixnum or :WILD or :NEWEST, not ~"
#~ msgstr "~: el argumento :VERSION debe ser NIL, un número positivo del tipo fixnum, :WILD o :NEWEST pero no ~"

#~ msgid "~: :VERSION-argument should be NIL or :WILD or :NEWEST, not ~"
#~ msgstr "~: el argumento :VERSION debe ser o bien NIL, o :WILD o :NEWEST, pero no ~"

# Duda: Wildcard por comodín, ..., está bien, ¿no?
#
#~ msgid "wildcards are not allowed here: ~"
#~ msgstr "aquí no están permitidos los comodines: ~"

#~ msgid "~: argument ~ should be ~, ~, ~, ~, ~, ~ or ~"
#~ msgstr "~: el argumento ~ debería ser ~, ~, ~, ~, ~, ~ o ~"

#~ msgid "~: replacement pieces ~ do not fit into ~"
#~ msgstr "~: las piezas de intercambio ~ no caben en ~"

#~ msgid "~: ~ is not a specialization of ~"
#~ msgstr "~: ~ no es una especialización de ~"

#~ msgid "(~ ~ ~ ~) is ambiguous: ~"
#~ msgstr "(~ ~ ~ ~) es ambiguo: ~"

#~ msgid "nonexistent directory: ~"
#~ msgstr "directorio inexistente: ~"

#~ msgid "no directory ~ above ~"
#~ msgstr "no existe el directorio ~ bajo ~"

#~ msgid "\"..\\\\\" after \"...\\\\\" is invalid: ~"
#~ msgstr "\"..\\\\\" después de \"...\\\\\" es inválido: ~"

# Casi lo mismo. Bueno, al menos aquí hay dos puntos. sv
#
# Tienes razón. Ahora que veo este mensaje me lío a poner dos puntos en
# los mensajes anteriores. cll
#
#~ msgid "UNIX error while GETWD: ~"
#~ msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Si la tildecilla se sustituye por aquello que devolvió la orden GETWD,
# la frase resultante no tiene mucho sentido.
# Sugerencia: "La ejecución de GETWD en Unix devolvió ~" sv
#
# Hmmm, ..., podría ser, pero verás: en primer lugar, el texto que est
# asociado con la etiqueta "UNIX GETWD returned ~" es "UNIX error while
# GETWD" (fichero pathname.d, línea 6176); segundo, en CLisp se sigue la
# convención de colocar primero un mensaje y después, al final, aquello
# que originó el mensaje y, francamente, no quiero cambiar esta
# convención. Es decir, no quiero faltar al estilo original de los
# autores del programa. cll
#
# Por este motivo, creo que lo más conveniente es dejarlo como está. cll
#
#~ msgid "UNIX GETWD returned ~"
#~ msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

#~ msgid "UNIX REALPATH returned ~"
#~ msgstr "Se produjo un error UNIX durante la ejecución de REALPATH: ~"

#~ msgid "~: ~ names a directory, not a file"
#~ msgstr "~: ~ es el nombre de un directorio, no de un fichero"

#~ msgid "no file name given: ~"
#~ msgstr "no se ha entregado ningún nombre de fichero: ~"

#~ msgid "not a directory: ~"
#~ msgstr "no es un directorio: ~"

#~ msgid "~: pathname with type but without name makes no sense: ~"
#~ msgstr "~: un PATHNAME con tipo, pero sin nombre, no tiene ningún sentido: ~"

#~ msgid "cannot delete file ~ since there is file stream open to it"
#~ msgstr "no se puede borrar el fichero ~ puesto que hay un flujo abierto sobre el"

#~ msgid "cannot rename file ~ since there is file stream open to it"
#~ msgstr "no se puede renombrar el fichero ~ puesto que hay un flujo abierto sobre el"

#~ msgid "root directory not allowed here: ~"
#~ msgstr "el directorio raíz no está permitido aquí: ~"

# Duda: En este mensaje, el primer "~" se sustituye por el nombre de una
# función y el segundo "~" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#~ msgid "~ on ~ is illegal"
#~ msgstr "~ no es posible sobre el flujo ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#~ msgid "Return value ~ of call to ~ should be an integer between ~ and ~."
#~ msgstr "Devuelve valor ~ de llamada a ~ debería ser un entero entre ~ y ~."

#~ msgid "~: the last character read from ~ was not ~"
#~ msgstr "~: el último carácter leído de ~ no era ~"

# Duda: A continuación vienen muchos mensajes que empiezan por "~ from
# ~". Para ayudar en su trabajo a quienes estén revisando este trabajo
# (no me canso de darte las gracias, Santiago, ..., y a quienes se
# animen) aclaro que el primer "~" se sustituye por el nombre de una
# función cuya evaluación (o ejecución, pero esto no es correcto en
# Lisp, ... se prefiere el término evaluación porque se está a nivel de
# intérprete) produce el error; el segundo "~" se refiere al nombre del
# flujo desde el cual se leyó dicha función. Luego, a continuación,
# viene el mensaje de error propiamente dicho.
#
# Por ejemplo, la siguiente instrucción en CLisp:
#
# > (read)
#
# ..., si se teclea:
#
# #<...>
#
# ..., produce el siguiente error: (en español, ya traducido)
#
# *** - READ en #<TERMINAL-STREAM>: los objetos escritos de la manera
# #<...> no pueden volverse a leer
#
# ¿De acuerdo?
#
# A continuación reproduzco un par de mails donde se explica el
# mecanismo general de estos mensajes, a propósito de la pregunta que
# puse en la lista de correo de CLisp:
#
# Mi pregunta fue:
#
# > 21. There are a few messages which begin with "~ from ~". They are
# > very easy to translate but they use a lot of prepositions, and words
# > that could be translated in masculine or feminine. So, I need some
# > real examples of their use.
#
# Las respuestas fueron:
#
#
# ---------------------------------------------------------------------------
# Look in io.d:
#     { pushSTACK(*stream_); # Wert fu:r Slot STREAM von STREAM-ERROR
#       pushSTACK(ch); # Character
#       pushSTACK(*stream_); # Stream
#       pushSTACK(S(read));
#       //: DEUTSCH "~ von ~: Gelesenes Zeichen ist kein String-Char: ~"
#       //: ENGLISH "~ from ~: character read should be a string-char: ~"
#       //: FRANCAIS "~ de ~ : le caracte!re lu n'est pas de type STRING-CHAR."
# The first ~ is the function name, the second the stream that was being
# read from or written to and the third is the character that was read/written.
#
# So it says something like "READ from #<STREAM ...>: illegal character"
#
# 						(Joerg Hoehle)
#
# ---------------------------------------------------------------------------
# A general question here: I thought gettext was coming with an Emacs
# mode called "po-mode", which helps you in translating the messages.
# In particular, there are keystroke commands for showing the C/Lisp source
# surrounding the original reference to a message. From this context,
# you should at least be able to guess the meaning of the objects which
# are substituted for the ~. Note, however, that the first ~ corresponds
# the last pushSTACK command before the string, the second ~ to the
# second-to-last pushSTACK command etc.
#
# 						(Bruno Haible)
#
# ---------------------------------------------------------------------------
#
#~ msgid "~ from ~ without ~ before it"
#~ msgstr "~ en ~ sin ~ antes de él"

#~ msgid "~: cannot output to ~"
#~ msgstr "~: no se puede escribir en ~"

#~ msgid "~: cannot output ~ into ~, not of type ~"
#~ msgstr "~: no se puede escribir ~ en ~,  no de tipo ~"

#~ msgid "integer ~ is out of range, cannot be output onto ~"
#~ msgstr "el entero ~ está fuera del dominio, no puede imprimirse en ~"

#~ msgid "~: argument ~ should be an input stream"
#~ msgstr "~: el argumento ~ debería ser un flujo entrante"

#~ msgid "~: argument ~ should be an output stream"
#~ msgstr "~: el argumento ~ debería ser un flujo saliente"

#~ msgid "~: argument should be a symbol, not ~"
#~ msgstr "~: el argumento debería ser un símbolo, no ~"

#~ msgid "~ is beyond the end because the string ~ has been adjusted"
#~ msgstr "~ está más allá del final porque la cadena ~ ha sido ajustada"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#~ msgid "~: ~ is not a string input stream"
#~ msgstr "~: ~ no es un flujo de entrada con buffer"

#~ msgid "~: ~ argument must be a subtype of ~, not ~"
#~ msgstr "~: el argumento ~ debe ser un subtipo de ~, no ~"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#~ msgid "~: ~ is not a string output stream"
#~ msgstr "~: ~ no es un flujo de salida con buffer"

# Duda: He traducido `fill pointer' por "puntero de relleno". En
# realidad, los `fill-pointer' son exactamente, eso:
#
# "The fill pointer constitutes the "active length" of the vector; all
# vector elements whose index is less than the fill pointer are active,
# and the others are inactive." (Guy L. Steele, Jr; Common Lisp, The
# Language - 2nd Edition; pag. 454).
#
#~ msgid "~: argument ~ should be a string with fill pointer"
#~ msgstr "~: el argumento ~ debería ser una cadena con un puntero de relleno"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#~ msgid "~: ~ is not a buffered input stream"
#~ msgstr "~: ~ no es un flujo de entrada con buffer"

#~ msgid "~: stream must be a generic-stream, not ~"
#~ msgstr "~: el flujo debe ser un `generic-stream', no ~"

#~ msgid "~: Ctrl-C: User break"
#~ msgstr "~: Ctrl-C: Interrupción del usuario"

#~ msgid "unknown character set ~"
#~ msgstr "conjunto de carácter desconocido ~"

#~ msgid "Closed ~ because disk is full."
#~ msgstr "Se ha cerrado ~ porque el disco está lleno."

#~ msgid "cannot position ~ beyond EOF"
#~ msgstr "no es posible colocarse en ~ más allá de EOF"

# Duda: lo del fichero `regular' por `normal'. De hecho, yo juraría que
# en la asignatura de Sistemas Operativos, en mi Facultad, los
# llamábamos "ficheros normales". ¿Qué tal os suena?.
#
#~ msgid "~: argument ~ ~ was specified, but ~ is not a regular file."
#~ msgstr "~: argumento ~ ~ fue especificado, pero ~ no es un fichero normal."

# Duda: aqui he traducido de la version francesa (no se frances, pero
# por lo que parece que pone, ...)
#
#~ msgid "file ~ is not an integer file"
#~ msgstr "el fichero ~ no es un fichero de enteros"

#~ msgid "Return value ~ of call to ~ is not a list."
#~ msgstr "Valor ~ devuelto de llamada a ~ no es una lista."

#~ msgid "Return value ~ of call to ~ contains ~ which is not a ~."
#~ msgstr "Valor devuelto ~ de llamada a ~ contiene ~ la cual no es un ~."

#~ msgid "~: argument ~ should be a window stream"
#~ msgstr "~: el argumento ~ debería ser un flujo por ventana"

#~ msgid "terminal type ~ unknown to termcap"
#~ msgstr "tipo de terminal ~ desconocido para termcap"

#~ msgid "~: package SCREEN is not implemented"
#~ msgstr "~: el paquete SCREEN no está implementado"

# Duda: he dejado `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es a¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#~ msgid "host should be string, not ~"
#~ msgstr "el anfitrión debe ser una cadena de caracteres y no ~"

# Duda: Pues otra vez como siempre, ..., he dejado `display' tal
# cual. Pienso que todo el mundo sabe lo que es un `display' ¿no?
#
# Por otra parte (como ya sucedió en un mensaje anterior), ..., `fixnum'
# por ser el nombre de un subtipo (o tipo, si se quiere) en Lisp, est
# sin traducir, ...
#
#~ msgid "display should be a nonnegative fixnum, not ~"
#~ msgstr "el `display' debe ser un entero del tipo FIXNUM >=0, y no ~"

#~ msgid "~: stream must be a socket-stream, not ~"
#~ msgstr "~: el flujo debe ser un `socket-stream' y no ~"

#~ msgid "~: argument ~ should be a vector of type (ARRAY (UNSIGNED-BYTE 8) (*))"
#~ msgstr "~: el argumento ~ debe ser un vector del tipo (ARRAY (UNSIGNED-BYTE 8) (*)) "

#~ msgid "~: input stream ~ has reached its end"
#~ msgstr "~: el flujo de entrada ~ ha alcanzado su final"

#~ msgid "~: ~ is not a ~"
#~ msgstr "~: ~ no es un ~"

#~ msgid "~: argument ~ is neither an open SOCKET-STREAM nor a positive FIXNUM"
#~ msgstr "~: el argumento ~ no es ni un SOCKET-STREAM abierto ni un FIXNUM positivo"

#~ msgid "~: argument ~ is not an open SOCKET-STREAM"
#~ msgstr "~: el argumento ~ no es un SOCKET-STREAM abierto"

#~ msgid "~: argument ~ is not a SOCKET-STREAM"
#~ msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#~ msgid "~: argument ~ is not an open stream"
#~ msgstr "~: el argumento ~ no es el flujo abierto"

#~ msgid "~: list ~ is too long (~ maximum)"
#~ msgstr "~: la lista ~ es demasiado larga(~ máximo)"

#~ msgid "~: argument ~ should be of type ~."
#~ msgstr "~: argumento ~ debería ser de tipo ~."

#~ msgid "Invalid direction ~ for accessing ~"
#~ msgstr "Dirección ~ no válida para acceder al ~"

#~ msgid "~: ~ should be a handle, handle stream, or one of ~, ~, ~"
#~ msgstr "~: ~ debería ser un manipulador, flujo de manipulador, o uno de ~, ~, ~"

#~ msgid "The value of ~ is not a stream: ~"
#~ msgstr "El valor de ~ no es un flujo: ~"

#~ msgid "The value of ~ is not an appropriate stream: ~"
#~ msgstr "El valor de ~ no es un flujo apropiado: ~"

#~ msgid "The value of ~ was not an appropriate stream: ~. It has been changed to ~."
#~ msgstr "El valor de ~ no era un flujo apropiado: ~. Ha sido modificado a ~."

#~ msgid "~: The ~ of ~ cannot be changed from ~ to ~."
#~ msgstr "~: El ~ de ~ no puede ser cambiado desde ~ a ~."

#~ msgid "Return value ~ of call to ~ is not a string."
#~ msgstr "Valor devuelto ~ de llamada a ~ no es un flujo."

#~ msgid "~: illegal endianness argument ~"
#~ msgstr "~: límite endian de argumento ~ es ilegal"

#~ msgid "~: argument ~ does not contain a valid OS stream handle"
#~ msgstr "~: argumento ~ no es el manipulador de flujo SO válido"

#~ msgid "~: ~: stream of wrong direction"
#~ msgstr "~: ~: flujo de dirección equivocada"

#~ msgid "~ is not a ~, cannot be output onto ~"
#~ msgstr "~ no es un ~, no puede ser salida en ~"

#~ msgid "~: argument ~ is not an open file stream"
#~ msgstr "~: el argumento ~ no es un flujo de un fichero abierto"

#~ msgid "~: position argument should be ~ or ~ or a nonnegative integer, not ~"
#~ msgstr "~: el argumento de posición debería ser ~ o ~ o un número natural, no ~"

#~ msgid "The value of ~ was not a readtable. It has been reset."
#~ msgstr "El valor de ~ no era una tabla de lectura. Ha sido reinicializado."

#~ msgid "~: argument ~ is not a ~"
#~ msgstr "~: argumento ~ no es un ~"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
# Al final, por iniciativa de Leo, he cambiado `# macro carácter', que
# no me gustaba demasiado por `macro carácter secundario', que me parece
# mucho mejor. - cll
#
#~ msgid "~: ~ is a dispatch macro character"
#~ msgstr "~: ~ es un macro carácter secundario"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#~ msgid "~: ~ is not a dispatch macro character"
#~ msgstr "~: ~ no es un macro carácter secundario"

#~ msgid "~: digit $ not allowed as sub-char"
#~ msgstr "~: el dígito $ no está permitido como un sub-carácter"

#~ msgid "~: new value ~ should be ~, ~, ~ or ~."
#~ msgstr "~: el nuevo valor ~ debe ser ~, ~, ~ o ~."

#~ msgid ""
#~ "The value of ~ should be an integer between 2 and 36, not ~.\n"
#~ "It has been reset to 10."
#~ msgstr ""
#~ "El valor de ~ debe ser un entero entre 2 y 36, no ~.\n"
#~ "Ha sido inicializado a 10."

#~ msgid "~: input stream ~ ends within an object. Last opening parenthesis probably in line ~."
#~ msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto. El último paréntesis abierto es, probablemente, el de la línea ~."

#~ msgid "~: input stream ~ ends within an object"
#~ msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto"

#~ msgid "~ from ~: illegal character ~"
#~ msgstr "~ en ~: carácter inválido ~"

#
# Duda: Lo mismo de antes, he dejado `token' sin traducir
#
#~ msgid "~: input stream ~ ends within a token after single escape character"
#~ msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape simple"

#
# Duda: A ver, ¿la palabra `token'?
#       Mientras no se os ocurra algo mejor, lo he dejado en inglés, ...
#
#~ msgid "~: input stream ~ ends within a token after multiple escape character"
#~ msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape múltiple"

#~ msgid "~ from ~: ~ has no macro character definition"
#~ msgstr "~ en ~: ~ no tiene ninguna definición de macro carácter"

#~ msgid "~ from ~: macro character definition for ~ may not return ~ values, only one value."
#~ msgstr "~ en ~: la definición del macro carácter para ~ no puede devolver ~ valores, sólo puede ser uno."

#~ msgid "~ from ~: dispatch macro character definition for ~ after ~ may not return ~ values, only one value."
#~ msgstr "~ en ~: la definición del macro carácter secundario de ~ después de ~ sólo puede devolver un valor, no ~"

# Duda: He traducido `token' tal cual, ... Santiago, imagino que la
# palabra token se queda tal cual. Quiero decir, ¿es necesario lo de las
# comillas? - cll
#
#~ msgid "~ from ~: a token consisting only of dots cannot be meaningfully read in"
#~ msgstr "~ en ~: no puede leerse correctamente un `token' que consiste únicamente en puntos"

# Duda: Todo el mundo sabe que `colon' es el signo de dos puntos
# `:'. Bueno, pues la traducción del siguiente mensaje podría ser algo
# del estilo: "demasiados signos de dos puntos en el token ...", sin
# embargo, me ha parecido mejor poner los dos puntos directamente, ...
#
#~ msgid "~ from ~: too many colons in token ~"
#~ msgstr "~ en ~: demasiados `:' en el `token' ~"

#~ msgid "~ from ~: there is no package with name ~"
#~ msgstr "~ en ~: no existe ningún paquete con el nombre ~"

#~ msgid "~ from ~: ~ has no external symbol with name ~"
#~ msgstr "~ en ~: ~ no tiene ningún símbolo externo con el nombre ~"

#~ msgid "~ from ~: token \".\" not allowed here"
#~ msgstr "~ en ~: el `token' \".\" no está permitido aquí"

#~ msgid "~: the value of ~ has been arbitrarily altered"
#~ msgstr "~: el valor de ~ ha sido arbitrariamente alterado"

#~ msgid "~: no entry for ~ from ~ in ~ = ~"
#~ msgstr "~: ninguna entrada para ~ desde ~ en ~ = ~"

#~ msgid "~ from ~: illegal end of dotted list"
#~ msgstr "~ en ~: fin de lista punteada inválido"

#~ msgid "~ from ~: an object cannot start with ~"
#~ msgstr "~ en ~: un objeto no puede comenzar por ~"

#~ msgid "~: input stream ~ ends within a string"
#~ msgstr "~: el flujo de entrada ~ termina con una cadena"

#~ msgid "~ from ~: no number allowed between # and $"
#~ msgstr "~ en ~: no debe haber ningún número entre # y $"

#~ msgid "~: input stream ~ ends within a comment #$ ... $#"
#~ msgstr "~: el flujo de entrada ~ termina dentro un comentario #$ ... $#"

#~ msgid "~ from ~: font number ~ for character is too large, should be = 0"
#~ msgstr "~ en ~: número de tipografía ~ para caracter es demasiado grande, debería ser = 0"

#~ msgid "~ from ~: there is no character with name ~"
#~ msgstr "~ en ~: no hay ningún carácter con el nombre ~"

#~ msgid "~ from ~: token ~ after #$ is not a rational number in base ~"
#~ msgstr "~ en ~: el `token' ~ después de #$ no es un número racional en base ~"

#~ msgid "~ from ~: the number base must be given between # and R"
#~ msgstr "~ en ~: el número de la base debe estar entre # y R"

#~ msgid "~ from ~: The base ~ given between # and R should lie between 2 and 36"
#~ msgstr "~ en ~: La base ~ entre # y R debe estar entre 2 y 36"

#~ msgid "~ from ~: bad syntax for complex number: #C~"
#~ msgstr "~ en ~: sintaxis equivocada del número complejo: #C~"

#~ msgid "~ from ~: token expected after #:"
#~ msgstr "~ en : ~: se esperaba un `token' después de #:"

#~ msgid "~ from ~: token ~ after #: should contain no colon"
#~ msgstr "~ en ~: el `token' ~ después de #: no debe contener dos puntos"

#~ msgid "~ from ~: only zeroes and ones are allowed after #*"
#~ msgstr "~ en ~: sólo se permiten ceros y unos después de #*"

#~ msgid "~ from ~: bit vector is longer than the explicitly given length ~"
#~ msgstr "~ en ~: la longitud del vector de bits es mayor que la longitud explícitamente indicada ~"

#~ msgid "~ from ~: must specify element of bit vector of length ~"
#~ msgstr "~ en ~: debe especificar un elemento para el vector de bits de longitud ~"

#~ msgid "~ from ~: vector is longer than the explicitly given length ~"
#~ msgstr "~ en ~: el vector tiene una longitud mayor que la explícitamente indicada ~"

#~ msgid "~ from ~: must specify element of vector of length ~"
#~ msgstr "~ en ~: debe especificar un elemento para el vector de longitud ~"

#~ msgid "~ from ~: bad syntax for array: #A~"
#~ msgstr "~ en ~: sintaxis equivocada en la unimatriz: #A~"

#~ msgid "~ from ~: ~ = ~ does not allow the evaluation of ~"
#~ msgstr "~ en ~: ~ = ~ no permite la evaluación de ~"

#~ msgid "~ from ~: a number must be given between # and $"
#~ msgstr "~ en ~: debe indicarse un número entre # y $"

#~ msgid "~ from ~: label #~? too large"
#~ msgstr "~ en ~: la etiqueta #~? es demasiado grande"

# Duda: En Common Lisp existe lo que se denominan "Listas de asociación"
# (Common Lisp, The Language, 2nd Edition - Guy L. Steel, página 431) o,
# en inglés, "Association Lists" que abreviadamente se conocen como
# "alist" o "a-list". En realidad, aunque en español, mucha gente dice
# "alistas", esto no me parece correcto y me parece mucho más formal
# decir "listas de asociación".
#
# De hecho, el término "listas de asociación" será facílisimamente
# reconocible por el programador, mientras que "alista" exige estar un
# poquito más experimentado con el Lisp.
#
# Más aún, los traductores del libro "Lisp" (3ra edición) de Winston y
# Horn, utilizan la expresión "lista de asociación" en la presentación
# de la función ASSOC en la página 34, aunque luego también se refieran
# a ellas como "listas-a".
#
#~ msgid "~ from ~: the value of ~ has been altered arbitrarily, it is not an alist: ~"
#~ msgstr "~ en ~: el valor de ~ ha sido modificado arbitrariamente, no es una lista de asociación: ~"

#~ msgid "~ from ~: label #~= may not be defined twice"
#~ msgstr "~ en ~: la etiqueta #~= no puede definirse dos veces"

#~ msgid "~ from ~: #~= #~# is illegal"
#~ msgstr "~ en ~: #~= #~# no está permitido"

#~ msgid "~ from ~: undefined label #~#"
#~ msgstr "~ en ~: la etiqueta #~# no está definida"

#~ msgid "~ from ~: objects printed as #<...> cannot be read back in"
#~ msgstr "~ en ~: los objetos escritos de la manera #<...> no pueden volverse a leer"

#~ msgid "~ from ~: objects printed as # in view of ~ cannot be read back in"
#~ msgstr "~ en ~: los objetos escritos como # a causa de ~ no pueden volverse a leer"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#~ msgid "~ from ~: illegal feature ~"
#~ msgstr "~ en ~: propiedad inválida ~"

#~ msgid "~ from ~: #S must be followed by the type and the contents of the structure, not ~"
#~ msgstr "~ en ~: #S debe estar seguido del tipo y contenidos de la estructura, no ~"

#~ msgid "~ from ~: the type of a structure should be a symbol, not ~"
#~ msgstr "~ en ~: el tipo de una estructura debe ser un símbolo, no ~"

#~ msgid "~ from ~: bad ~"
#~ msgstr "~ en ~: ~ equivocado"

#~ msgid "~ from ~: bad ~ for ~"
#~ msgstr "~ en ~: ~ equivocado en ~"

#~ msgid "~ from ~: structures of type ~ cannot be read in, missing constructor function"
#~ msgstr "~ en ~: las estructuras del tipo ~ no pueden leerse, no se conoce la función de construcción"

#~ msgid "~ from ~: a structure ~ may not contain a component \".\""
#~ msgstr "~ en ~: una estructura ~ no debe contener un componente \".\""

#~ msgid "~ from ~: ~ is not a symbol, not a slot name of structure ~"
#~ msgstr "~ en ~: ~ no es un símbolo, ni el nombre de una ranura ni una estructura ~"

#~ msgid "~ from ~: missing value of slot ~ in structure ~"
#~ msgstr "~ en ~: falta el valor de la ranura ~ en la estructura ~"

#
# Duda: slots se queda tal cual, ...
#
# De acuerdo con la lista spanglish, `slot' se traducirá, en todo el
# CLisp, como "ranura".
#
#~ msgid "~ from ~: too many slots for structure ~"
#~ msgstr "~ en ~: hay demasiadas ranuras en la estructura ~"

#
# "~ en ~: sintaxis inválida del vector de código de recinto tras #~Y" - lsg
#
# Hmmm, no me acaba de gustar, ... - cll
#
#~ msgid "~ from ~: illegal syntax of closure code vector after #~Y"
#~ msgstr "~ en ~: sintaxis inválida del vector de código de la cerradura después de #~Y"

#~ msgid "~ from ~: object #Y~ has not the syntax of a compiled closure"
#~ msgstr "~ en ~: el objeto #Y~ no tiene la sintaxis de una cerradura compilada"

#
# pathname NO es array!
# "~ en ~: sintaxis incorrecta en nombre de path: #A~" - lsg
#
# Si, es verdad, aquí se me había ido la mano, ...
#
# Además, PATHNAME no se traduce puesto que, o bien se refiere al tipo
# de datos PATHNAME o a la función PATHNAME (en este caso, al tipo de
# datos). Como ambos términos están definidos en el estándar de Common
# Lisp: Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr., pues
# no se traduce y se pone en mayúsculas para distinguirlo de otros
# términos. - cll
#
#~ msgid "~ from ~: bad syntax for pathname: #P~"
#~ msgstr "~ en ~: la sintaxis del PATHNAME: #P~ está equivocado"

# Nota: El siguiente mensaje se debe a la función PEEK-CHAR (Common
# Lisp, The Language - 2nd Edition; Guy L. Steele, Jr; pag. 574), que
# realiza la lectura del siguiente objeto de un flujo de caracteres
# según el valor de su primer argumento opcional `peek-type' que solo
# puede valer, como reza el mensaje, NIL, T o un carácter.
#
#~ msgid "~: peek type should be NIL or T or a character, not ~"
#~ msgstr "~: el tipo del PEEK solo puede ser NIL, T o un carácter, y no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#~ msgid "~: ~ argument should be an integer between 2 and 36, not ~"
#~ msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

# "~: la cadena ~ no tiene sintaxis de entero" - lsg
#
# He cambiado lo "de entero" por "de un número entero", que parece más
# inteligible - cll
#
#~ msgid "~: substring ~ does not have integer syntax at position ~"
#~ msgstr "~: subcadena ~ no tiene la sintaxis de un número entero en la posición ~"

#~ msgid "~: Despite ~, ~ cannot be printed readably."
#~ msgstr "~: A pesar de ~, ~ no puede ser impreso de manera legible."

#~ msgid ""
#~ "~: the value ~ of ~ is neither ~ nor ~ nor ~.\n"
#~ "It is reset to ~."
#~ msgstr ""
#~ "~: el valor ~ de ~ no es ~ ni ~ ni ~.\n"
#~ "Ha sido inicializado a ~."

#~ msgid "~: must be a positive integer or NIL, not ~"
#~ msgstr "~: debe ser un número positivo entero o NIL, pero no ~"

# "~: espacio insuficiente en la pila para realizar un análisis de circularidad" - lsg
#
# Vale - cll
#
#~ msgid "~: not enough stack space for carrying out circularity analysis"
#~ msgstr "~: no hay espacio suficiente en la pila para realizar un análisis de circularidad"

#~ msgid "~: bad ~"
#~ msgstr "~: incorrecto ~"

#~ msgid "~: an unknown record type has been generated!"
#~ msgstr "~: se ha generado un tipo de registro desconocido!"

#, fuzzy
#~ msgid "~: argument ~ is too large"
#~ msgstr "~: el argumento ~ no es un string"

#, fuzzy
#~ msgid "~: argument ~ should be ~ or ~."
#~ msgstr "~: el argumento ~ debe ser un flujo"

#, fuzzy
#~ msgid "~: argument ~ should be ~, ~, ~ or ~."
#~ msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

# "~: ~ no es una formación" - lsg
#
# Aunque en la lista de spanglish.txt pone "formación", en este caso
# creo que será mucho más conveniente poner "matriz" porque de hecho,
# los mensajes se refieren a matrices, ... - cll
#
#~ msgid "~: ~ is not an array"
#~ msgstr "~: ~ no es una matriz"

#~ msgid "~: got ~ subscripts, but ~ has rank ~"
#~ msgstr "~: se encontraron ~ subíndices, pero ~ tiene rango ~"

#~ msgid "~: subscripts ~ for ~ are not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
#~ msgstr "~: los subíndices ~ de ~ no son del tipo '(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#~ msgid "~: subscripts ~ for ~ are out of range"
#~ msgstr "~: los subíndices ~ de ~ han excedido el rango"

#~ msgid "~: index ~ for ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
#~ msgstr "~: el índice ~ de ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#~ msgid "~: index ~ for ~ is out of range"
#~ msgstr "~: el índice ~ de ~ ha excedido el rango"

#, fuzzy
#~ msgid "~: cannot store values in an array of element type NIL"
#~ msgstr "~: ~ no puede convertirse al tipo ~"

#, fuzzy
#~ msgid "~: cannot access values of an array of element type NIL"
#~ msgstr "~: ~ no puede convertirse al tipo ~"

#~ msgid "~: ~ does not fit into ~, bad type"
#~ msgstr "~: ~ no cabe en ~, tipo incorrecto"

#, fuzzy
#~ msgid "~: ~ cannot be stored in an array of element type NIL"
#~ msgstr "~: ~ no puede convertirse al tipo ~"

#~ msgid "~: ~ is not an nonnegative integer less than the rank of ~"
#~ msgstr "~: ~ no es un entero no negativo menor que el rango de ~"

#~ msgid "~: ~ is not an array of bits"
#~ msgstr "~: ~ no es una matriz de bits"

#~ msgid "~: The arguments ~ and ~ should be arrays of bits with the same dimensions"
#~ msgstr "~: Los argumentos ~ y ~ deben ser matrices de bits de la misma dimensión"

#~ msgid "~: The arguments ~, ~ and ~ should be arrays of bits with the same dimensions"
#~ msgstr "~: Los argumentos ~, ~ y ~ deben ser matrices de bits de la misma dimensión"

#~ msgid "~: vector ~ has no fill pointer"
#~ msgstr "~: el vector ~ no tiene ningún puntero de relleno"

#~ msgid "~: ~ has length zero"
#~ msgstr "~: ~ tiene longitud nula"

#~ msgid "~: extending the vector by ~ elements makes it too long"
#~ msgstr "~: ampliar el vector en ~ elementos, lo hace muy grande"

#~ msgid "~ works only on adjustable arrays, not on ~"
#~ msgstr "~ funciona sólo con matrices ajustables, no con ~"

#~ msgid "~: extension ~ should be a positive fixnum"
#~ msgstr "~: la extensión ~ debe ser un número positivo del tipo FIXNUM"

#~ msgid "~: cannot push ~ into array ~ (bad type)"
#~ msgstr "~: no se puede introducir ~ en la matriz ~ (tipo incorrecto)"

#~ msgid "~: dimension ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
#~ msgstr "~: la dimensión ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#~ msgid "~: dimensions ~ produce too large total-size"
#~ msgstr "~: las dimensiones ~ producen un tamaño total demasiado grande"

#~ msgid "~: ambiguous, more than one initialization specified"
#~ msgstr "~: ambiguo, se ha especificado más de una inicialización"

#~ msgid "~: the initial-element ~ is not of type ~"
#~ msgstr "~: el INITIAL-ELEMENT ~ no es del tipo ~"

#~ msgid "~: ~ is of incorrect length"
#~ msgstr "~: ~ no tiene la longitud correcta"

#~ msgid "~: ~-argument ~ is not an array"
#~ msgstr "~: El ~ argumento ~ no es una matriz"

#~ msgid "~: ~-argument ~ does not have element type ~"
#~ msgstr "~: El ~ argumento ~ no tiene como tipo de elemento ~"

#~ msgid "~: ~-argument ~ is not of type `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"
#~ msgstr "~: El ~ argumento ~ no es del tipo `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"

#~ msgid "~: array-total-size + displaced-offset (= ~) exceeds total size ~ of ~-argument"
#~ msgstr "~: array-total-size + displaced-offset (= ~) excede el tamaño total ~ del ~ argumento"

#~ msgid "~: fill-pointer ~ should be a nonnegative fixnum"
#~ msgstr "~: El puntero de relleno ~ debe ser un número no negativo del tipo FIXNUM"

#~ msgid "~: fill-pointer argument ~ is larger than the length ~"
#~ msgstr "~: El argumento FILL-POINTER ~ es mayor que la longitud ~"

#
# "~: el rango intentado ~ es demasiado grande" - lsg
#
# De acuerdo - cll
#
#~ msgid "~: attempted rank ~ is too large"
#~ msgstr "~: el rango intentado ~ es demasiado grande"

#~ msgid "~: ~ may not be specified for an array of rank ~"
#~ msgstr "~: ~ no debe especificarse para una matriz de rango ~"

#~ msgid "~: rank ~ of array ~ cannot be altered: ~"
#~ msgstr "~: no es posible cambiar el rango ~ de la matriz ~: ~"

#
# "~: los elementos de la formación ~ no son de tipo ~" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#~ msgid "~: array ~ does not have element-type ~"
#~ msgstr "~: los elementos de la matriz ~ no son del tipo ~"

#~ msgid "~: cannot displace array ~ to itself"
#~ msgstr "~: no se puede desplazar la matriz ~ hacia ella misma"

#~ msgid "~: array ~ has no fill-pointer"
#~ msgstr "~: la matriz ~ no tiene ningún puntero de relleno"

#~ msgid "~: the fill-pointer of array ~ is ~, greater than ~"
#~ msgstr "~: el puntero de relleno de la matriz ~ es ~ que es mayor que ~"

# ... de la misma forma que uno no pone "START Índice" sv
#
# Si, si, ..., tienes toda la razón, ... cll
#
#~ msgid "Illegal START index ~ for ~"
#~ msgstr "Índice START ~ inválido en ~"

#~ msgid "Illegal END index ~ for ~"
#~ msgstr "Índice END ~ inválido en ~"

#~ msgid "~: invalid bit-vector length ~"
#~ msgstr "~: la longitud de BIT-VECTOR ~ es inválida"

# Duda: hash lo he traducido por hash. ¿Alguna sugerencia? ¿Tablas de
# acceso rápido, o algo así?. Tened en cuenta que en Common Lisp, las
# tablas hash son una estructura bien definida que cuenta con sus
# propias instrucciones. A mí me gusta tal cual, ...
# Sugerencia: tabla de `hash'. sv
#
# No, no, no, no, ... :) `hash table' es `tabla hash'. Si se quiere,
# podríamos traducir la palabra `hash' pero si se deja es `tabla
# hash'. Todos los informáticos las llamamos así. Jamás he oído `Tabla
# *de* hash' cll
#
#~ msgid "Hash table size ~ too large"
#~ msgstr "La tabla hash ~ es demasiado grande"

#
# "error interno al redimensionar ~" - lsg
#
# Me gusta, salvo que el error ocurre "durante" - cll
#
#~ msgid "internal error occured while resizing ~"
#~ msgstr "error interno durante el redimensionamiento de ~"

#, fuzzy
#~ msgid "~: argument ~ should be ~, ~, ~, ~ or ~."
#~ msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#, fuzzy
#~ msgid "~: ~ argument should be a fixnum >=0, not ~"
#~ msgstr "~ : El argumento debe ser del tipo FIXNUM >=0 y no ~"

#, fuzzy
#~ msgid "~: ~ argument should be an integer or a float > 1, not ~"
#~ msgstr "~: el argumento debe ser un entero, no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#, fuzzy
#~ msgid "~: ~ argument should be a real between 0 and 1, not ~"
#~ msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

#~ msgid "~: internal error while building ~"
#~ msgstr "~: error interno durante la construcción de ~"

#, fuzzy
#~ msgid "~: argument ~ is not a hash table"
#~ msgstr "~: el argumento ~ no es un carácter"

#~ msgid "~: ~ is not a pair"
#~ msgstr "~: ~ no es un par"

#~ msgid "~: lists ~ and ~ are not of same length"
#~ msgstr "~: las listas ~ y ~ no son de la misma longitud"

#~ msgid "~: start index ~ too large for ~"
#~ msgstr "~: el índice :START ~ es demasiado grande para ~"

#~ msgid "~: end index ~ too large for ~"
#~ msgstr "~: el índice :END ~ es demasiado grande para ~"

#~ msgid "symbol ~ cannot be deleted from symbol table"
#~ msgstr "el símbolo ~ no puede ser borrado de la tabla de símbolos"

#~ msgid "~ inconsistent: symbol ~ is a shadowing symbol but not present"
#~ msgstr "inconsistencia en ~: el símbolo ~ es un símbolo que eclipsa a otro/s, sin embargo no está presente."

#, fuzzy
#~ msgid ""
#~ "Uninterning ~ from ~ uncovers a name conflict.\n"
#~ "You may choose the symbol in favour of which to resolve the conflict."
#~ msgstr "Puede elegir ~ desde símbolo en favor del cual se resolverá el conflicto."

#, fuzzy
#~ msgid "Importing ~ into ~ produces a name conflict with ~ and other symbols."
#~ msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S y otros símbolos."

#~ msgid "Importing ~ into ~ produces a name conflict with ~."
#~ msgstr "Importando ~ en ~ produce un conflicto de nombres con ~."

#~ msgid "UNEXPORT in ~ is illegal"
#~ msgstr "UNEXPORT en ~ es inválido"

#
# "UNEXPORT sólo funciona con símbolos accesibles, no con ~ en ~" - lsg
#
# Ya, o sea, que cambie "sobre" por "con". Vale, me gusta mucho más tu
# mensaje que el mío - cll
#
#~ msgid "UNEXPORT works only on accessible symbols, not on ~ in ~"
#~ msgstr "UNEXPORT sólo funciona sobre símbolos accesibles, no con ~ en ~"

#
#~ msgid "~: Symbol ~ should be imported into ~ before being exported."
#~ msgstr "~: símbolo ~ debería ser importado a ~ antes de ser exportado."

#
#
# El segundo from deberia ser 'de', porque quiere decir que un símbolo
# a de un paquete A entra en conflicto con el símbolo b _del_ paquete
# B. Luego, debe ser 'de'.
#
#~ msgid ""
#~ "Exporting ~ from ~ produces a name conflict with ~ from ~.\n"
#~ "You may choose which symbol should be accessible in ~."
#~ msgstr "la exportación de ~S desde ~S produce un conflicto de nombres con ~S de ~S."

#~ msgid ""
#~ "(~ ~ ~): ~ name conflicts remain\n"
#~ "Which symbol with name ~ should be accessible in ~?"
#~ msgstr "¿Cual símbolo con nombre ~ debería ser accesible en ~?"

#~ msgid "The value of *PACKAGE* was not a package. Old value ~. New value ~."
#~ msgstr "El valor de *PACKAGE* no era un paquete. Valor anterior ~. Nuevo valor ~."

#~ msgid "~: Package ~ has been deleted."
#~ msgstr "~: El paquete ~ ha sido borrado."

#~ msgid "~: argument should be a package or a package name, not ~"
#~ msgstr "~: el argumento debe ser un paquete o el nombre de un paquete, no ~"

#~ msgid "~: there is already a package named ~"
#~ msgstr "~: ya hay un paquete llamado ~"

#
# "~: el argumento debe ser un símbolo o una lista de símbolos, no ~" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#~ msgid "~: argument should be a symbol or a list of symbols, not ~"
#~ msgstr "~: el argumento debería ser un símbolo o una lista de símbolos, no ~"

#~ msgid "~: a package with name ~ already exists."
#~ msgstr "~: un paquete con el nombre ~ ya existe."

#~ msgid "Cannot change the case sensitiveness of ~."
#~ msgstr "No es posible cambiar las MAYUS/minús de ~."

#~ msgid "~: ~ is not using ~"
#~ msgstr "~: ~ no está empleando ~"

#~ msgid "~: ~ is not a valid index into ~"
#~ msgstr "~: ~ no es un índice válido en ~"

#~ msgid "~: ~ is not a record"
#~ msgstr "~: ~ no es un registro"

#~ msgid "~: length ~ should be of type ~"
#~ msgstr "~: longitud ~ debería ser de tipo ~"

#~ msgid "~: ~ is not a structure of type ~"
#~ msgstr "~: ~ no es una estructura del tipo ~"

#~ msgid "~: Slot ~ of ~ has no value"
#~ msgstr "~: ranura ~ de ~ no tiene valor"

#~ msgid "~: This is not a compiled closure: ~"
#~ msgstr "~: No se trata de una cerradura compilada: ~"

#~ msgid "~ is not a valid code-vector byte"
#~ msgstr "~ no es un byte CODE-VECTOR válido"

#~ msgid "~: invalid side-effect class ~ for function ~"
#~ msgstr "~: efecto lateral de clase inválido ~ para función ~"

#~ msgid "~: invalid code-vector ~"
#~ msgstr "~: CODE-VECTOR inválido ~"

#~ msgid "~: function ~ is too big: ~"
#~ msgstr "~: la función ~ es demasiado grande: ~"

#~ msgid "~: This is not a prototype of a generic function: ~"
#~ msgstr "~: Ésta no es un prototipo de una función genérica: ~"

#~ msgid "There are no sequences of type ~"
#~ msgstr "No hay secuencias del tipo ~"

#~ msgid "~: ~ should be an integer >=0, not ~"
#~ msgstr "~: ~ debe ser un entero >=0, no ~"

#~ msgid "~: ~ = ~ should not be greater than ~ = ~"
#~ msgstr "~: ~ = ~ no debe ser mayor que ~ = ~"

#~ msgid "~: the index should be a fixnum >=0, not ~"
#~ msgstr "~: el índice debe ser un número >=0 del tipo FIXNUM, no ~"

#~ msgid "~: bad length ~"
#~ msgstr "~: longitud incorrecta ~"

#~ msgid "~: size should be an integer >=0, not ~"
#~ msgstr "~: el tamaño debe ser un entero >=0, no ~"

#~ msgid "~: :update must not be specified without :initial-element"
#~ msgstr "~: no debe especificarse :update sin :initial-element"

#~ msgid "~: Must not specify both arguments to :TEST and :TEST-NOT"
#~ msgstr "~: Los argumentos :TEST y :TEST-NOT no deben tener valor simultáneamente"

#~ msgid "~: sequence ~ is too long"
#~ msgstr "~: la secuencia ~ es demasiado larga"

#~ msgid "too long sequence ~"
#~ msgstr "secuencia demasiado larga ~"

#~ msgid "~: the radix must be an integer between 2 and 36, not ~"
#~ msgstr "~: la base debe ser un entero entre 2 y 36, no ~"

#~ msgid "~: the code argument should be an integer, not ~"
#~ msgstr "~: el argumento del código debe ser un entero y no ~"

# "~: no se puede convertir ~ al tipo character"
#
# No sé si traducir la palabra character, puesto que es una palabra
# clave en Lisp. - lsg
#
# Yo ya había traducido este mensaje como:
#
# "~: ~ no puede convertirse a un carácter"
#
# Pero el tuyo me gusta mucho más, salvo que `character', puesto que es
# un término definido en el estándar Common Lisp, debe ir en mayúsculas
# - cll
#
#~ msgid "~: cannot coerce ~ to a character"
#~ msgstr "~: no se puede convertir ~ al tipo CHARACTER"

#~ msgid "~: the weight argument should be an integer, not ~"
#~ msgstr "~: el argumento de ponderación debe ser un entero, y no ~"

#~ msgid "~: argument should be an integer, not ~"
#~ msgstr "~: el argumento debe ser un entero, no ~"

#~ msgid "~: ~-index should be an integer, not ~"
#~ msgstr "~: el índice ~ debe ser un entero, no ~"

#~ msgid "~: index should be NIL or an integer, not ~"
#~ msgstr "~: el índice debe ser NIL o un entero, no ~"

#~ msgid "~: ~-index should be NIL or an integer, not ~"
#~ msgstr "~: el índice ~ debe ser NIL o un entero, no ~"

#~ msgid "~: index should not be negative: ~"
#~ msgstr "~: el índice no debe ser negativo: ~"

#~ msgid "~: ~-index should not be negative: ~"
#~ msgstr "~: el índice ~ no debe ser negativo: ~"

#~ msgid "~: index ~ should not be greater than the length of the string"
#~ msgstr "~: el índice ~ no debe ser mayor que la longitud de la cadena"

#~ msgid "~: ~-index ~ should not be greater than the length of the string"
#~ msgstr "~: el índice ~ = ~ no debe ser mayor que la longitud de la cadena"

#~ msgid "~: index ~ should be less than the length of the string"
#~ msgstr "~: el índice ~ debe ser menor que la longitud de la cadena"

#~ msgid "~: ~-index ~ should be less than the length of the string"
#~ msgstr "~: el índice ~ = ~ debe ser menor que la longitud de la cadena"

#~ msgid "~: :START-index ~ must not be greater than :END-index ~"
#~ msgstr "~: El índice :START ~ no debe ser mayor que el índice :END ~"

#~ msgid "~: argument ~ should be a string, a symbol or a character"
#~ msgstr "~: el argumento ~ debería ser una cadena, un símbolo o un caracter"

#~ msgid "~: :start-index ~ must not be greater than :end-index ~"
#~ msgstr "~: El índice :start ~ no debe ser mayor que el índice :end ~"

#~ msgid "~: :start1-index ~ must not be greater than :end1-index ~"
#~ msgstr "~: El índice start1 ~ no debe ser mayor que el índice :end1 ~"

#~ msgid "~: :start2-index ~ must not be greater than :end2-index ~"
#~ msgstr "~: El índice :start2 ~ no debe ser mayor que el índice :end2 ~"

#~ msgid "~: the string length ~ should be nonnegative fixnum"
#~ msgstr ""
#~ "~: la longitud de la cadena de caracteres ~ debe ser un número no negativo\n"
#~ "del tipo FIXNUM"

#~ msgid "~: ~ argument ~ should be of type ~"
#~ msgstr "~: el argumento ~ ~ debería ser de tipo ~"

#
# Duda: esta traducción ha sido muy difícil, y está basada en la
# traducción francesa que dice: "~: Mauvais mode de saut d'environnement
# ~."
#
#~ msgid "~: bad frame climbing mode ~"
#~ msgstr "~: modo de salto de marco equivocado"

#~ msgid "~: ~ is not a stack pointer"
#~ msgstr "~: ~ no es un puntero de pila"

#~ msgid "~: ~ is not a pointer to an EVAL/APPLY frame"
#~ msgstr "~: ~ no es un puntero a un marco de tipo EVAL/APPLY"

#~ msgid "~: environment is not an alist"
#~ msgstr "~: el entorno no es una a-lista"

#~ msgid "~: unknown frame type"
#~ msgstr "~: tipo de marco desconocido"

#~ msgid "~: ~ comes from a previous Lisp session and is invalid"
#~ msgstr "~: ~ proviene de una sesion anterior de Lisp y es inválido"

#~ msgid "~: ~ is not a list"
#~ msgstr "~: ~ no es una lista"

#~ msgid "~: A true list must not end with ~"
#~ msgstr "~: Una auténtica lista no debe finalizar con ~"

# me comería el "y por ello", todo el mundo lo entenderá, y además no
# está en el original. sv
#
# No sólo eso, sino que además el mensaje queda demasiado largo. Ser
# mucho más cómodo, para quien esté trabajando, ver mensajes cortos,
# ... sugerencia aceptada. cll
#
#~ msgid "~: ~ is a constant, may not be used as a variable"
#~ msgstr "~: ~ es una constante, no puede ser empleado como una variable"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#
#~ msgid "~: ~ is not a symbol, cannot be declared ~"
#~ msgstr "~: ~ no es un símbolo, no puede declararse ~"

#~ msgid "~: ~ is not a vector"
#~ msgstr "~: ~ no es un vector"

#~ msgid "~: ~ may not be used as an environment"
#~ msgstr "~: ~ no puede usarse como un entorno"

#~ msgid "~: argument ~ should be a nonnegative fixnum"
#~ msgstr "~: el argumento ~ debe ser un número no negativo del tipo fixnum"

#~ msgid "~: ~ is not an integer"
#~ msgstr "~: ~ no es un entero"

#~ msgid "~: ~ is not a non-negative integer"
#~ msgstr "~: ~ no es el entero no negativo"

#~ msgid "~: argument ~ is not a string"
#~ msgstr "~: el argumento ~ no es una cadena de texto"

#~ msgid "~: argument ~ is neither a string nor an integer"
#~ msgstr "~: el argumento ~ no es ni una cadena de texto ni un entero"

#~ msgid "~: argument ~ is not a stream"
#~ msgstr "~: el argumento ~ no es el flujo "

#~ msgid "~: argument ~ should be a stream of type ~"
#~ msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#~ msgid "~: argument ~ is not a character set"
#~ msgstr "~: el argumento ~ no es un conjunto de carácter"

#~ msgid "~: keyword arguments in ~ should occur pairwise"
#~ msgstr "~: los argumentos clave de ~ deberían ocurrir por pares"

#~ msgid "~: ~ marker ~ is not a symbol"
#~ msgstr "~: ~ marcador ~ no es un símbolo"

#
# Yo pondría un guión entre argumento y clave. - lsg
#
# Hmm, o sea `argumento-clave'. No, no me gusta y de hecho, en el
# "Vocabulario bilingüe de términos técnicos" de "Lisp" (3ra edición) de
# Winston y Horn, los traductores al español ponen en la página 649:
#
# keyword arguments - argumentos clave
#
# sin guión por medio - cll
#
#~ msgid ""
#~ "~: illegal keyword/value pair ~, ~ in argument list.\n"
#~ "The allowed keywords are ~"
#~ msgstr ""
#~ "~: par argumento clave/valor inválido ~, ~ en la lista de argumentos.\n"
#~ "Los parámetros clave permitidos son ~"

#~ msgid "~: ~ is not a function"
#~ msgstr "~: ~ no es el nombre de una función"

#~ msgid "~: ~ is not a function name"
#~ msgstr "~: ~ no es el nombre de una función"

#~ msgid "~: Too many arguments (~ instead of at most ~) given to ~"
#~ msgstr "~: Demasiados argumentos (~ en vez de ~) dado para ~"

#~ msgid "EVAL/APPLY: Too few arguments (~ instead of at least ~) given to ~"
#~ msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#~ msgid "~: Too few arguments (~ instead of at least ~) given to ~"
#~ msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#~ msgid "~: ~ is not an 8-bit number"
#~ msgstr "~: ~ no es un número de 8 bit"

#~ msgid "~: ~ is not a 16-bit number"
#~ msgstr "~: ~ no es un número de 16 bit"

#~ msgid "~: ~ is not an 32-bit number"
#~ msgstr "~: ~ no es un número de 32 bit"

#~ msgid "~: ~ is not an 64-bit number"
#~ msgstr "~: ~ no es un número de 64 bit"

#~ msgid "~: ~ is not an `unsigned int' number"
#~ msgstr "~: ~ no es un número del tipo `unsigned int'"

#~ msgid "~: ~ is not an `int' number"
#~ msgstr "~: ~ no es un número del tipo `int'"

#~ msgid "~: ~ is not a `unsigned long' number"
#~ msgstr "~: ~ no es un número del tipo `unsigned long'"

#~ msgid "~: ~ is not a `long' number"
#~ msgstr "~: ~ no es un número del tipo `long'"

#~ msgid "~: ~ is not a single-float"
#~ msgstr "~: ~ no es un SINGLE-FLOAT"

#~ msgid "~: ~ is not a double-float"
#~ msgstr "~: ~ no es un DOUBLE-FLOAT"

#~ msgid "~: type of attribute ~ is unsupported"
#~ msgstr "~: el tipo de atributo ~ no está soportado"

#~ msgid "~: too large shift amount ~"
#~ msgstr "~: el tamaño del desplazamiento es muy grande ~"

#~ msgid "~: unidentifiable type!!!"
#~ msgstr "~: ¡tipo irreconocible!!!"

#~ msgid "~: type ~ does not correspond to a class"
#~ msgstr "~: el tipo ~ no se corresponde con una clase"

#~ msgid "~: ~ does not name a class"
#~ msgstr "~: ~ no es el nombre de una clase"

#~ msgid "~: ~ cannot be coerced to type ~"
#~ msgstr "~: ~ no puede convertirse al tipo ~"

#~ msgid "~: the property list of ~ has an odd length"
#~ msgstr "~: la lista de propiedades de ~ tiene longitud impar"

#~ msgid "~: the property list ~ has an odd length"
#~ msgstr "~: la lista de propiedades ~ tiene longitud impar"

#~ msgid "~: ~ is not a system function"
#~ msgstr "~: ~ no es una función del sistema"

#~ msgid "~: index ~ is negative"
#~ msgstr "~: el índice ~ es negativo"

#~ msgid "~: invalid argument ~"
#~ msgstr "~: el argumento ~ es inválido"

#~ msgid "The value of *GENSYM-COUNTER* was not a nonnegative integer. Old value ~. New value ~."
#~ msgstr "El valor de *GENSYM-COUNTER* no era un entero no negativo. Valor anterior ~. Valor nuevo ~."

#~ msgid "~: argument should be a positive fixnum, not ~"
#~ msgstr "~: el argumento debería ser un número positivo del tipo FIXNUM, no ~"

#~ msgid "~: ~ is not a number"
#~ msgstr "~: ~ no es un número"

#~ msgid "~: ~ is not a real number"
#~ msgstr "~: ~ no es un número real del tipo `long'"

#~ msgid "~: ~ is not a floating-point number"
#~ msgstr "~: ~ no es un número real de coma flotante"

#~ msgid "~: ~ is not a rational number"
#~ msgstr "~: ~ no es un número racional"

#~ msgid "~: the value of ~ should be a ~, not ~"
#~ msgstr "~: el valor de ~ debería ser un ~, no ~"

#~ msgid "~: argument should be positive and an integer or float, not ~"
#~ msgstr "~: el argumento debe ser un número positivo del tipo ENTERO o REAL, no ~"

#~ msgid "not a 32-bit integer: ~"
#~ msgstr "no es un entero de 32 bit: ~"

#~ msgid "not a 64-bit integer: ~"
#~ msgstr "no es un entero de 64 bit: ~"

#~ msgid "~: ~ is not a valid boolean operation"
#~ msgstr "~: ~ no es una operación lógica válida"

# Duda: En Lisp existe un tipo predeterminado: `fixnum'. Por ese motivo,
# dejo sin traducir este término.
#
#~ msgid "The arguments to BYTE must be fixnums >=0: ~, ~"
#~ msgstr "Los argumentos de BYTE deben ser números enteros del tipo FIXNUM >=0: ~, ~"

#~ msgid "~ is not a BYTE specifier"
#~ msgstr "~ no es un especificador de BYTE"

#~ msgid "quotient ~ / ~ is not an integer"
#~ msgstr "el cociente ~ / ~ no es un entero"

#~ msgid "~: Unsupported call mechanism: ~"
#~ msgstr "~: mecanismo de llamado no soportado: ~"

#~ msgid "~: Bad function prototype: ~"
#~ msgstr "~: Prototipo de función equivocado: ~"

#~ msgid "~: Wrong number of arguments for prototype ~"
#~ msgstr "~: número incorrecto de argumentos para el prototipo ~"

#~ msgid "~: Bad argument for prototype ~: ~"
#~ msgstr "~: Argumento equivocado para el prototipo ~: ~"

#~ msgid "~: Bad argument: ~"
#~ msgstr "~: Argumento equivocado: ~"

#~ msgid "~: ~ is not a valid address"
#~ msgstr "~: ~ no es una dirección válida"

#~ msgid "~: argument is not a foreign object: ~"
#~ msgstr "~: el argumento no es una variable externa: ~"

#~ msgid "~: argument ~ should be a ~, ~ or ~"
#~ msgstr "~: el argumento ~ debería ser un ~, ~ o ~"

#~ msgid "~: cannot resurrect the zombie ~"
#~ msgstr "~: no se puede resucitar al zombi ~"

#~ msgid "~ cannot be converted to the foreign type ~"
#~ msgstr "~ no puede ser compartido al tipo extranjero ~"

#~ msgid "64 bit integers are not supported on this platform and with this C compiler: ~"
#~ msgstr "los enteros de 64 bits no están soportados en esta arquitectura, para este compilador de C:"

#~ msgid "~ cannot be converted to a foreign function with another calling convention."
#~ msgstr "~ no puede ser convertido a una función externa con otra convención de llamada."

#~ msgid "~: element type has size 0: ~"
#~ msgstr "tipo del elemento ~: tiene tamaño 0: ~"

#~ msgid "~: argument is not a foreign variable: ~"
#~ msgstr "~: el argumento no es una variable extranjera: ~"

#~ msgid "~: foreign variable with unknown type, missing DEF-C-VAR: ~"
#~ msgstr "~: variable externa de tipo desconocido, se ha omitido DEF-C-VAR: ~"

#~ msgid "A foreign variable ~ does not exist"
#~ msgstr "La variable extranjera ~ no existe"

#~ msgid "~: foreign variable ~ does not have the required size or alignment"
#~ msgstr "~: la variable externa ~ no tiene el tamaño o alineamiento requerido"

#~ msgid "~: type specifications for foreign variable ~ conflict: ~ and ~"
#~ msgstr "~: conflicto de especificación de tipo de la variable extranjera ~: ~ y ~"

#~ msgid "~: foreign variable ~ may not be modified"
#~ msgstr "~: no se puede modificar la variable externa ~"

#~ msgid "~: foreign variable ~ of type ~ is not an array"
#~ msgstr "~: la variable externa ~ del tipo ~ no es una unimatriz"

#~ msgid "~: foreign variable ~ of type ~ is not a pointer"
#~ msgstr "~: la variable externa ~ del tipo ~ no es un puntero"

#~ msgid "~: foreign variable ~ of type ~ is not a struct or union"
#~ msgstr "~: la variable externa ~ del tipo ~ no es, ni una estructura, ni una unión"

#~ msgid "~: foreign variable ~ of type ~ has no component with name ~"
#~ msgstr "~: la variable externa ~ del tipo ~ no tiene ningún componente con el nombre ~"

#~ msgid "~: foreign variable ~ does not have the required alignment"
#~ msgstr "~: la variable externa ~ no tiene el alineamiento requerido"

#~ msgid "~: argument is not a foreign function: ~"
#~ msgstr "~: el argumento no es una función externa: ~"

#~ msgid "~: foreign function with unknown calling convention, missing DEF-CALL-OUT: ~"
#~ msgstr "~: función externa con convención de llamada desconocida, se ha omitido DEF-CALL-OUT: ~"

#~ msgid "~: illegal foreign function type ~"
#~ msgstr "~: tipo de función externa inválido ~"

#~ msgid "~: A foreign function ~ does not exist"
#~ msgstr "~: La función extranjera ~ no existe"

#~ msgid "~: calling conventions for foreign function ~ conflict"
#~ msgstr "~: conflicto en la convención de llamada de la función externa ~"

#~ msgid "~: Cannot open library ~: ~"
#~ msgstr "~: No se puede abrir la biblioteca ~: ~"

#~ msgid "~: Cannot open library ~"
#~ msgstr "~: No se puede abrir la biblioteca ~"

#~ msgid "~: no dynamic object named ~ in library ~"
#~ msgstr "~: ningún objeto dinámico nombrado ~ dentro de la biblioteca ~"

#~ msgid "~: ~ is not a library"
#~ msgstr "~: ~ no es una biblioteca"

#~ msgid "symbol ~SA from ~SA will become a shadowing symbol"
#~ msgstr "el símbolo ~SA del ~SA se convertirá en un símbolo que eclipsa a otro"

#
# A ver aquí, que hay mogollón, hay mogollón, ...
#
# Leo, tu opinas que aquí deberíamos traducir:
#
# "variables con vinculación de recintos (~S = dinámicamente):"
#
# Sin embargo, yo creo que lo más correcto es:
#
# "trama de ligadura de las variables (~S = dinámicamente):"
#
# Puesto que esto se refiere al tipo de tramas que hay en la pila,
# cuando ésta está siendo examinada. De hecho, la traducción francesa
# es:
#
# "Le «frame» de liaison de variables (~S signifiant dynamique) lie :"
#
# ..., que viene a ser algo como lo que he puesto yo. - cll
#
#~ msgid "frame binding variables (~S = dynamically):"
#~ msgstr "marco de ligadura de las variables (~S = dinámicamente):"

#~ msgid " binds (~S = dynamically):"
#~ msgstr " vincula (~S = dinámicamente):"

#~ msgid "~Sa: redefining ~Sa ~Ss in ~Sa, was defined in ~Sa"
#~ msgstr "~Sa: redefiniendo ~Sa ~Ss dentro de ~Sa, fue definido dentro de ~Sa"

#~ msgid "Loading file ~SA ..."
#~ msgstr "Cargando fichero ~SA ..."

#~ msgid "Loaded file ~SA"
#~ msgstr "Fichero ~SA cargado"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# No tengo ni idea de qué significa ese "0*"
#~ msgid "~S0*It will be ignored."
#~ msgstr "~S0*Será ignorado."

#~ msgid "Loading logical hosts from file ~SA ..."
#~ msgstr "Hospedadores lógicos cargados desde el fichero ~SA ..."

#~ msgid "Defined logical host ~SA"
#~ msgstr "Hospedador lógico definido ~SA"

#~ msgid "~SA must introduce a number."
#~ msgstr "~SA debe introducir un número."

#~ msgid "The closing format directive '~SA' does not have a corresponding opening one."
#~ msgstr "No existe una directiva de apertura para la de cierre `~SA'."

#~ msgid "The closing format directive '~SA' does not match the corresponding opening one. It should read '~SA'."
#~ msgstr "La directiva de cierre `~SA' no se corresponde con la de apertura. Debe leerse `~SA'."

#~ msgid "The ~S~S; format directive is not allowed at this point."
#~ msgstr "La directiva ~S~S; no está permitida aquí."

#~ msgid "The ~S~Snewline format directive cannot take both modifiers."
#~ msgstr "La directiva ~S~Snewline no puede tomar ambos modificadores."

# Ojo: Estos "ing" no son siempre gerundios.
# Tal vez sea simplemente "...; se esperaba '~SA'." sv
#
# Bueno, ..., cuando el mensaje ha salido es que se ha producido un
# error. En tal caso, no se puede estar `esper*ando*', sino que se
# esperaba, ... Si, creo que tienes toda la razón. cll
#
#~ msgid "An opening format directive is never closed; expecting '~SA'."
#~ msgstr "Una directiva de formato de apertura nunca es cerrado; se esperaba `~SA'."

#~ msgid "The argument for the ~S~SR format directive is too large."
#~ msgstr "El argumento del formato de directiva ~S~SR es demasiado grande."

#~ msgid "The ~S~S[ format directive cannot take both modifiers."
#~ msgstr "La formato de directiva ~S~S[ no puede tomar ambos modificadores."

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#~ msgid "Wrote the memory image into ~SA"
#~ msgstr "Escrito la imagen de memoria dentro del ~SS"

#~ msgid "~Ss: ~Ss is not a function name"
#~ msgstr "~Ss: ~Ss no es un nombre de función"

# Aquí también junto las exclamaciones. sv
#~ msgid "Compiler bug!! Occurred in ~SA~S@[ at ~SA~S]."
#~ msgstr "aError del compilador!! Ocurrió en ~SA~S@[ en ~SA~S]."

#~ msgid " in line ~SD"
#~ msgstr " en la línea ~SD"

#~ msgid " in lines ~SD..~SD"
#~ msgstr " en las líneas ~SD..~SD"

#
# Duda: He querido traducir la palabra `warning' por `aviso' que es como
# debería decirse en español, ¿no?. ¿Hay algún término adoptado en
# es@li.org, para esta palabra?.
#
# Sí, atención. sv
#
# Si, si, ya lo he hecho, ... En todas partes he puesto "WARNING" por
# "ATENCIÓN". No es exactamente lo mismo, pero me parece una sugerencia
# genial, de hecho me gusta muchísimo más que aquello de "AVISO:". De
# esta manera, parecía que te estaban hablando los "super-tacañones" :) - cll
#
# Sin embargo, Santiago, este caso es bastante peculiar. Verás, si dejo
# "ATENCIÓN" aquí, entonces, durante la compilación de un proyecto con
# varios ficheros en Lisp, podría salir, por ejemplo, un mensaje como el
# siguiente (tomado de un ejemplo real, que conste, ...):
#
# --------------
# ATENCIÓN en la función PROBLEMA~C~CESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
# Y yo pregunto, en este caso ¿no es mejor poner "ADVERTENCIA"? La
# verdad es que "ADVERTENCIA" me suena mucho mejor que "ATENCIÓN" y que
# "AVISO". En este caso, lo que se tendría es:
#
# --------------
# ADVERTENCIA en la función PROBLEMA~C~CESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
#
#~ msgid "WARNING~S@[ in ~SA~S]~SA :"
#~ msgstr "ADVERTENCIA~S@[ en ~SA~S]~SA :"

#~ msgid "Function ~Ss is deprecated~S@[, use ~Ss instead~S]"
#~ msgstr "Función ~Ss es obsoleta~S@[, emplee ~Ss en su lugar~S]"

#
# Duda: ¡atención a la utilización de la directiva ~SP!
#
# La siguiente traducción funcionará si, para el caso del español (como
# para el alemán), se pasa el parámetro (eql *error-count* 1), en
# segundo lugar.
#
# Ya no hace falta. Tal y como está hecho no es necesario pasar ningún
# parámetro extra. Así funciona correctamente.
#
# Aquí dudo porque atención no es tan "pluralizable" como aviso. sv
#
# Claro, de hecho, a mí también me pasa lo mismo. He preferido cambiar
# la traducción de "aviso" por "advertencia", en este mensaje y en aquél
# en el que se sacan los mensajes del compilador. ¿No os suena muchísimo
# mejor esta segunda alternativa? - cll
#
#~ msgid "~SD error~S:P, ~SD warning~S:P"
#~ msgstr "~SD error~S:*~S[es~S;~S:;es~S], ~SD advertencia~S:P"

#~ msgid "Listing of compilation of file ~SA~S%on ~S@? by ~SA, version ~SA"
#~ msgstr "Listado de la compilación del fichero ~SA~S%el ~S@? por ~SA, versión ~SA"

#~ msgid "Compiling file ~SA ..."
#~ msgstr "Compilando el fichero ~SA ..."

#~ msgid "Wrote file ~SA"
#~ msgstr " escribió el fichero ~SA"

#~ msgid "service does not exist: ~SA/~SA"
#~ msgstr "servicio no existe: ~SA/~SA"

#~ msgid "~SA is not a number. Try again."
#~ msgstr "~SA no es un número. Pruebe de nuevo."

#~ msgid "a label used for resolving #~SD# references during READ."
#~ msgstr "una etiqueta para resolver #~SD# referencias en READ."

# Nota: Caso brillante de la generación de mensajes diferentes gracias a las
#       directivas condicionales del Clisp (y del Common Lisp en general).
#
#~ msgid ", is accessible in ~S:d package~S:*~S[~S;~S:;s~S] ~S{~SA~S^, ~S}"
#~ msgstr ", es accesible dentro ~S:[del paquete~S;de los paquetes~S] ~S{~SA~S^, ~S}"

#~ msgid " (macro: ~Ss)"
#~ msgstr " (macro: ~Ss)"

#~ msgid ", value: ~Ss"
#~ msgstr ", valor: ~Ses"

#~ msgid "a~S:[~S; deprecated~S] function"
#~ msgstr "una función ~S:[interpret~S;compil~S]ada."

#~ msgid "a~S:[~S; deprecated~S] macro"
#~ msgstr "una función ~S:[interpret~S;compil~S]ada"

#~ msgid "on the ~S:[posi~S;nega~S]tive real axis"
#~ msgstr "en el eje real ~S:[posi~S;nega~S]tivo"

#~ msgid "on the ~S:[posi~S;nega~S]tive imaginary axis"
#~ msgstr "en el eje imaginario ~S:[posi~S;nega~S]tivo"

#~ msgid "in the ~S:[~S:[first~S;fourth~S]~S;~S:[second~S;third~S]~S] quadrant"
#~ msgstr "en el ~S:[~S:[primer~S;cuarto~S]~S;~S:[segundo~S;tercer~S]~S] cuadrante"

#~ msgid "It is a ~S:[non-~S;~S]printable character."
#~ msgstr "Se trata de un carácter ~S:[no ~S;~S]imprimible."

#~ msgid "a~S:[~S:[ closed ~S;n output-~S]~S;~S:[n input-~S;n input/output-~S]~S]stream."
#~ msgstr "un flujo ~S:[~S:[cerrado~S;de salida~S]~S;~S:[de entrada~S;de entrada/salida~S]~S]."

#~ msgid "the package named ~SA"
#~ msgstr "el paquete nombrado ~SA"

#~ msgid ". It has ~S:d nickname~S:*~S[~S;~S:;s~S] ~S{~SA~S^, ~S}"
#~ msgstr ". Tiene los apodos~S:*~S[~S;~S:;s~S] ~S{~SA~S^, ~S}"

#~ msgid "imports the external symbols of ~S:d package~S:*~S[~S;~S:;s~S] ~S{~SA~S^, ~S} and "
#~ msgstr "importa los símbolos externos de~S:[l paquete~S; los paquetes~S] ~S{~SA~S^, ~S} y "

#~ msgid "exports ~S[no symbols~S:;~S:*~S:d symbol~S:*~S[~S;~S:;s~S]~S]"
#~ msgstr "~S:[no exporta ningún símbolo~S;exporta los símbolos~S:*~S{~S<~S%~S:; ~SS~S>~S^~S}~S]"

#~ msgid " to ~S:d package~S:*~S[~S;~S:;s~S] ~S{~SA~S^, ~S}"
#~ msgstr " ~S:[al paquete~S;a los paquetes~S]: ~S{~SA~S^, ~S}"

# Este mensaje tiene una especial dificultad, porque de el deberían
# salir cosas del tipo: "una tabla de lectura" (con `tabla de lectura'
# al final del mensaje) o "la tabla de lectura de Common Lisp" (con
# `tabla de lectura' al principio).
#
# Afortunadamente, la situación puede salvarse sin ningún problema
# gracias a la directiva ~S:* de format
#
#~ msgid "~S:[a~S;the Common Lisp~S] readtable."
#~ msgstr "~S:[una~S;la~S] tabla de lectura~S:*~S:[~S; de Common Lisp~S]"

#~ msgid "a ~S:[~S;portable ~S]pathname~S:[.~S;~S:*, with the following components:~S{~SA~S}~S]"
#~ msgstr "una trayectoria~S:[~S; portátil~S]~S:[.~S;~S:*, constituída por: ~S{~SA~S}~S]"

#~ msgid "a~S:[~S; simple~S] ~SA dimensional array"
#~ msgstr "una matriz~S:[~S; simple~S] de dimensión ~SA"

#~ msgid " of ~SAs"
#~ msgstr " de ~S(~SA~S)s"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#~ msgid "~S%No methods."
#~ msgstr "~S%Sin métodos."

#~ msgid "Argument list: ~S:S"
#~ msgstr "Índice de argumentos: ~S:S"

#~ msgid "Documentation: ~SA"
#~ msgstr "Documentación: ~SA"

#~ msgid "Argument list: ~SA."
#~ msgstr "Argumento listado: ~SA."

#~ msgid "Bytes permanently allocated:   ~S9D~S%Bytes currently in use:        ~S9D~S%Bytes available until next GC: ~S9D"
#~ msgstr "Bytes permanentemente asignados:   ~S9D~S%Bytes actualmente en uso:        ~S9D~S%Bytes disponibles hasta el próximo GC: ~S9D"

#~ msgid "~S: ~S is not an output ~S"
#~ msgstr "~S: ~S no es una salida ~S"

#~ msgid "~S: argument ~S should be ~S."
#~ msgstr "~S: el argumento ~S debería ser ~S."

#~ msgid "Please choose one of ~S:{~SA~S:^, ~S} ."
#~ msgstr "Por favor, elija uno/a de ~S:{~SA~S:^, ~S} ."

#~ msgid "Error: ~S~S:@> not implemented"
#~ msgstr "Error: ~S~S:@> no implementado"
