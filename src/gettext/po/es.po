# Mensajes en español para GNU CLISP.
# Copyright (C) 1996 Free Software Foundation, Inc.
# Carlos Linares López <clinares@delicias.dia.fi.upm.es>, 1997.
#
# Han contribuido a esta traducción:
#
# cll - Carlos Linares López 	(Traducción)
# sv  - Santiago Vila Doncel	(Revisión)
# lsg - Leonardo Sarasúa García	(Traducción y Revisión)
#
# Agradecimientos especiales a:
#
# Bruno Haible
# Marcus Daniels
# 					(Programadores de CLisp)
#
# Enrique Melero
# 				    (Coordinador de Spanish GNU)
#
# Por haber atendido siempre mis preguntas y por mostrar tanto interés
# en esta traducción.
#
# Asimismo, quisiera expresar mi agradecimiento a las siguientes
# personas, por responder pacientemente todas mis preguntas: Joerg
# Hoehle (traductor de la versión francesa) y Juan Jordana.
#
# Por último, a toda la lista de Spanish GNU Translation Team
# (es@li.org) por sus sugerencias.
#
# NOTAS.
#
# * Los mensajes en los que se han realizado anotaciones de interés,
# bien porque haya alguna duda, bien porque contenga notas importantes
# relativas a las traducciones tienen la palabra `Duda:' al principio de
# su comentario.
#
# * Por favor, si alguien realiza alguna modificación a este archivo que
# ponga sus iniciales al final del comentario explicando el cambio y el
# motivo. Si su nombre no está en esta cabecera que lo añada poniendo
# las iniciales.
#
# * Todas las líneas que comienzan con #~ son mensajes obsoletos que no
# hace falta revisar. En cualquier caso, intentaré normalmente
# eliminarlas.
#
# $Id$
# $Log$
# Revision 1.12  1998/09/07 18:21:38  clinares
# Traducción de todos los mensajes para la versión del 29-8-1998. Estos
# cambios, sin embargo, serán publicados en alguna nueva versión de
# septiembre de este mismo año.
#
# Revision 1.9  1997/09/18 13:36:38  clinares
# He incluído nuevas modificaciones de Leo Sarasúa.
#
# Entre las más representativas está el hecho de haber modificado
# `trama' por `marco' y `# macro carácter' por `macro carácter
# secundario'. Nuevamente gracias, Leo, ...
#
# Revision 1.8  1997/09/05 17:23:30  clinares
# He introducido todas las modificaciones propuestas por Santiago Vila a
# la versión 1.6. Además, las he adaptado para el nuevo .pot que se
# empleó en la versión 1.7.
#
# Entre los cambios más importantes está: `command' es `orden', no
# `comando'; `warning' es, preferiblemente, `atención' y, en otro caso,
# propongo que sea `advertencia', en vez de `aviso'.
#
# Revision 1.7  1997/09/03 17:51:44  clinares
# He modificado la traducción de las directivas ~P, puesto que nunca se
# escribirán versiones en español de ellas, ya que el estándar Common
# Lisp - The Language es muy específico: solo en inglés. Ni en alemán,
# ni francés, ni español, ...
#
# Además, he adaptado los cambios del POT de la versión 1.6
# (POT-Creation-Date: 1997-05-04) a la última versión que existe
# actualmente (POT-Creation-Date: 1997-09-02). Para ello, he traducido 9
# mensajes nuevos, he corregido los mensajes difusos y he borrado todos
# los obsoletos.
#
# Revision 1.6  1997/08/30 14:04:08  clinares
# El 100% de los mensajes están traducidos :)
# En total, 9 meses de trabajo (es decir, ¡¡ha sido un parto!! :)
#
# Revision 1.5  1997/08/27 00:48:46  clinares
# Esta es la traducción que resulta de programar todos los cambios
# propuestos por lsg (Leonardo Sarasúa García). En total, ¡¡alrededor de
# 800 líneas!!, ahí es nada :)
#
# Muchísimas gracias, Leo. Te debo la cerveza más grande del mundo, ...
#
# ------------------------------------------------------------------
# msgfmt --statistics -c -v -o /dev/null /home/clinares/GNU/clisp.po
# 1406 mensajes traducidos.
# ------------------------------------------------------------------
#
msgid ""
msgstr ""
"Project-Id-Version: GNU clisp 1996-03-31\n"
"POT-Creation-Date: 2000-03-03 22:56:47 CET\n"
"PO-Revision-Date: 1997-08-11 18:16 MET DST\n"
"Last-Translator: Carlos Linares López <clinares@delicias.dia.fi.upm.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: constobj.d:371
msgid "Please choose:"
msgstr "Por favor, escoja:"

#: constobj.d:375
msgid "Please choose one of ~:{~A~:^, ~} ."
msgstr "Por favor, elija uno/a de ~:{~A~:^, ~} ."

#: constobj.d:378
msgid "symbol ~A from #<PACKAGE ~A> will become a shadowing symbol"
msgstr "el símbolo ~A del paquete #<PACKAGE ~A> se convertirá en un símbolo que eclipsa a otro"

#: constobj.d:380
msgid "You may choose the symbol in favour of which to resolve the conflict."
msgstr "Puede elegir el símbolo en favor del cual se resolverá el conflicto."

#: constobj.d:382
msgid "uninterning ~S from ~S uncovers a name conflict."
msgstr "Al sacar ~S de ~S se ha puesto de manifiesto un conflicto entre nombres."

#: constobj.d:384 constobj.d:398
msgid "You may choose how to proceed."
msgstr "Puede elegir cómo continuar."

#: constobj.d:386
msgid "importing ~S into ~S produces a name conflict with ~S."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S."

#: constobj.d:388
msgid "importing ~S into ~S produces a name conflict with ~S and other symbols."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S y otros símbolos."

#
# publicar está mal y ademas no es consistente con el mensaje d:329 en el que dice 'sacar'
# En este y en otros mensajes, el texto no es una orden dada al usuario, sino una opción que
# se le ofrece. Por tanto, no debe traducirse como un imperativo (impórtelo)  sino en
# infinitivo (importarlo). Pero deberías confirmar esto. - lsg
#
# Si, creo que tienes toda la razón, ... Entonces pongo `sacar' que
# aunque suene muy burro, creo que es muy, muy claro, ...
#
#: constobj.d:390
msgid "((\"I\" \"import it and unintern the other symbol\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"impórtarlo y sacar el otro símbolo\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Aquí tengo la misma duda anterior - lsg
#
#: constobj.d:393
msgid "((\"I\" \"import it, unintern one other symbol and shadow the other symbols\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"importarlo, sacar uno de los otro símbolos y eclipsar el resto\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Lo mismo de antes - lsg
#
#: constobj.d:396
msgid "((\"I\" \"import it and shadow the other symbol\" T) (\"N\" \"do nothing\" NIL))"
msgstr "((\"I\" \"importarlo y eclipsar el otro símbolo\" T) (\"N\" \"no hacer nada\" NIL))"

#: constobj.d:400
msgid "symbol ~S should be imported into ~S before being exported."
msgstr "el símbolo ~S debe ser importado a ~S antes de ser exportado."

#
# La misma cuestión anterior entre imperativo e infinitivo - lsg
#
#: constobj.d:402
msgid "((\"I\" \"import the symbol first\" T) (\"N\" \"do nothing, don't export the symbol\" NIL))"
msgstr "((\"I\" importar el símbolo primero\" T) (\"N\" \"no hacer nada, no exportar el símbolo\"))"

#: constobj.d:405
msgid "You may choose in favour of which symbol to resolve the conflict."
msgstr "Puede elegir en favor de qué símbolo se debe resolver el conflicto."

#
# El segundo from deberia ser 'de', porque quiere decir que un símbolo
# a de un paquete A entra en conflicto con el símbolo b _del_ paquete
# B. Luego, debe ser 'de'.
#
#: constobj.d:407
msgid "exporting ~S from ~S produces a name conflict with ~S from ~S."
msgstr "la exportación de ~S desde ~S produce un conflicto de nombres con ~S de ~S."

#: constobj.d:409
msgid "Which symbol should be accessible in ~S ?"
msgstr "¿ Qué símbolo debe ser accesible en ~S ?"

#: constobj.d:413
msgid "the symbol to export, "
msgstr "el símbolo a exportar, "

#: constobj.d:415
msgid "the old symbol, "
msgstr "El símbolo original, "

#: constobj.d:417
msgid "You may choose for every conflict in favour of which symbol to resolve it."
msgstr "Puede elegir en favor de qué símbolo se debe resolver cada conflicto."

#
# Es una traducción un poco libre (literalmente sería "el nombre = ~S
# entra en conflicto...."), pero ésta me parece más corta y correcta. - lsg
#
#: constobj.d:419
msgid "~S name conflicts while executing USE-PACKAGE of ~S into package ~S."
msgstr "Conflicto de nombre ~S al ejecutar USE-PACKAGE de ~S al paquete ~S"

#: constobj.d:421
msgid "which symbol with name ~S should be accessible in ~S ?"
msgstr "¿ Qué símbolo con nombre ~S debe ser accesible en ~S ?"

#: constobj.d:423
msgid "You can input another name."
msgstr "Puede introducir otro nombre."

#: constobj.d:425
msgid "You can input another nickname."
msgstr "Puede introducir otro apodo."

#: constobj.d:427
msgid "a package with name ~S already exists."
msgstr "ya existe un paquete con el nombre ~S."

#
# Si fuera inglés corriente, estaría bien tu traducción, pero es inglés
# 'telegráfico', y en realidad quieren decir lo que te he escrito, es
# decir, 'nuevo' afecta a 'nombre', no a 'paquete'.
#
# Eres un gran maestro, algo así como un quinto dan de las traducciones,
# ... ¡Tienes toda la razón! :) - cll
#
#: constobj.d:429
msgid "Please input new package name:"
msgstr "Por favor, introduzca un nuevo nombre de paquete:"

#: constobj.d:431
msgid "Please input new package nickname:"
msgstr "Por favor, introduzca un nuevo apodo de paquete:"

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: constobj.d:433
msgid "Ignore."
msgstr "Ignorar."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: constobj.d:435
msgid "~S: There is no package with name ~S."
msgstr "~S: No hay ningún paquete con el nombre ~S."

#: constobj.d:437
msgid "~*Nevertheless delete ~S."
msgstr "~*No obstante borre ~S."

#
# Leo, en vez de "está siendo utilizado", ¿no crees que es mejor "es
# utilizado"? - cll
#
# Propongo *se utiliza*, es mucho más español. sv
#
# Pero, ¿cómo pones algo así? "~S se utiliza en ~{~S~^, ~}.", ¿por
# ejemplo? Es que el problema es que no ~S (el primero) no "se utiliza"
# en la segunda expresión, sino que la segunda expresión es una que
# emplea a la primera. No se si me explico, ...
#
# En cualquier caso, creo que tienes toda la razón al decir "es mucho
# más español", es que de hecho la expresión "es utilizado" aunque es
# correcta, no parece muy española, por favor, ¿sugerencias? - cll
#
#: constobj.d:439
msgid "~S: ~S is used by ~{~S~^, ~}."
msgstr "~S: ~S es utilizado por ~{~S~^, ~}."

#: constobj.d:453
msgid "January"
msgstr "Enero"

#: constobj.d:457
msgid "February"
msgstr "Febrero"

#: constobj.d:461
msgid "March"
msgstr "Marzo"

#: constobj.d:465
msgid "April"
msgstr "Abril"

#: constobj.d:469
msgid "May"
msgstr "Mayo"

#: constobj.d:473
msgid "June"
msgstr "Junio"

#: constobj.d:477
msgid "July"
msgstr "Julio"

#: constobj.d:481
msgid "August"
msgstr "Agosto"

#: constobj.d:485
msgid "September"
msgstr "Septiembre"

#: constobj.d:489
msgid "October"
msgstr "Octubre"

#: constobj.d:493
msgid "November"
msgstr "Noviembre"

#: constobj.d:497
msgid "December"
msgstr "Diciembre"

#: constobj.d:512
msgid "ANSI C program"
msgstr "programa ANSI C"

#: constobj.d:516
msgid "GNU C++ "
msgstr "GNU C++"

#: constobj.d:519
msgid "GNU C "
msgstr "GNU C "

#: constobj.d:526
msgid "C++ compiler"
msgstr "Compilador de C++"

#: constobj.d:529
msgid "C compiler"
msgstr "Compilador de C"

# Ojo: ¿¿No sería "INGLÉS"?? sv
#
# No, esto está bien, esta expresión se utiliza en una parte del código
# de CLisp en la que se realiza la inicialiación dependiente del idioma,
# de modo que en la traducción alemana pone "DEUTSCH" y en la francesa
# "FRANCAIS", pues en la española, "ESPAÑOL", como corresponde - cll
#
#: constobj.d:534
msgid "ENGLISH"
msgstr "ESPAÑOL"

#: constobj.d:693
msgid "The value of ~S was not a pathname. ~:*~S is being reset."
msgstr "El valor de ~S no es del tipo PATHNAME. ~:*~S se reinicializará."

# Duda: ¿Creando *el* directorio? ¿Creando *un* directorio? De momento,
# simplemente "Creando directorio" - cll
#
#: constobj.d:698
msgid "Creating directory: "
msgstr "Creando directorio: "

#: constobj.d:847
msgid ""
"The variable ~S had an illegal value.\n"
"~S has been reset to ~S."
msgstr ""
"La variable ~S tenía un valor inválido.\n"
"~S ha sido inicializado a ~S."

#: constobj.d:849
msgid ""
"Floating point operation combines numbers of different precision.\n"
"See ANSI CL 12.1.4.4 and the CLISP impnotes for details.\n"
"The result's actual precision is controlled by\n"
"~S.\n"
"To shut off this warning, set ~S to ~S."
msgstr ""
"Las operaciones en coma flotante combinan números de diferentes precisiones.\n"
"Para más detalles, consulte ANSI CL 12.1.4.4 y las notas de implementación de\n"
"CLISP.\n"
"La precisión actual del resultado está controlada por\n"
"~S.\n"
"Para eliminar este aviso, establezca el valor de ~S a ~S."

#: constobj.d:864
msgid "Bye."
msgstr "Adiós."

#: constobj.d:866
msgid "Press a key to terminate..."
msgstr ""

# Un poco más en español podría ser: "Entorno siguiente: " sv
#
# Hmmm, ..., aquí no estoy de acuerdo contigo. No me suena bien lo del
# "Entorno siguiente", ... cll
#
#: constobj.d:871
msgid ""
"\n"
"  Next environment: "
msgstr ""
"\n"
"  Siguiente entorno: "

#: constobj.d:873
msgid ""
"\n"
"APPLY frame with breakpoint for call "
msgstr ""
"\n"
"marco APPLY con punto de ruptura para invocar "

#: constobj.d:875
msgid ""
"\n"
"APPLY frame for call "
msgstr ""
"\n"
"marco APPLY para invocar "

#: constobj.d:877
msgid ""
"\n"
"EVAL frame with breakpoint for form "
msgstr ""
"\n"
"marco EVAL con punto de ruptura para la forma "

#: constobj.d:879
msgid ""
"\n"
"EVAL frame for form "
msgstr ""
"\n"
"marco EVAL para la forma "

#
# A ver aquí, que hay mogollón, hay mogollón, ...
#
# Leo, tu opinas que aquí deberíamos traducir:
#
# "variables con vinculación de recintos (~ = dinámicamente):"
#
# Sin embargo, yo creo que lo más correcto es:
#
# "trama de ligadura de las variables (~ = dinámicamente):"
#
# Puesto que esto se refiere al tipo de tramas que hay en la pila,
# cuando ésta está siendo examinada. De hecho, la traducción francesa
# es:
#
# "Le «frame» de liaison de variables (~ signifiant dynamique) lie :"
#
# ..., que viene a ser algo como lo que he puesto yo. - cll
#
#: constobj.d:881
msgid ""
"\n"
"frame binding variables (~ = dynamically):"
msgstr ""
"\n"
"marco de ligadura de las variables (~ = dinámicamente):"

#: constobj.d:884
msgid ""
"\n"
"CALLBACK frame"
msgstr ""
"\n"
"marco CALLBACK"

#: constobj.d:887
msgid ""
"\n"
"frame binding variables "
msgstr ""
"\n"
"marco de ligadura de las variables"

#: constobj.d:889
msgid ""
"\n"
"frame binding functions "
msgstr ""
"\n"
"marco de ligadura de las funciones "

#: constobj.d:891
msgid " binds (~ = dynamically):"
msgstr " vincula (~ = dinámicamente):"

#: constobj.d:894
msgid ""
"\n"
"block frame "
msgstr ""
"\n"
"marco de bloque"

#: constobj.d:896
msgid ""
"\n"
"nested block frame "
msgstr ""
"\n"
"marco anidado de bloque"

#: constobj.d:898
msgid " for "
msgstr " para "

#: constobj.d:900
msgid ""
"\n"
"compiled block frame for "
msgstr ""
"\n"
"marco de bloque compilado para "

#: constobj.d:902
msgid ""
"\n"
"tagbody frame "
msgstr ""
"\n"
"marco de cuerpo de etiquetas de salto"

# Duda: Aquí lo de `nested' es bastante puñetero. Creo que no debe
# traducirse por `anidado' (que no tendría demasiado sentido, creo),
# sino por `encajada', haciendo referencia a la trama a la que se llega
# por el uso de las etiquetas de salto, ...
#
# Sin embargo, no estoy demasiado seguro, ... ¡¡Socorro!! - cll
#
# A propósito de esta cuestión, pregunté en la lista de correo de CLisp:
#
# > `nested' have various meanings. It can mean that one thing is `into'
# > other one or that one thing is `joined' with other one. In this
# > message, I think you are talking about the frame you arrive when using
# > a tag, as if you were `joining' a new frame, is it so?
#
# Y la respuesta de Bruno Haible fue:
#
# No. In CLISP it's yet another (maybe new?) meaning. Interpretation frames
# are normally built up in the stack. However, when a closure is created,
# some parts of the frames must be moved out to the heap, so that the
# closure points to valid data, called "environment", even after the frame
# has been deestablished. We called this process "nesting" of a frame.
# Any better vocabulary? Can you propose a good german or french translation?
#
# Asi que, la verdad, "anidado" me parece correcto. Para ello, imaginaos
# una trama (o marco), de la que se "re-elabora" una parte denominada
# "entorno" pero que solo tiene sentido dentro de esta trama (o marco),
# puesto que se ha levantado un `closure'. - cll
#
#: constobj.d:904
msgid ""
"\n"
"nested tagbody frame "
msgstr ""
"\n"
"marco anidado del cuerpo de etiquetas de salto"

#: constobj.d:906
msgid " for"
msgstr " para"

#: constobj.d:909
msgid ""
"\n"
"compiled tagbody frame for "
msgstr ""
"\n"
"marco compilado del cuerpo de etiquetas de salto para "

#
# Ésta estaba claramente mal - lsg
#
#: constobj.d:911
msgid ""
"\n"
"catch frame for tag "
msgstr ""
"\n"
"marco de captura para la etiqueta "

# Handler, otra buena.. Sugerencias? - lsg
#
# Duda: ¿cómo traducir `handler'?
#
# Pues bien, he elegido el término `manipulador' puesto que eso es,
# precisamente, lo que es un `handler' en Common Lisp. De hecho, el
# estándar Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr.,
# en la página 872 dice:
#
# "The process of signaling involves the search for an invocation of a
# handler, a piece of code that will attempt to deal appropiately with
# the situation"
#
# Y atención a la siguiente observación: (en la misma página, a
# continuación del párrafo anterior)
#
# "If a handle is found, it may either handle the situation, by
# performing some non-local transfer of control, or decline to handle
# it, by failing to perform a non-local transfer of control. If it
# declines, other handlers are sought".
#
# En fin, a la vista de esta definición y de la siguiente aclaración,
# propongo `manejador' para su traducción - cll
#
#: constobj.d:913
msgid ""
"\n"
"handler frame for conditions"
msgstr ""
"\n"
"marco de manipulación (HANDLER) para las condiciones"

#
# Estaba mal. Yo pondria: "recinto de unwind-protect" - lsg
#
# Y yo creo que si cambiamos `recinto' por `trama' ya es la leche de
# perfecto ;) - cll
#
# Leo, como puedes ver he cambiado en todos lados `trama' por `marco' - cll
#
#: constobj.d:915
msgid ""
"\n"
"unwind-protect frame"
msgstr ""
"\n"
"marco `unwind-protect'"

# Duda: Lo de `driver' lo dejo sin traducir, ...
#
# En la traducción francesa está sin traducir y en el estándar de Common
# Lisp no se hace ni la mas mínima referencia a algo que se llame así.
#
# "recinto de driver" - lsg
#
# Vale, ¡pero vamos!, que cambio `recinto' por `trama' - cll
#
#: constobj.d:917
msgid ""
"\n"
"\n"
"driver frame"
msgstr ""
"\n"
"\n"
"marco `driver'"

# "Entornos con vinculación de recintos" - lsg
#
# Aquí volvemos un poco a lo del mensaje constobj.d:915 Según creo,
# estos mensajes se refieren al tipo de tramas que hay en la pila, no se
# trata de un entorno (en el sentido que en Lisp tiene esta palabra).
#
# La traducción francesa dice:
#
# "«frame» de liaison d'environnements"
#
# ¿Que os parece?
#
#: constobj.d:919
msgid ""
"\n"
"frame binding environments"
msgstr ""
"\n"
"marco de ligadura del entorno"

#: spvw.d:593
msgid "could not make symbol value per-thread"
msgstr ""

# "*** - desbordamiento de la pila del programa - REINICIALIZANDO" - lsg
#
# En mi opinión, RESET debe traducirse como un imperativo - cll
#
#: spvw.d:657
msgid ""
"\n"
"*** - Program stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila del programa. REINICIE"

# ¡ Toma puntilloso que soy! Lisp debería escribirse con mayúscula.
# "*** - desbordamiento de la pila de Lisp - REINICIALIZANDO" - lsg
#
# No, no, nada de REINICIALIZANDO. Debe ser un imperativo: REINICIE.
# Por ejemplo, si durante una sesión con CLisp haces:
#
# > (defun foo (a) (foo (1- a)))
# FOO
# > (foo 2)
#
# *** - Desbordamiento de la pila de Lisp. REINICIE
# >
#
# ..., pero el intérprete se queda esperando a que tú sigas tecleando,
# es decir, él solo no se pone a reiniciar nada, ...
#
# Por otra parte, tienes toda la razón, Lisp debe ir con mayúsculas :) - cll
#
#: spvw.d:662
msgid ""
"\n"
"*** - Lisp stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila de Lisp. REINICIE"

#
# Muy bueno el apunte sobre ese acento en "cómo". Gracias, Santiago - cll
#
#: spvw.d:799
msgid ""
"internal error: statement in file ~, line ~ has been reached!!\n"
"Please send the authors of the program a description how you produced this error!"
msgstr ""
"error interno: ¡¡en la sentencia del fichero ~, línea ~!!\n"
"¡Por favor, envíe a los autores del programa una descripción de cómo\n"
"se produjo este error!"

#
# Por qué traduces signature asi?
# "Signatura desconocida de una FSUBR\n" - lsg
#
# Bueno, pues porque la traducción francesa dice:
#
# "Type d'argument inconnu pour FSUBR"
#
# Y mientras no sepa qué leches es eso del FSUBR (o SUBR, ver mensaje
# siguiente), pues para no pillarme los dedos lo dejaré tal y como lo
# puso Joerg Hoehle - cll
#
#: spvw.d:861
msgid "Unknown signature of an FSUBR\n"
msgstr "Tipo de argumento desconocido para FSUBR\n"

# ¿¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:970
msgid "Unknown signature of a SUBR\n"
msgstr "Tipo de argumento desconocido para SUBR\n"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:1603
msgid "module `%s' requires package %s.\n"
msgstr "el módulo `%s' necesita el paquete %s.\n"

# Antes de entrar en el debate sobre la traducción de port:
# ¿Es tan fundamentalmente distinto version y port en este contexto como
# para que no se pueda utilizar también versión para "port"? sv
#
# ¡¡Madre mía!! Eso de "antes de entrar" me ha dado muchísimo miedo,
# ... :) Asi que no se hable más, pongo "versión" :) No, ahora fuera
# cachondeo, en el contexto de estos mensajes la expresión "versión" es
# perfecta, ... - cll
#
#: spvw.d:1740
#, fuzzy
msgid "                    Amiga version: Jörg Höhle\n"
msgstr "                    Versión para Amiga: Jörg Höhle\n"

#: spvw.d:1744
#, fuzzy
msgid "                    RISCOS port: Peter Burwood, Bruno Haible\n"
msgstr "                    Versión para RISCOS: Peter Burwood, Bruno Haible\n"

#: spvw.d:1748
#, fuzzy
msgid "                    DOS port: Jürgen Weber, Bruno Haible\n"
msgstr "                    Versión para DOS: Jürgen Weber, Bruno Haible\n"

#: spvw.d:1967
msgid "Syntax for %s: nnnnnnn or nnnnKB or nMB\n"
msgstr "Sintaxis de %s: nnnnnnn or nnnnKB or nMB\n"

#
# "%s fuera de intervalo\n"
# No me gusta del todo. A lo mejor:
# "%s fuera de limites\n" - lsg
#
# Al final me he decidido por:
#
# "%s se ha salido del rango\n"
#
# ¿No te mola más? - cll
#
#: spvw.d:1971
msgid "%s out of range\n"
msgstr "%s se ha salido del rango\n"

#: spvw.d:1983
msgid "memory size"
msgstr "tamaño de memoria"

#: spvw.d:1993
msgid "stack size"
msgstr "tamaño de la pila"

#: spvw.d:2317
msgid "Return value of malloc() = %x is not compatible with type code distribution.\n"
msgstr "El valor devuelto por malloc() = %x no es compatible con la distribución del código de tipo.\n"

# solo es con acento.
# "sólo %d bytes disponibles\n" - lsg
#
# ¡¡Madre mía!! Tienes toda la razón del mundo - cll :)
#
#: spvw.d:2324
msgid "Only %d bytes available.\n"
msgstr "Sólo quedan %d bytes disponibles.\n"

# Duda: Imagino que SP es el "Stack Pointer". Pero entonces, ¿a qué
# viene decir "SP stack"? ¿Se referirán con ello a la pila del sistema?
# - cll
#
#: spvw.d:2558
msgid "Couldn't determine the end of the SP stack!\n"
msgstr "No fue posible determinar el final de la pila SP!\n"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:2783
msgid ""
"\n"
"WARNING: No initialisation file specified.\n"
msgstr ""
"\n"
"ATENCIÓN: No se ha especificado ningún fichero de inicialización.\n"

#: spvw.d:2787
msgid "Please try: "
msgstr "Por favor, intente:"

#: spvw.d:2976
msgid "Not enough memory for Lisp.\n"
msgstr "No hay memoria suficiente para Lisp.\n"

# "*** - Memoria virtual agotada. REINICIALIZACION " - lsg
#
# Yo creo que el mensaje debe acabar en un imperativo: REINICIALIZAR - cll
#
#: spvw_alloca.d:49
msgid ""
"\n"
"*** - Virtual memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria virtual agotada. REINICIE"

# "*** - Memoria agotada. REINICIALIZACION " - lsg
#
# Más de lo mismo - cll
#
#: spvw_alloca.d:51
msgid ""
"\n"
"*** - Memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria agotada. REINICIE"

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:67 spvw_mmap.d:219 spvw_mmap.d:392 spvw_multimap.d:174
msgid "Cannot map memory to address 0x%x ."
msgstr "No se puede asignar la memoria a la dirección 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:188
msgid "Cannot reserve address range at 0x%x ."
msgstr "No se puede reservar el rango de direcciones a 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:199
msgid "Cannot reserve address range 0x%x-0x%x ."
msgstr "No se puede reservar el rango de direcciones 0x%x-0x%x ."

#: spvw_mmap.d:252
msgid "CreateFileMapping() failed."
msgstr "CreateFileMapping() falló."

#: spvw_mmap.d:259
msgid "MapViewOfFileEx(addr=0x%x,off=0x%x) failed."
msgstr "MapViewOfFileEx(dirección=0x%x,segmento=0x%x) falló."

#: spvw_mmap.d:266
msgid "MapViewOfFileEx() returned 0x%x instead of 0x%x.\n"
msgstr "MapViewOfFileEx() devolvió 0x%x en vez de 0x%x.\n"

#: spvw_mmap.d:283
msgid "VirtualFree() failed."
msgstr "VirtualFree() falló."

#: spvw_mmap.d:299
msgid "VirtualProtect() failed."
msgstr "VirtualProtect() falló."

#: spvw_mmap.d:367 spvw_multimap.d:115
msgid "Cannot open /dev/zero ."
msgstr "No se puede abrir /dev/zero."

# "msync(0x%x,0x%x,MS_INVALIDATE) fracasó." - lsg
#
# O "falló" en vez de "fracasó". ¿Qué te parece? - cll
#
#: spvw_multimap.d:144
msgid "msync(0x%x,0x%x,MS_INVALIDATE) fails."
msgstr "msync(0x%x,0x%x,MS_INVALIDATE) falló."

#: spvw_multimap.d:209
msgid "Cannot open %s ."
msgstr "No se puede abrir %s."

#: spvw_multimap.d:220
msgid "Cannot delete %s ."
msgstr "No se puede borrar %s ."

# He seguido la propuesta de Santiago Vila. A partir de ahora, y siempre
# que sea posible, el término "warning" se traducirá por "atención". En
# aquellos casos en que esto no es posible, lo he indicado
# explícitamente con un comentario indicando el motivo. - cll
#
#: spvw_multimap.d:235
msgid "** WARNING: ** Too few free disk space for %s .\n"
msgstr "** ATENCIÓN: ** Hay muy poco espacio libre en disco para %s .\n"

#: spvw_multimap.d:238
msgid "Please restart LISP with fewer memory (option -m).\n"
msgstr "Por favor, vuelva a ejecutar LISP con menos memoria (opción -m).\n"

#: spvw_multimap.d:246
msgid "Cannot make %s long enough."
msgstr "No es posible agrandar %s lo suficiente."

#: spvw_multimap.d:265
msgid "Cannot fill %s ."
msgstr "No se puede rellenar %s ."

#: spvw_multimap.d:282
msgid "Cannot close %s ."
msgstr "No se puede cerrar %s ."

#: spvw_multimap.d:317
msgid "Cannot close /dev/zero ."
msgstr "No se puede cerrar /dev/zero ."

#
# Muy buena tu sugerencia, Leo. Se queda tal y como tu propones - lsg
#
# ¿Apoyo o soporte? sv
#
# Bueno, si, tienes razón. De hecho ésta era una de esas traducciones
# "raras". El problema es que no estaba seguro de que el término
# "soporte" fuese aceptado. Pero si es así, pues perfecto - cll
#
#: spvw_multimap.d:353
msgid "Recompile your operating system with SYSV IPC support.\n"
msgstr "Recompile su sistema operativo con soporte para SYSV IPC.\n"

#
# "no se puede asignar un segmento privado en la memoria compartida" - lsg
#
#: spvw_multimap.d:367
msgid "Cannot allocate private shared memory segment."
msgstr "No se puede asignar un segmento privado en la memoria compartida."

#: spvw_multimap.d:389
msgid "Cannot map shared memory to address 0x%x."
msgstr "No se puede asignar la memoria compartida a la direccion 0x%x."

#: spvw_multimap.d:412
msgid "Cannot fill shared memory."
msgstr "No se puede rellenar la memoria compartida."

#: spvw_multimap.d:418
msgid "Could not fill shared memory."
msgstr "No se pudo rellenar la memoria compartida."

#
# En este y en otros tantos mensajes, he seguido tu consejo, Leo. He
# traducido `remove' por `desechar' en todos los sitios. - cll
#
#: spvw_multimap.d:433
msgid "Cannot remove shared memory segment."
msgstr "No se puede desechar el segmento de memoria compartida."

#: spvw_fault.d:482
msgid "mprotect() fails."
msgstr "mprotect() falló."

# "SIGSEGV no puede ser subsanado. Dirección del error =3D 0x%x.\n" - lsg
#
# Si, me gusta más tu traducción. Yo había puesto:
#
# "No se puede evitar SIGSEGV. Dirección de fallo = 0x%x.\n"
#
# Pero el caso es que un SIGSEGV no tiene porque evitarse puesto que es
# una señal que, para cuando sale este mensaje, ya se ha recibido. El
# problema ---realmente--- es que no fue posible "subsanar" la
# señal. Muy bien - cll
#
# De todas formas, prefiero ponerlo al revés ("No se puede subsanar" en
# vez de "... no puede ser subsanado"). Por otra parte, en vez de
# "error" prefiero "fallo" puesto que eso es exactamente de lo que se
# trata. No de un error por algo que alguien hizo mal, sino de un fallo
# del sistema, ... - cll
#
#: spvw_sigsegv.d:31
msgid ""
"\n"
"SIGSEGV cannot be cured. Fault address = 0x%x.\n"
msgstr ""
"\n"
"No se puede subsanar SIGSEGV. Dirección de fallo = 0x%x.\n"

#: spvw_sigsegv.d:73
msgid "Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!\n"
msgstr "Escenario Apollo 13: Falló la manipulación del desbordamiento de pila. ¡¡¡ Nos estrellaremos en el siguiente desbordamiento de pila !!!\n"

#: spvw_sigint.d:76 spvw_sigint.d:159
msgid "Ctrl-C: User break"
msgstr "Ctrl-C: Interrupción del usuario"

#: spvw_garcol.d:2020
msgid "munmap() fails."
msgstr "munmap() falló."

#: spvw_allocate.d:34
msgid "No more room for LISP objects"
msgstr "No queda espacio para almacenar más objetos LISP"

#
# "*** - no queda espacio para almacenar objetos LISP - REINICIALIZANDO" - lsg
#
# Yo sigo en mis trece, ... Debe ser un imperativo: REINICIE - cll
#
#: spvw_allocate.d:54
msgid ""
"\n"
"*** - No more room for LISP objects: RESET"
msgstr ""
"\n"
"*** - No queda espacio para almacenar más objetos LISP: REINICIE"

#: spvw_allocate.d:272 spvw_allocate.d:337 spvw_allocate.d:418
msgid "Trying to make room through a GC...\n"
msgstr "Intentando obtener más espacio a través de un GC ...\n"

#: spvw_memfile.d:218
msgid "disk full"
msgstr "el disco está lleno"

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#: spvw_memfile.d:744
msgid "operating system error during load of initialisation file `%s'\n"
msgstr "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"

#: spvw_memfile.d:1216
msgid "Cannot map the initialisation file into memory."
msgstr "No puedo escribir el fichero de inicialización en memoria."

#: spvw_memfile.d:1480
msgid "operating system error during load of initialisation file\n"
msgstr "error del sistema operativo durante la carga del fichero de inicialización\n"

#: spvw_memfile.d:1486
msgid "initialisation file was not created by this version of LISP\n"
msgstr "el fichero de inicialización no fue creado con esta versión de LISP\n"

#: spvw_memfile.d:1490
msgid "not enough memory for initialisation\n"
msgstr "no hay memoria suficiente para la inicialización\n"

# "~: ~ es una constante, no se puede asignar dinámicamente" - lsg
#
# ¡Bingo! - cll
#
#: eval.d:551
msgid "~: ~ is a constant, cannot be bound dynamically"
msgstr "~: ~ es una constante, no se puede asignar dinámicamente"

#: control.d:2457 eval.d:1516
msgid "Too many documentation strings in ~"
msgstr "Demasiadas cadenas de documentación en ~"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#: eval.d:1728
msgid "FUNCTION: lambda-list for ~ is missing"
msgstr "FUNCTION: falta la lista lambda de ~"

#
# "FUNCTION: la lista lambda de ~ debe ser una lista, no un(a) ~" - lsg
#
# Lo de "un(a)" no me mola, aunque sin esa palabra el mensaje queda más
# "telegráfico", me parece más apropiado para tratarse del "diálogo con
# un ordenador" :) - cll
#
#: eval.d:1738
msgid "FUNCTION: lambda-list for ~ should be a list, not ~"
msgstr "FUNCTION: la lista lambda de ~ debe ser una lista, no ~"

#: eval.d:1851
msgid "FUNCTION: illegal declaration ~"
msgstr "FUNCTION: declaración inválida ~"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#: eval.d:1862
msgid "FUNCTION: ~ is not a symbol, cannot be declared SPECIAL"
msgstr "FUNCTION: ~ no es un símbolo, no puede declararse SPECIAL"

#: eval.d:1945
msgid "FUNCTION: too long variable specification after &OPTIONAL: ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &OPTIONAL: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:1986
msgid "FUNCTION: &REST var must be followed by &KEY or &AUX or end of list: ~"
msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~"

#
# Igualmente: "FUNCTION: &REST debe ir seguido de una variable: ~" - lsg
#
# Pues si, es que cuando uno está mucho tiempo traduciendo del inglés,
# llega un momento en que empieza coger los hábitos de ese lenguaje y
# empieza a expresarse de una manera extraña, ... - cll
#
#: eval.d:1991
msgid "FUNCTION: &REST must be followed by a variable: ~"
msgstr "FUNCTION: &REST debe ir seguido de una variable: ~"

#: eval.d:2042
#, fuzzy
msgid "FUNCTION: ~ in ~ is not a symbol"
msgstr "FUNCTION: ~ en ~ no es una palabra clave"

#: eval.d:2098
msgid "FUNCTION: incorrect variable specification after &KEY: ~"
msgstr "FUNCTION: especificación de variable incorrecta después de &KEY: ~"

#
# Y de nuevo "FUNCTION: &ALLOW-OTHER-KEYS debe ir seguido de &AUX o del
# final de lista: ~" - lsg
#
# Pues si, :) - cll
#
#: eval.d:2105
msgid "FUNCTION: &ALLOW-OTHER-KEYS must be followed by &AUX or end of list: ~"
msgstr "FUNCTION: &ALLOW-OTHER-KEYS debe ir seguido por &AUX o el fin de lista: ~"

#: eval.d:2140
msgid "FUNCTION: too long variable specification after &AUX: ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~"

#: eval.d:2163
msgid "FUNCTION: badly placed lambda-list keyword ~: ~"
msgstr "La palabra clave ~ de la lista lambda está mal situada: ~"

# Sugerencia: may not -> no puede. sv
# Sugerencia: comerse el "y por ello". sv
#: eval.d:2168
msgid "FUNCTION: ~ is not a symbol, may not be used as a variable"
msgstr "FUNCTION: ~ no es un símbolo, no puede usarse como una variable"

# me comería el "y por ello", todo el mundo lo entenderá, y además no
# está en el original. sv
#
# No sólo eso, sino que además el mensaje queda demasiado largo. Será
# mucho más cómodo, para quien esté trabajando, ver mensajes cortos,
# ... sugerencia aceptada. cll
#
#: eval.d:2173
msgid "FUNCTION: ~ is a constant, may not be used as a variable"
msgstr "FUNCTION: ~ es una constante, no puede usarse como una variable"

#: eval.d:2180
msgid "FUNCTION: too many parameters in the lambda-list ~"
msgstr "FUNCTION: demasiados parámetros en la lista lambda ~"

#: eval.d:2187
msgid "FUNCTION: a dot in a lambda-list is allowed only for macros, not here: ~"
msgstr "FUNCTION: sólo en las macros se permite utilizar un punto en la lista lambda, no aquí: ~"

#: eval.d:2267
#, fuzzy
msgid "~: ~ is a special form, not a function"
msgstr "APPLY: ~ es una forma especial, no una función"

#: eval.d:2284 symbol.d:31
msgid "~: ~ is a macro, not a function"
msgstr "~: ~ es una macro, no una función"

#: eval.d:2301
msgid "~: the function ~ is undefined"
msgstr "~: la función ~ no está definida"

#: eval.d:2343 sequence.d:1185
msgid "~: ~ is not a function"
msgstr "~: ~ no es una función"

#: eval.d:2404
msgid "EVAL/APPLY: keyword arguments for ~ should occur pairwise"
msgstr "EVAL/APPLY: los argumentos clave de ~ deben aparecer por pares"

#
# 'Se han pasado demasiados argumentos a ~" - lsg
#
# Bueno, tu traducción es absolutamente válido. Tal vez, algo más
# informal que la mía, por aquello de "pasado" en vez de
# "entregado". Bueno, pues si te parece, esta vez lo dejo como lo tenía
# yo - cll
#
#: eval.d:2417 eval.d:2734
msgid "EVAL/APPLY: too many arguments given to ~"
msgstr "EVAL/APPLY: se han entregado demasiados argumentos a ~"

#: eval.d:2432
#, fuzzy
msgid "EVAL/APPLY: ~ is not a symbol"
msgstr "EVAL/APPLY: ~ no es una palabra clave"

#: eval.d:2458
msgid "EVAL/APPLY: keyword ~ is illegal for ~. The possible keywords are ~"
msgstr "EVAL/APPLY: el argumento clave ~ es inválido en ~. Los posibles argumentos clave son ~"

#
# "EVAL/APPLY: no se han pasado suficientes argumentos a ~" - lsg
#
# Hmmm, ... Si me gusta, es más "explicativo". Si, me gusta, si, si
# Lo único que te trastoco es lo de "pasado" por "entregado". Ya sabes,
# un toque de distinción :) - cll
#
#: eval.d:2652
msgid "EVAL/APPLY: too few arguments given to ~"
msgstr "EVAL/APPLY: no se han entregado suficientes argumentos a ~"

#
# "EVAL: la variable ~ no tiene asignado ningún valor" - lsg
#
# Bueno, he quitado lo de "asignado" porque parece de "perogrullo", pero
# lo demás se queda - cll
#
#: eval.d:3163
msgid "EVAL: variable ~ has no value"
msgstr "EVAL: la variable ~ no tiene ningún valor"

#: eval.d:3188
msgid "EVAL: illegal form ~"
msgstr "EVAL: forma ~ inválida"

#: control.d:105 eval.d:3267 eval.d:4291 eval.d:5219
msgid "~: ~ is not a function name"
msgstr "~: ~ no es el nombre de una función"

# "EVAL: no se han pasado suficientes argumentos a la forma especial ~:~" - lsg
#
# Bueno, pues te digo lo mismo que en el mensaje eval.d:2572, ... - cll
#
#: eval.d:3346
msgid "EVAL: too few parameters for special-form ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a la forma especial ~: ~"

#
# "Se han pasado demasiados parámetros a la forma especial ~: ~" - lsg
#
# O sea, que quite lo de "para" y ponga "a". Pues vale, tienes toda la
# razón del mundo - cll
#
#: eval.d:3360
msgid "EVAL: too many parameters for special-form ~: ~"
msgstr "EVAL: se han entregado demasiados parámetros a la forma especial ~: ~"

#: eval.d:3373
msgid "EVAL: dotted parameter list for special form ~: ~"
msgstr "EVAL: la lista de parámetros para la forma especial ~ está punteada: ~"

#
# "EVAL: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Una vez más, te digo lo mismo que en el mensaje eval.d:2572 - cll
#
#: eval.d:3440
msgid "EVAL: too few arguments given to ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a ~: ~"

#
# "Se han pasado demasiados argumentos a ~: ~" - lsg
#
# Me gusta más "entregado" que "pasado" - cll
#
#: eval.d:3453
msgid "EVAL: too many arguments given to ~: ~"
msgstr "EVAL: se han entregado demasiados argumentos a ~: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: eval.d:3466
msgid "EVAL: argument list given to ~ is dotted: ~"
msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#: eval.d:4304
msgid "APPLY: argument list given to ~ is dotted"
msgstr "APPLY: la lista de argumentos entregada a ~ está punteada"

#
# "Se han pasado demasiados argumentos a ~" - lsg
#
# Una vez más, me gusta más "entregar" que "pasar" - cll
#
#: eval.d:4316
msgid "APPLY: too many arguments given to ~"
msgstr "APPLY: se han entregado demasiados argumentos a ~"

#
# "APPLY: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Pues eso, que me gusta más "entregar" - cll
#
#: eval.d:4328
msgid "APPLY: too few arguments given to ~"
msgstr "APPLY: se han entregado pocos argumentos a ~"

#
# "el símbolo ~ no tiene valor asignado" - lsg
#
# En algún otro sitio ha aparecido algo parecido a esto. Verás, como me
# parece evidente que si un símbolo no tiene valor, es que no tiene
# valor asignado, pues prefiero omitir lo de "asignado" y evitar que el
# usuario lea términos innecesarios - cll
#
#: eval.d:6786 eval.d:6802
msgid "symbol ~ has no value"
msgstr "el símbolo ~ no tiene valor"

#: eval.d:6817
msgid "assignment to constant symbol ~ is impossible"
msgstr "no pueden realizarse asignaciones sobre el símbolo constante ~"

#
# "~: se ha invocado ~ con demasiados argumentos" - lsg
#
# ¡¡¡ Traducción brillantísima !!! Te ha quedado perfecto. Lo que yo había puesto:
#
# "~: se han entregado demasiados argumentos a ~"
#
# queda como más "indio". Tu traducción me encanta - cll
#
#: control.d:2355 eval.d:7443
msgid "~: too many arguments given to ~"
msgstr "~: se ha invocado ~ con demasiados argumentos"

# Duda: tagbody es de muy difícil traducción.
#       Echando un ojo a la traducción en francés me he encontrado con que está
#       tal cual, ... De momento se queda así hasta que otros miembros del
#       equipo decidan cualquier otra cosa, ...
#
# No es que sepa lo que es, pero, si tag es etiqueta, tagbody podría ser
# "el cuerpo de la etiqueta" (¿tiene sentido esto?), con lo cual, una
# posibilidad sería (para simplificar) "el cuerpo de las etiquetas..." sv
#
# Otra de las propuestas a esta cuestión en la lista de correo
# es@li.org, ha sido: "el contenido de las etiquetas ~ ya ha sido
# abandonado". Esta traducción me gusta, ... cll
#
# ( Desafortunadamente, no recuerdo el nombre de la persona que lo
# sugirió, ... cll )
#
# "(~ ~): ya se ha salido del cuerpo de etiquetas ~" - lsg
#
# Debo rendirme a la evidencia, ... La propuesta de Leo, no solo para
# este término sino todos cuanto se refieren a la traducción de `tag' y
# `tagbody' es perfecta y, además, sigue los pasos de la de Santiago, de
# modo que "moción aceptada" :)
#
#: eval.d:7621 eval.d:7658
msgid "(~ ~): the tagbody of the tags ~ has already been left"
msgstr "(~ ~): ya se ha salido del cuerpo de etiquetas ~"

#: control.d:2042 eval.d:7722
msgid "~: there is no CATCHer for tag ~"
msgstr "~: No hay ningún capturador (CATCH) para la etiqueta de salto ~"

#: eval.d:7747
msgid "STACK corrupted"
msgstr "Pila (STACK) corrupta"

#: eval.d:8131
msgid "~: ~ is not a correct index into ~"
msgstr "~: ~ no es un índice correcto en ~"

#: eval.d:8743
msgid "undefined bytecode in ~ at byte ~"
msgstr "Código de octeto ~ indefinido en el octeto ~"

#: eval.d:8753
msgid "too many return values"
msgstr "Demasiados valores devueltos"

#: eval.d:8760
msgid "Corrupted STACK in ~ at byte ~"
msgstr "Pila corrupta en ~ en el byte ~"

#: control.d:63
msgid "~: function name ~ should be a symbol"
msgstr "~: el nombre de la función ~ debe ser un símbolo"

#: control.d:88
msgid "~: undefined function ~"
msgstr "~: la función ~ no está definida"

#: control.d:125
msgid "~: ~ has no dynamic value"
msgstr "~: ~ no tiene ningún valor dinámico"

#
# "~: ~ no tiene una definición global de función " - lsg
#
# Atención, atención ¿qué es global, la definición o la función?
#
# Yo he traducido:
#
# "~: ~ no tiene ninguna definición global de función"
#
# y la traducción francesa dice:
#
# "~ : ~ n'a pas de définition globale de fonction." - cll
#
#: control.d:171 symbol.d:23
msgid "~: ~ has no global function definition"
msgstr "~: ~ no tiene ninguna definición global de función"

#: control.d:257
msgid "~: the value of the constant ~ may not be altered"
msgstr "~: no puede alterarse el valor de la constante ~"

#: control.d:285
msgid "~ called with odd number of arguments: ~"
msgstr "~ invocado con un número impar de argumentos: ~"

#: control.d:295
msgid "dotted list given to ~ : ~"
msgstr "lista punteada entregada a ~: ~"

#: control.d:395
msgid "~: the value of the constant ~ must not be removed"
msgstr "~: no se debe desechar el valor de la constante ~"

#: control.d:420
msgid "~: the special form definition of ~ must not be removed"
msgstr "~: no se debe desechar la definición de la forma especial de ~"

#: control.d:502
msgid "~: doc-strings are not allowed here: ~"
msgstr "~: aquí no se permiten cadenas de documentación: ~"

#: control.d:575
msgid "~: ~ is not a symbol, but was declared SPECIAL"
msgstr "~: ~ no es un símbolo, pero ha sido declarado SPECIAL"

#: control.d:618 control.d:889
msgid "~: illegal variable specification ~"
msgstr "~: especificación inválida de variable ~"

#: control.d:657
#, fuzzy
msgid "~: symbol ~ is declared special and must not be declared a macro"
msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:664
msgid "~: symbol ~ must not be declared SPECIAL and a macro at the same time"
msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:673 control.d:902
msgid "~: ~ is a constant, cannot be bound"
msgstr "~: ~ es una constante, y por ello no puede ligarse"

#: control.d:693
msgid "~: too many variables and/or declarations"
msgstr "~: demasiadas variables y/o declaraciones"

#: control.d:977
msgid "~: ~ is not a function specification"
msgstr "~: ~ no es la especificación de una función"

#: control.d:1142
msgid "~: ~ is not a macro specification"
msgstr "~: ~ no es la especificación de una macro"

#: control.d:1150
msgid "~: macro name ~ should be a symbol"
msgstr "~: el nombre de la macro ~ debe ser un símbolo"

#: control.d:1261
msgid "~: clause ~ should be a list"
msgstr "~: la clausula ~ debe ser una lista"

#: control.d:1294
msgid "~: missing key list: ~"
msgstr "~: falta la lista de claves: ~"

#: control.d:1304
msgid "~: the ~ clause must be the last one"
msgstr "~: la clausula ~ debe ser la última"

#: control.d:1368
msgid "~: the block named ~ has already been left"
msgstr "~: el bloque de nombre ~ ya ha sido abandonado"

#: control.d:1407
msgid "~: no block named ~ is currently visible"
msgstr "~: no hay ningún bloque visible con el nombre ~"

#: control.d:1656
msgid "~: ~ is neither tag nor form"
msgstr "~: ~ no es ni una etiqueta de salto ni una forma"

#: control.d:1702
msgid "~: illegal tag ~"
msgstr "~: etiqueta de salto inválida ~"

#: control.d:1741
msgid "~: tagbody for tag ~ has already been left"
msgstr "~: ya se ha salido del cuerpo de etiquetas de ~"

#: control.d:1756
msgid "~: no tag named ~ is currently visible"
msgstr "~: no hay ninguna etiqueta de salto visible con el nombre ~"

#: control.d:1775
msgid "~: too many values"
msgstr "~: demasiados valores"

#: control.d:1820
msgid "~: too many arguments to ~"
msgstr "~: se han entregado demasiados argumentos a ~"

#: control.d:2083
msgid "Argument ~ is not a macroexpansion environment"
msgstr "El argumento ~ no es un entorno para la expansión de macros"

#: control.d:2151
msgid "declarations ~ are not allowed here"
msgstr "las declaraciones ~ no están permitidas aquí"

#: control.d:2173
msgid "~: ~ evaluated to the values ~, not of type ~"
msgstr "~: La forma ~ ha producido los valores ~, ninguno de los cuales es del tipo ~"

#: control.d:2189
msgid "~: bad declaration ~"
msgstr "~: declaración incorrecta ~"

#: control.d:2302
msgid "~: ~ may not be used as an environment"
msgstr "~: ~ no puede usarse como un entorno"

#: control.d:2450
msgid "no doc-strings allowed here: ~"
msgstr "no se permite la utilización de cadenas de documentación aquí: ~"

#: control.d:2515
msgid "keyword argument list ~ has an odd length"
msgstr "la lista de argumentos clave ~ tiene longitud impar"

#: control.d:2551
msgid "illegal keyword/value pair ~, ~ in argument list. The allowed keywords are ~"
msgstr "par argumento clave/valor inválido ~, ~ en la lista de argumentos. Los parámetros clave permitidos son ~"

#: encoding.d:41
msgid "Character #\\u$$$$ cannot be represented in the character set ~"
msgstr ""

#: encoding.d:220
msgid "character #x$$$$$$$$ in ~ conversion, not a Unicode-16, sorry"
msgstr ""

#: encoding.d:414
msgid "invalid byte #x$$ in ~ conversion, not a Unicode-16"
msgstr ""

#: encoding.d:432
msgid "invalid byte sequence #x$$ #x$$ in ~ conversion"
msgstr ""

#: encoding.d:453
msgid "invalid byte sequence #x$$ #x$$ #x$$ in ~ conversion"
msgstr ""

#: encoding.d:1052
msgid "invalid byte #x$$ in ~ conversion"
msgstr ""

#: encoding.d:1434
#, fuzzy
msgid "~: illegal :CHARSET argument ~"
msgstr "~: argumento :TEST inválido ~"

#: encoding.d:1447
#, fuzzy
msgid "~: illegal :LINE-TERMINATOR argument ~"
msgstr "~: argumento :TEST inválido ~"

#: encoding.d:1459
#, fuzzy
msgid "~: illegal :INPUT-ERROR-ACTION argument ~"
msgstr "~: argumento :DIRECTION inválido ~"

#: encoding.d:1471
#, fuzzy
msgid "~: illegal :OUTPUT-ERROR-ACTION argument ~"
msgstr "~: argumento :DIRECTION inválido ~"

#: encoding.d:1520
#, fuzzy
msgid "~: argument ~ is not a character set"
msgstr "~: el argumento ~ no es un carácter"

#: encoding.d:2110
#, fuzzy
msgid "~: ~ is not a 1:1 encoding"
msgstr "~: ~ no es un registro"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#
#: pathname.d:1170 pathname.d:1221
msgid "~: host should be NIL or a string, not ~"
msgstr "~: el anfitrión debe ser, o bien NIL, o una cadena, pero no ~"

#
# Duda: he traducido hostname por "nombre del `host'". ¿Qué os parece?
#
#: pathname.d:1192 pathname.d:1241
msgid "~: illegal hostname ~"
msgstr "~: nombre de anfitrión inválido ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:1263
msgid "~: host should be NIL, not ~"
msgstr "~: el anfitrión debe ser NIL, no ~"

#: pathname.d:1389
msgid "~: argument should be a string, symbol, file stream or pathname, not ~"
msgstr "~: el argumento debe ser o bien una cadena, o un símbolo, o un flujo de fichero o un PATHNAME pero no ~"

#: pathname.d:1432
msgid "~: filename for ~ is unknown"
msgstr "~: el nombre de fichero de ~ es desconocido"

#: pathname.d:1991 pathname.d:2329
msgid "~: there is no environment variable ~"
msgstr "~: no hay ninguna variable de entorno ~"

#: pathname.d:2272
msgid "~: there is no user named ~"
msgstr "~: no hay ningún usuario con el nombre ~"

#: pathname.d:2672
msgid "~: syntax error in filename ~ at position ~"
msgstr "~: error de sintáxis en el nombre del fichero ~, en la posición ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:2685
msgid "~: hosts ~ and ~ of ~ should coincide"
msgstr "~: los anfitriones ~ y ~ de ~ deben coincidir"

#: pathname.d:2925
msgid "~: argument ~ is not a logical pathname, string, stream or symbol"
msgstr "~: el argumento ~ no es un PATHNAME \"lógica\", una cadena de caracteres, un flujo o un símbolo"

#: pathname.d:2981
msgid "~: endless loop while resolving ~"
msgstr "~: bucle infinito para ~"

#: pathname.d:3003
msgid "~: unknown logical host ~ in ~"
msgstr "~: anfitrión ~ desconocido en ~"

#: pathname.d:3015
msgid "~: No replacement rule for ~ is known."
msgstr "~: No se conoce ninguna regla de sustitución para ~."

#: pathname.d:3420
msgid "~: :VERSION-argument should be NIL or a positive fixnum or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser NIL, un número positivo del tipo fixnum, :WILD o :NEWEST pero no ~"

#: pathname.d:3447
msgid "~: :VERSION-argument should be NIL or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser o bien NIL, o :WILD o :NEWEST, pero no ~"

#: pathname.d:4547
msgid "~: illegal ~ argument ~"
msgstr "~: el argumento de ~ es inválido: ~"

# Duda: Wildcard por comodín, ..., está bien, ¿no?
#
#: pathname.d:4889
msgid "wildcards are not allowed here: ~"
msgstr "Aquí no están permitidos los comodines: ~"

#: pathname.d:4926
msgid "~: argument ~ should be ~, ~, ~, ~, ~, ~ or ~"
msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#: pathname.d:6109
msgid "~: replacement pieces ~ do not fit into ~"
msgstr "~: las piezas de intercambio ~ no caben en ~"

#: pathname.d:6176
msgid "~: ~ is not a specialization of ~"
msgstr "~: ~ no es una especialización de ~"

#: pathname.d:6227
msgid "(~ ~ ~ ~) is ambiguous: ~"
msgstr "(~ ~ ~ ~) es ambiguo: ~"

#: pathname.d:6253
msgid "nonexistent directory: ~"
msgstr "directorio inexistente: ~"

#: pathname.d:6269
msgid "~: File ~ already exists"
msgstr "~: El fichero ~ ya existe"

#: pathname.d:6624 pathname.d:7490
msgid "no directory ~ above ~"
msgstr "no existe el directorio ~ bajo ~"

#: pathname.d:6632
msgid "\"..\\\\\" after \"...\\\\\" is invalid: ~"
msgstr "\"..\\\\\" después de \"...\\\\\" es inválido: ~"

#: pathname.d:6838
msgid "Couldn't access current directory"
msgstr "No se pudo acceder al directorio actual"

#: pathname.d:6992
msgid "~: ~ names a file, not a directory"
msgstr "~: ~ es el nombre de un fichero, no de un directorio"

#: pathname.d:7043 pathname.d:7242 pathname.d:7612
msgid "~: ~ names a directory, not a file"
msgstr "~: ~ es el nombre de un directorio, no de un fichero"

# Casi lo mismo. Bueno, al menos aquí hay dos puntos. sv
#
# Tienes razón. Ahora que veo este mensaje me lío a poner dos puntos en
# los mensajes anteriores. cll
#
#: pathname.d:7089
msgid "UNIX error while GETWD: ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Si la tildecilla se sustituye por aquello que devolvió la orden GETWD,
# la frase resultante no tiene mucho sentido.
# Sugerencia: "La ejecución de GETWD en Unix devolvió ~" sv
#
# Hmmm, ..., podría ser, pero verás: en primer lugar, el texto que está
# asociado con la etiqueta "UNIX GETWD returned ~" es "UNIX error while
# GETWD" (fichero pathname.d, línea 6176); segundo, en CLisp se sigue la
# convención de colocar primero un mensaje y después, al final, aquello
# que originó el mensaje y, francamente, no quiero cambiar esta
# convención. Es decir, no quiero faltar al estilo original de los
# autores del programa. cll
#
# Por este motivo, creo que lo más conveniente es dejarlo como está. cll
#
#: pathname.d:7098
msgid "UNIX GETWD returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Lo mismo. sv
#
# Lo mismo también ;) cll
#
#: pathname.d:7198
msgid "UNIX REALPATH returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de REALPATH: ~"

#: pathname.d:7424
msgid "~: If a device is specified, the directory must begin with ~: ~"
msgstr "~: Si se especifica un dispositivo, el directorio debe comenzar con ~: ~"

#: pathname.d:7827
msgid "no file name given: ~"
msgstr "no se ha entregado ningún nombre de fichero: ~"

#: pathname.d:7841
msgid "not a directory: ~"
msgstr "no es un directorio: ~"

#: pathname.d:7910
msgid "~: file ~ does not exist"
msgstr "~: el fichero ~ no existe"

#: pathname.d:7939
msgid "~: pathname with type but without name makes no sense: ~"
msgstr "~: un PATHNAME con tipo, pero sin nombre, no tiene ningún sentido: ~"

#: pathname.d:8171
msgid "cannot delete file ~ since there is file stream open to it"
msgstr "no se puede borrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:8233
msgid "cannot rename file ~ since there is file stream open to it"
msgstr "no se puede renombrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:8829
msgid "file ~ does not exist"
msgstr "el fichero ~ no existe"

#: pathname.d:8835
msgid "a file named ~ already exists"
msgstr "ya existe un fichero con el nombre ~"

#: pathname.d:8894
msgid "~: illegal :DIRECTION argument ~"
msgstr "~: argumento :DIRECTION inválido ~"

#: pathname.d:8923
msgid "~: illegal :IF-EXISTS argument ~"
msgstr "~: argumento :IF-EXISTS inválido ~"

#: pathname.d:8943
msgid "~: illegal :IF-DOES-NOT-EXIST argument ~"
msgstr "~: argumento :IF-DOES-NOT-EXIST inválido ~"

#: pathname.d:10548
msgid "root directory not allowed here: ~"
msgstr "el directorio raíz no está permitido aquí: ~"

# En la lista de "spanglish" pone:
#
# command                 orden, mandato (NO "comando")
#
# Asi que, muchas gracias Santiago por la indicación, ... - cll
#
#: pathname.d:11324 pathname.d:11371 pathname.d:11431
msgid "~: the command should be a string, not ~"
msgstr "~: la orden debe ser una cadena y no ~"

#: pathname.d:11688
msgid "~: library directory is not known, use a command line option to specify it"
msgstr ""

# Duda: En este mensaje, el primer "~" se sustituye por el nombre de una
# función y el segundo "~" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: stream.d:222 stream.d:16362
msgid "~ on ~ is illegal"
msgstr "~ no es posible sobre el flujo ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#: stream.d:508 stream.d:719
#, fuzzy
msgid "Return value ~ of call to ~ should be an integer between ~ and ~."
msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

#: stream.d:618
msgid "~: the last character read from ~ was not ~"
msgstr "~: el último carácter leído de ~ no era ~"

# Duda: A continuación vienen muchos mensajes que empiezan por "~ from
# ~". Para ayudar en su trabajo a quienes estén revisando este trabajo
# (no me canso de darte las gracias, Santiago, ..., y a quienes se
# animen) aclaro que el primer "~" se sustituye por el nombre de una
# función cuya evaluación (o ejecución, pero esto no es correcto en
# Lisp, ... se prefiere el término evaluación porque se está a nivel de
# intérprete) produce el error; el segundo "~" se refiere al nombre del
# flujo desde el cual se leyó dicha función. Luego, a continuación,
# viene el mensaje de error propiamente dicho.
#
# Por ejemplo, la siguiente instrucción en CLisp:
#
# > (read)
#
# ..., si se teclea:
#
# #<...>
#
# ..., produce el siguiente error: (en español, ya traducido)
#
# *** - READ en #<TERMINAL-STREAM>: los objetos escritos de la manera
# #<...> no pueden volverse a leer
#
# ¿De acuerdo?
#
# A continuación reproduzco un par de mails donde se explica el
# mecanismo general de estos mensajes, a propósito de la pregunta que
# puse en la lista de correo de CLisp:
#
# Mi pregunta fue:
#
# > 21. There are a few messages which begin with "~ from ~". They are
# > very easy to translate but they use a lot of prepositions, and words
# > that could be translated in masculine or feminine. So, I need some
# > real examples of their use.
#
# Las respuestas fueron:
#
#
# ---------------------------------------------------------------------------
# Look in io.d:
#     { pushSTACK(*stream_); # Wert fu:r Slot STREAM von STREAM-ERROR
#       pushSTACK(ch); # Character
#       pushSTACK(*stream_); # Stream
#       pushSTACK(S(read));
#       //: DEUTSCH "~ von ~: Gelesenes Zeichen ist kein String-Char: ~"
#       //: ENGLISH "~ from ~: character read should be a string-char: ~"
#       //: FRANCAIS "~ de ~ : le caracte!re lu n'est pas de type STRING-CHAR."
# The first ~ is the function name, the second the stream that was being
# read from or written to and the third is the character that was read/written.
#
# So it says something like "READ from #<STREAM ...>: illegal character"
#
# 						(Joerg Hoehle)
#
# ---------------------------------------------------------------------------
# A general question here: I thought gettext was coming with an Emacs
# mode called "po-mode", which helps you in translating the messages.
# In particular, there are keystroke commands for showing the C/Lisp source
# surrounding the original reference to a message. From this context,
# you should at least be able to guess the meaning of the objects which
# are substituted for the ~. Note, however, that the first ~ corresponds
# the last pushSTACK command before the string, the second ~ to the
# second-to-last pushSTACK command etc.
#
# 						(Bruno Haible)
#
# ---------------------------------------------------------------------------
#
#: stream.d:626
msgid "~ from ~ without ~ before it"
msgstr "~ en ~ sin ~ antes de él"

#: stream.d:896
msgid "~: cannot output to ~"
msgstr "~: no se puede escribir en ~"

#: stream.d:912
msgid "~ is not a character, cannot be output onto ~"
msgstr "~ no es un carácter, no puede escribirse en ~"

#: stream.d:928
msgid "~ is not an integer, cannot be output onto ~"
msgstr "~ no es un entero, no puede escribirse en ~"

#: stream.d:943
msgid "integer ~ is out of range, cannot be output onto ~"
msgstr "el entero ~ está fuera del dominio, no puede imprimirse en ~"

#: stream.d:996
#, fuzzy
msgid "~: argument ~ should be an input stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: stream.d:1014
#, fuzzy
msgid "~: argument ~ should be an output stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: stream.d:1337
msgid "~: argument should be a symbol, not ~"
msgstr "~: el argumento debe ser un símbolo, no ~"

#: stream.d:2335 stream.d:2828
msgid "~ is beyond the end because the string ~ has been adjusted"
msgstr "~ está más allá del final porque la cadena ~ ha sido ajustada"

#: stream.d:2466
msgid "~: ~ is not a string input stream"
msgstr "~: ~ no es un flujo de entrada de cadenas de caracteres"

#: charstrg.d:3009 stream.d:2559
#, fuzzy
msgid "~: ~ argument must be a subtype of ~, not ~"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: stream.d:2596
msgid "~: ~ is not a string output stream"
msgstr "~: ~ no es un flujo de salida de cadenas de caracteres"

# Duda: He traducido `fill pointer' por "puntero de relleno". En
# realidad, los `fill-pointer' son exactamente, eso:
#
# "The fill pointer constitutes the "active length" of the vector; all
# vector elements whose index is less than the fill pointer are active,
# and the others are inactive." (Guy L. Steele, Jr; Common Lisp, The
# Language - 2nd Edition; pag. 454).
#
#: stream.d:2638
msgid "~: argument ~ should be a string with fill pointer"
msgstr "~: El argumento ~ debe ser una cadena con un puntero de relleno"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:2940
msgid "~: ~ is not a buffered input stream"
msgstr "~: ~ no es un flujo de entrada con buffer"

#: stream.d:3267
msgid "~: stream must be a generic-stream, not ~"
msgstr "~: el flujo debe ser un `generic-stream', no ~"

#: stream.d:3359
#, fuzzy
msgid "~: illegal :BUFFERED argument ~"
msgstr "~: argumento :TEST inválido ~"

#: stream.d:3475 stream.d:18275
msgid "~: illegal :ELEMENT-TYPE argument ~"
msgstr "~: argumento :ELEMENT-TYPE inválido ~"

#: stream.d:3545
#, fuzzy
msgid "~: illegal :EXTERNAL-FORMAT argument ~"
msgstr "~: argumento :TEST inválido ~"

#: stream.d:3980
msgid "~: Ctrl-C: User break"
msgstr "~: Ctrl-C: Interrupción del usuario"

#: stream.d:4032
#, fuzzy
msgid "unknown character set ~"
msgstr "Registro desconocido: ~S"

#: stream.d:6329
msgid "Unbuffered streams need an ~ with a bit size being a multiple of 8, not ~"
msgstr ""

#: stream.d:6721
msgid "Closed ~ because disk is full."
msgstr "Se ha cerrado ~ porque el disco está lleno."

#: stream.d:6909
msgid "cannot position ~ beyond EOF"
msgstr "no es posible colocarse en ~ más allá de EOF"

# Duda: lo del fichero `regular' por `normal'. De hecho, yo juraría que
# en la asignatura de Sistemas Operativos, en mi Facultad, los
# llamábamos "ficheros normales". ¿Qué tal os suena?.
#
#: stream.d:8521
#, fuzzy
msgid "~: argument ~ ~ was specified, but ~ is not a regular file."
msgstr "~: ~ no es un fichero normal."

#: stream.d:8556
msgid "~: arguments ~ ~ and ~ ~ were specified, but ~ is not a regular file."
msgstr ""

# Duda: aqui he traducido de la version francesa (no se frances, pero
# por lo que parece que pone, ...)
#
#: stream.d:8618
msgid "file ~ is not an integer file"
msgstr "el fichero ~ no tiene el formato de un fichero de enteros"

#: stream.d:10523
msgid "character ~ contains bits, cannot be output onto ~"
msgstr "el carácter ~ contiene bits, que no pueden imprimirse en ~"

# Duda: Aunque RAW significa `crudo', y `modo crudo' es una expresión
# muy conocida en español, lo dejo como RAW (y en mayúsuculas), para que
# quede claro que me refiero a la palabra reservada RAW (igual que
# ocurre en la versión original)
#
#: stream.d:11262
msgid "RAW mode not supported on ~"
msgstr "Modo RAW no soportado en ~"

#: stream.d:11694
msgid "~: argument ~ should be a window stream"
msgstr "~: el argumento ~ debe ser un WINDOW-STREAM"

#: stream.d:12557
msgid "cannot output to standard output"
msgstr "no se puede escribir en la salida estándar"

#: stream.d:13953
msgid "environment has no TERM variable"
msgstr "no existe ninguna variable de entorno TERM"

#: stream.d:13958
msgid "terminal type ~ unknown to termcap"
msgstr "No existe ninguna entrada para el tipo de terminal ~ en termcap"

# Duda: Juan Jordana (de la lista de CLisp) propone usar la expresión:
#
# 	Terminal incompleta (o errónea): Terminal de impresora.
#
# 	y me gusta, salvo que prefiero decir a continuación algo del
# 	tipo "usando el modo de impresora" o algo así, ¿no os parece
# 	mejor?
#
#: stream.d:13983
msgid "insufficient terminal: hardcopy terminal"
msgstr "terminal insuficiente: usando el modo de impresora"

# Duda: ¿Pues qué voy a decir? La traducción siguiente es una auténtica
# traducción libre. De todos modos, tanto la versión francesa como la
# alemana (aunque no sé ni alemán ni francés) hacen ---por lo visto---,
# lo que yo: una traducción libre.
#
#: stream.d:13987
msgid "insufficient terminal: overstrikes, cannot clear output"
msgstr "teminal insuficiente: no se puede inicializar la salida"

#: stream.d:13991
msgid "insufficient terminal: cannot scroll"
msgstr "terminal insuficiente: no se puede desplazar la pantalla"

#: stream.d:13996
msgid "insufficient terminal: cannot clear screen"
msgstr "terminal insuficiente: no se puede borrar la pantalla"

#: stream.d:14000
msgid "insufficient terminal: cannot position cursor randomly"
msgstr "terminal insuficiente: no se puede situar el cursor aleatoriamente"

#: stream.d:14512
msgid "~: package SCREEN is not implemented"
msgstr "~: el paquete SCREEN no está implementado"

# Duda: he dejado `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: stream.d:16024
msgid "host should be string, not ~"
msgstr "el anfitrión debe ser una cadena de caracteres y no ~"

# Duda: Pues otra vez como siempre, ..., he dejado `display' tal
# cual. Pienso que todo el mundo sabe lo que es un `display' ¿no?
#
# Por otra parte (como ya sucedió en un mensaje anterior), ..., `fixnum'
# por ser el nombre de un subtipo (o tipo, si se quiere) en Lisp, está
# sin traducir, ...
#
#: stream.d:16032
msgid "display should be a nonnegative fixnum, not ~"
msgstr "el `display' debe ser un entero del tipo FIXNUM >=0, y no ~"

#: stream.d:16074 stream.d:16126
msgid "~: stream must be a socket-stream, not ~"
msgstr "~: el flujo debe ser un `socket-stream' y no ~"

#: stream.d:16139
msgid "~: argument ~ should be a vector of type (ARRAY (UNSIGNED-BYTE 8) (*))"
msgstr "~: el argumento ~ debe ser un vector del tipo (ARRAY (UNSIGNED-BYTE 8) (*)) "

#: io.d:1042 stream.d:16163 stream.d:18317 stream.d:18538 stream.d:18618
msgid "~: input stream ~ has reached its end"
msgstr "~: el flujo de entrada ~ ha alcanzado su final"

#: stream.d:16355
msgid "~: ~ is not a SOCKET-SERVER"
msgstr "~: ~ no es un SOCKET-SERVER"

#: stream.d:16421
#, fuzzy
msgid "~: argument ~ is neither an open SOCKET-STREAM nor a positive FIXNUM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:16608
#, fuzzy
msgid "~: argument ~ is not an open SOCKET-STREAM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:16621
msgid "~: argument ~ is not a SOCKET-STREAM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:16862
msgid "The value of ~ is not a stream: ~"
msgstr "El valor de ~ no es un flujo: ~"

#: stream.d:16866
msgid "The value of ~ is not an appropriate stream: ~"
msgstr "El valor de ~ no es un flujo apropiado: ~"

#: stream.d:16880
msgid "The value of ~ was not a stream: ~. It has been changed to ~."
msgstr "El valor de ~ no era un flujo: ~. Ha sido cambiado por ~."

#: stream.d:16899
msgid "readline library: out of memory."
msgstr "biblioteca readline: la memoria ha sido agotada."

#: stream.d:17130
#, fuzzy
msgid "~: The ~ of ~ cannot be changed from ~ to ~."
msgstr "~: ~ no puede convertirse al tipo ~"

#: stream.d:17756
#, fuzzy
msgid "Return value ~ of call to ~ is not a string."
msgstr "El valor de ~ no es un flujo: ~"

#: stream.d:18215
msgid "Return value ~ of call to ~ is not a fixnum >= 0 or NIL."
msgstr ""

#: stream.d:18234
msgid "~ needs an ~ with a bit size being a multiple of 8, not ~"
msgstr ""

#: stream.d:18296
#, fuzzy
msgid "~: illegal endianness argument ~"
msgstr "~: el argumento de ~ es inválido: ~"

#: stream.d:18861 stream.d:18873
#, fuzzy
msgid "~ is not a ~, cannot be output onto ~"
msgstr "~ no es un entero, no puede escribirse en ~"

#: stream.d:18960
msgid "~: argument ~ is not an open file stream"
msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#: stream.d:18994
#, fuzzy
msgid "~: position argument should be ~ or ~ or a nonnegative integer, not ~"
msgstr "~: el argumento de posición debe ser ~, ~ o un número no negativo del tipo FIXNUM, pero no ~"

#: socket.d:984
#, fuzzy
msgid "~: ~"
msgstr "~: incorrecto ~"

#: io.d:484
msgid "The value of ~ was not a readtable. It has been reset."
msgstr "El valor de ~ no es una tabla de lectura. Ha sido inicializado/a."

#: io.d:570
msgid "~: argument ~ is not a readtable"
msgstr "~: el argumento ~ no es una tabla de lectura"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
# Al final, por iniciativa de Leo, he cambiado `# macro carácter', que
# no me gustaba demasiado por `macro carácter secundario', que me parece
# mucho mejor. - cll
#
#: io.d:773
msgid "~: ~ is a dispatch macro character"
msgstr "~: ~ es un macro carácter secundario"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:838
msgid "~: ~ is not a dispatch macro character"
msgstr "~: ~ no es un macro carácter secundario"

#: io.d:867
msgid "~: digit $ not allowed as sub-char"
msgstr "~: el dígito $ no está permitido como un sub-carácter"

#: io.d:917
msgid "~: new value ~ should be ~, ~, ~ or ~."
msgstr "~: el nuevo valor ~ debe ser ~, ~, ~ o ~."

#: io.d:954
msgid ""
"The value of ~ should be an integer between 2 and 36, not ~.\n"
"It has been reset to 10."
msgstr ""
"El valor de ~ debe ser un entero entre 2 y 36, no ~.\n"
"Ha sido inicializado a 10."

#: io.d:1005
#, fuzzy
msgid "~ from ~: character read should be a character: ~"
msgstr "~ en ~: el carácter leído debe ser un STRING-CHAR: ~"

#: io.d:1059
msgid "~: input stream ~ ends within an object. Last opening parenthesis probably in line ~."
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto. El último paréntesis abierto es, probablemente, el de la línea ~."

#: io.d:1065
msgid "~: input stream ~ ends within an object"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto"

#: io.d:1374
msgid "~ from ~: illegal character ~"
msgstr "~ en ~: carácter inválido ~"

#
# Duda: Lo mismo de antes, he dejado `token' sin traducir
#
#: io.d:1387
msgid "~: input stream ~ ends within a token after single escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape simple"

#
# Duda: A ver, ¿la palabra `token'?
#       Mientras no se os ocurra algo mejor, lo he dejado en inglés, ...
#
#: io.d:1435
msgid "~: input stream ~ ends within a token after multiple escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape múltiple"

#: io.d:2017
msgid "~ from ~: ~ has no macro character definition"
msgstr "~ en ~: ~ no tiene ninguna definición de macro carácter"

#: io.d:2031
msgid "~ from ~: macro character definition for ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter para ~ no puede devolver ~ valores, sólo puede ser uno."

#: io.d:2055
msgid "~: input stream ~ ends within read macro beginning to ~"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba una macro de lectura en ~"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:2089
msgid "~ from ~: After ~ is ~ an undefined dispatch macro character"
msgstr "~ en ~: Después de ~ está ~, que no es un macro carácter secundario"

#: io.d:2103
msgid "~ from ~: dispatch macro character definition for ~ after ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter secundario de ~ después de ~ sólo puede devolver un valor, no ~"

# Duda: He traducido `token' tal cual, ... Santiago, imagino que la
# palabra token se queda tal cual. Quiero decir, ¿es necesario lo de las
# comillas? - cll
#
#: io.d:2179
msgid "~ from ~: a token consisting only of dots cannot be meaningfully read in"
msgstr "~ en ~: no puede leerse correctamente un `token' que consiste únicamente en puntos"

# Duda: Todo el mundo sabe que `colon' es el signo de dos puntos
# `:'. Bueno, pues la traducción del siguiente mensaje podría ser algo
# del estilo: "demasiados signos de dos puntos en el token ...", sin
# embargo, me ha parecido mejor poner los dos puntos directamente, ...
#
#: io.d:2284
msgid "~ from ~: too many colons in token ~"
msgstr "~ en ~: demasiados `:' en el `token' ~"

#: io.d:2334
msgid "~ from ~: there is no package with name ~"
msgstr "~ en ~: no existe ningún paquete con el nombre ~"

#: io.d:2363
msgid "~ from ~: ~ has no external symbol with name ~"
msgstr "~ en ~: ~ no tiene ningún símbolo externo con el nombre ~"

#: io.d:2411
msgid "~ from ~: token \".\" not allowed here"
msgstr "~ en ~: el `token' \".\" no está permitido aquí"

#: io.d:2465 io.d:6589
msgid "~: the value of ~ has been arbitrarily altered"
msgstr "~: el valor de ~ ha sido arbitrariamente alterado"

#: io.d:2481
msgid "~: no entry for ~ from ~ in ~ = ~"
msgstr "~: no existe ninguna entrada para ~ de ~ en ~ = ~"

#: io.d:2692
msgid "~ from ~: illegal end of dotted list"
msgstr "~ en ~: fin de lista punteada inválido"

#: io.d:2768
msgid "~ from ~: an object cannot start with ~"
msgstr "~ en ~: un objeto no puede comenzar por ~"

#: io.d:2859
msgid "~: input stream ~ ends within a string"
msgstr "~: el flujo de entrada ~ termina con una cadena"

#: io.d:2925
msgid "~ from ~: no number allowed between # and $"
msgstr "~ en ~: no debe haber ningún número entre # y $"

#: io.d:3024
msgid "~: input stream ~ ends within a comment #$ ... $#"
msgstr "~: el flujo de entrada ~ termina dentro un comentario #$ ... $#"

#: io.d:3106
#, fuzzy
msgid "~ from ~: font number ~ for character is too large, should be = 0"
msgstr "~ en ~: el número ~ para la fuente de caracteres es demasiado grande, debe ser < ~"

# Duda: Vamos a ver, ... porque esto es muy curioso, ... En Common Lisp,
# los caracteres tienen tres atributos (Common Lisp, The Language, 2nd
# Edition - Guy L. Steel, página 374): código, bits y fuente. El
# atributo "bits" se refiere a otras señales que se pueden activar por
# la pulsación simultánea de varias teclas (o sea, el Control, Mays,
# etc.) Para identificar convenientemente las pulsaciones simultáneas de
# teclas con las que se conocen como teclas de control, existen
# "nombres" (he aquí el quiz de la cuestión, ...) para referirse a
# dichas combinaciones.
#
# Bueno, pues este es, entonces, el problema para traducir "character
# bit with name". La verdad, no me extraña que los indios hablasen como
# hablaban, ... esto no puede ser más críptico :)
#
# Yo he optado por "nombre para los bits de carácter", ... ¿qué os
# parece? - cll
#
#: io.d:3139
msgid "~ from ~: there is no character bit with name ~"
msgstr "~ en ~: no hay ningún nombre para los bits de carácter que sea ~"

#: io.d:3206
msgid "~ from ~: there is no character with name ~"
msgstr "~ en ~: no hay ningún carácter con el nombre ~"

#: io.d:3269
msgid "~ from ~: token ~ after #$ is not a rational number in base ~"
msgstr "~ en ~: el `token' ~ después de #$ no es un número racional en base ~"

#: io.d:3348
msgid "~ from ~: the number base must be given between # and R"
msgstr "~ en ~: el número de la base debe estar entre # y R"

#: io.d:3363
msgid "~ from ~: The base ~ given between # and R should lie between 2 and 36"
msgstr "~ en ~: La base ~ entre # y R debe estar entre 2 y 36"

#: io.d:3411
msgid "~ from ~: bad syntax for complex number: #C~"
msgstr "~ en ~: sintaxis incorrecta del número complejo: #C~"

#: io.d:3446
msgid "~ from ~: token expected after #:"
msgstr "~ en : ~: se esperaba un `token' después de #:"

#: io.d:3475
msgid "~ from ~: token ~ after #: should contain no colon"
msgstr "~ en ~: el `token' ~ después de #: no debe contener dos puntos"

#: io.d:3528
msgid "~ from ~: only zeroes and ones are allowed after #*"
msgstr "~ en ~: sólo se permiten ceros y unos después de #*"

#: io.d:3557
msgid "~ from ~: bit vector is longer than the explicitly given length ~"
msgstr "~ en ~: la longitud del vector de bits es mayor que la longitud explícitamente indicada ~"

#: io.d:3566
msgid "~ from ~: must specify element of bit vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de bits de longitud ~"

#: io.d:3646
msgid "~ from ~: vector is longer than the explicitly given length ~"
msgstr "~ en ~: el vector tiene una longitud mayor que la explícitamente indicada ~"

#: io.d:3655
msgid "~ from ~: must specify element of vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de longitud ~"

#: io.d:3740
msgid "~ from ~: bad syntax for array: #A~"
msgstr "~ en ~: sintaxis incorrecta en la matriz: #A~"

#: io.d:3806
msgid "~ from ~: ~ = ~ doesn't allow the evaluation of ~"
msgstr "~ en ~: ~ = ~ no permite la evaluación de ~"

#: io.d:3933
msgid "~ from ~: a number must be given between # and $"
msgstr "~ en ~: debe indicarse un número entre # y $"

#: io.d:3945
msgid "~ from ~: label #~? too large"
msgstr "~ en ~: la etiqueta #~? es demasiado grande"

# Duda: En Common Lisp existe lo que se denominan "Listas de asociación"
# (Common Lisp, The Language, 2nd Edition - Guy L. Steel, página 431) o,
# en inglés, "Association Lists" que abreviadamente se conocen como
# "alist" o "a-list". En realidad, aunque en español, mucha gente dice
# "alistas", esto no me parece correcto y me parece mucho más formal
# decir "listas de asociación".
#
# De hecho, el término "listas de asociación" será facílisimamente
# reconocible por el programador, mientras que "alista" exige estar un
# poquito más experimentado con el Lisp.
#
# Más aún, los traductores del libro "Lisp" (3ra edición) de Winston y
# Horn, utilizan la expresión "lista de asociación" en la presentación
# de la función ASSOC en la página 34, aunque luego también se refieran
# a ellas como "listas-a".
#
#: io.d:3967
msgid "~ from ~: the value of ~ has been altered arbitrarily, it is not an alist: ~"
msgstr "~ en ~: el valor de ~ ha sido modificado arbitrariamente, no es una lista de asociación: ~"

#: io.d:3987
msgid "~ from ~: label #~= may not be defined twice"
msgstr "~ en ~: la etiqueta #~= no puede definirse dos veces"

#: io.d:4014
msgid "~ from ~: #~= #~# is illegal"
msgstr "~ en ~: #~= #~# no está permitido"

#: io.d:4042
msgid "~ from ~: undefined label #~#"
msgstr "~ en ~: la etiqueta #~# no está definida"

#: io.d:4059
msgid "~ from ~: objects printed as #<...> cannot be read back in"
msgstr "~ en ~: los objetos escritos de la manera #<...> no pueden volverse a leer"

#: io.d:4077
msgid "~ from ~: objects printed as # in view of ~ cannot be read back in"
msgstr "~ en ~: los objetos escritos como # a causa de ~ no pueden volverse a leer"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#: io.d:4159
msgid "~ from ~: illegal feature ~"
msgstr "~ en ~: propiedad inválida ~"

#: io.d:4295
msgid "~ from ~: #S must be followed by the type and the contents of the structure, not ~"
msgstr "~ en ~: #S debe estar seguido del tipo y contenidos de la estructura, no ~"

#: io.d:4308
msgid "~ from ~: the type of a structure should be a symbol, not ~"
msgstr "~ en ~: el tipo de una estructura debe ser un símbolo, no ~"

#: io.d:4322
msgid "~ from ~: bad HASH-TABLE"
msgstr "~ en ~: HASH-TABLE incorrecta"

#: io.d:4349
msgid "~ from ~: bad ~"
msgstr "~ en ~: ~ es incorrecto"

#: io.d:4381
msgid "~ from ~: no structure of type ~ has been defined"
msgstr "~ en ~: no se ha definido ninguna estructura del tipo ~"

#: io.d:4392
msgid "~ from ~: bad ~ for ~"
msgstr "~ en ~: ~ es incorrecto en ~"

#: io.d:4404
msgid "~ from ~: structures of type ~ cannot be read in, missing constructor function"
msgstr "~ en ~: las estructuras del tipo ~ no pueden leerse, no se conoce la función de construcción"

#: io.d:4426
msgid "~ from ~: a structure ~ may not contain a component \".\""
msgstr "~ en ~: una estructura ~ no debe contener un componente \".\""

#: io.d:4438
msgid "~ from ~: ~ is not a symbol, not a slot name of structure ~"
msgstr "~ en ~: ~ no es un símbolo, ni el nombre de una ranura ni una estructura ~"

#: io.d:4448
msgid "~ from ~: missing value of slot ~ in structure ~"
msgstr "~ en ~: falta el valor de la ranura ~ en la estructura ~"

#
# Duda: slots se queda tal cual, ...
#
# De acuerdo con la lista spanglish, `slot' se traducirá, en todo el
# CLisp, como "ranura".
#
#: io.d:4470
msgid "~ from ~: too many slots for structure ~"
msgstr "~ en ~: hay demasiadas ranuras en la estructura ~"

#
# "~ en ~: sintaxis inválida del vector de código de recinto tras #~Y" - lsg
#
# Hmmm, no me acaba de gustar, ... - cll
#
#: io.d:4517
msgid "~ from ~: illegal syntax of closure code vector after #~Y"
msgstr "~ en ~: sintaxis inválida del vector de código de la cerradura después de #~Y"

#: io.d:4572
msgid "~ from ~: object #Y~ has not the syntax of a compiled closure"
msgstr "~ en ~: el objeto #Y~ no tiene la sintaxis de una cerradura compilada"

#
# pathname NO es array!
# "~ en ~: sintaxis incorrecta en nombre de path: #A~" - lsg
#
# Si, es verdad, aquí se me había ido la mano, ...
#
# Además, PATHNAME no se traduce puesto que, o bien se refiere al tipo
# de datos PATHNAME o a la función PATHNAME (en este caso, al tipo de
# datos). Como ambos términos están definidos en el estándar de Common
# Lisp: Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr., pues
# no se traduce y se pone en mayúsculas para distinguirlo de otros
# términos. - cll
#
#: io.d:4718
msgid "~ from ~: bad syntax for pathname: #P~"
msgstr "~ en ~: la sintaxis del PATHNAME: #P~ es incorrecta"

#: io.d:4935 io.d:10217
msgid "~: ~ is not a character"
msgstr "~: ~ no es un carácter"

# Nota: El siguiente mensaje se debe a la función PEEK-CHAR (Common
# Lisp, The Language - 2nd Edition; Guy L. Steele, Jr; pag. 574), que
# realiza la lectura del siguiente objeto de un flujo de caracteres
# según el valor de su primer argumento opcional `peek-type' que solo
# puede valer, como reza el mensaje, NIL, T o un carácter.
#
#: io.d:4981
msgid "~: peek type should be NIL or T or a character, not ~"
msgstr "~: el tipo del PEEK solo puede ser NIL, T o un carácter, y no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#: io.d:5142
msgid "~: ~ argument should be an integer between 2 and 36, not ~"
msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

# "~: la cadena ~ no tiene sintaxis de entero" - lsg
#
# He cambiado lo "de entero" por "de un número entero", que parece más
# inteligible - cll
#
#: io.d:5243
msgid "~: string ~ does not have integer syntax"
msgstr "~: la cadena ~ no tiene la sintaxis de un número entero"

#: io.d:5415
msgid "~: Despite of ~, ~ cannot be printed readably."
msgstr "~: A pesar de ~, ~ no puede imprimirse de manera legible."

#: io.d:5441
msgid ""
"~: the value ~ of ~ is neither ~ nor ~ nor ~.\n"
"It is reset to ~."
msgstr ""
"~: el valor ~ de ~ no es ~ ni ~ ni ~.\n"
"Ha sido inicializado a ~."

#: io.d:5884
msgid "~: must be a positive integer or NIL, not ~"
msgstr "~: debe ser un número positivo entero o NIL, pero no ~"

# "~: espacio insuficiente en la pila para realizar un análisis de circularidad" - lsg
#
# Vale - cll
#
#: io.d:6812
msgid "~: not enough stack space for carrying out circularity analysis"
msgstr "~: no hay espacio suficiente en la pila para realizar un análisis de circularidad"

#: io.d:8500
msgid "~: bad ~"
msgstr "~: incorrecto ~"

#: io.d:8617 record.d:225
msgid "~: ~ is not a structure"
msgstr "~: ~ no es una estructura"

#: io.d:9483
msgid "~: an unknown record type has been generated!"
msgstr "~: se ha generado un tipo de registro desconocido!"

#
# ¡¡Large no es largo, sino grande!! - lsg
#
# Tienes toda la razón, ya lo he cambiado en todos los mensajes - cll
#
#: array.d:228
msgid "index too large"
msgstr "índice demasiado grande"

# FIXME. Esto no cabe en 80 columnas. Comunicar al autor (?) sv
#
# "Una formación ha sido acortada mediante un ajuste al trasladar otra formación hacia ella"
# O bien, para que quepa en 80 columnas:
# "Una formación ha sido acortada al trasladar otra formación hacia ella" - lsg
#
# Yo había puesto:
#
# "Una matriz ha sido acortada debido a un ajuste cuando otra se ha desplazado "
# "hacia ella"
#
# Y ciertamente me gusta más tu traducción, salvo que en vez de
# formaciones hay que hablar de matrices, ¿no crees? - cll
#
#: array.d:237
msgid "An array has been shortened by adjusting it while another array was displaced to it."
msgstr "Una matriz ha sido acortada al trasladar otra matriz ella"

# "~: ~ no es una formación" - lsg
#
# Aunque en la lista de spanglish.txt pone "formación", en este caso
# creo que será mucho más conveniente poner "matriz" porque de hecho,
# los mensajes se refieren a matrices, ... - cll
#
#: array.d:329
msgid "~: ~ is not an array"
msgstr "~: ~ no es una matriz"

#: array.d:364 foreign.d:2273
msgid "~: got ~ subscripts, but ~ has rank ~"
msgstr "~: se encontraron ~ subíndices, pero ~ tiene rango ~"

#: array.d:382 foreign.d:2290
msgid "~: subscripts ~ for ~ are not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: los subíndices ~ de ~ no son del tipo '(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:411 foreign.d:2301
msgid "~: subscripts ~ for ~ are out of range"
msgstr "~: los subíndices ~ de ~ han excedido el rango"

#: array.d:474
msgid "~: index ~ for ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: el índice ~ de ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:495
msgid "~: index ~ for ~ is out of range"
msgstr "~: el índice ~ de ~ ha excedido el rango"

#: array.d:598
msgid "~: ~ does not fit into ~, bad type"
msgstr "~: ~ no cabe en ~, tipo incorrecto"

#: array.d:917
msgid "~: ~ is not an nonnegative integer less than the rank of ~"
msgstr "~: ~ no es un entero no negativo menor que el rango de ~"

#: array.d:1128
msgid "~: ~ is not an array of bits"
msgstr "~: ~ no es una matriz de bits"

#: array.d:1993
msgid "~: The arguments ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:2004
msgid "~: The arguments ~, ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~, ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:3986
msgid "~: vector ~ has no fill pointer"
msgstr "~: el vector ~ no tiene ningún puntero de relleno"

#: array.d:4036
msgid "~: ~ has length zero"
msgstr "~: ~ tiene longitud nula"

#: array.d:4064
msgid "~ works only on adjustable arrays, not on ~"
msgstr "~ funciona sólo con matrices ajustables, no con ~"

#: array.d:4082
msgid "~: extension ~ should be a positive fixnum"
msgstr "~: la extensión ~ debe ser un número positivo del tipo FIXNUM"

#: array.d:4106
msgid "~: extending the vector by ~ elements makes it too long"
msgstr "~: ampliar el vector en ~ elementos, lo hace muy grande"

#: array.d:4178
msgid "~: cannot push ~ into array ~ (bad type)"
msgstr "~: no se puede introducir ~ en la matriz ~ (tipo incorrecto)"

#: array.d:4477
msgid "~: dimension ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: la dimensión ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:4519
msgid "~: dimensions ~ produce too large total-size"
msgstr "~: las dimensiones ~ producen un tamaño total demasiado grande"

#: array.d:4561
msgid "~: ambiguous, more than one initialisation specified"
msgstr "~: ambiguo, se ha especificado más de una inicialización"

#: array.d:4573
msgid "~: ~ must not be specified without ~"
msgstr "~: ~ no debe especificarse sin ~"

#: array.d:4620
msgid "~: the initial-element ~ is not of type ~"
msgstr "~: el INITIAL-ELEMENT ~ no es del tipo ~"

#: array.d:4711
msgid "~: ~ is of incorrect length"
msgstr "~: ~ no tiene la longitud correcta"

#: array.d:4742
msgid "~: ~-argument ~ is not an array"
msgstr "~: El ~ argumento ~ no es una matriz"

#: array.d:4785
msgid "~: ~-argument ~ does not have element type ~"
msgstr "~: El ~ argumento ~ no tiene como tipo de elemento ~"

#: array.d:4802
msgid "~: ~-argument ~ is not of type `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"
msgstr "~: El ~ argumento ~ no es del tipo `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"

#: array.d:4814
msgid "~: array-total-size + displaced-offset (= ~) exceeds total size ~ of ~-argument"
msgstr "~: array-total-size + displaced-offset (= ~) excede el tamaño total ~ del ~ argumento"

#: array.d:4840
msgid "~: fill-pointer ~ should be a nonnegative fixnum"
msgstr "~: El puntero de relleno ~ debe ser un número no negativo del tipo FIXNUM"

#: array.d:4849
msgid "~: fill-pointer argument ~ is larger than the length ~"
msgstr "~: El argumento FILL-POINTER ~ es mayor que la longitud ~"

#
# "~: el rango intentado ~ es demasiado grande" - lsg
#
# De acuerdo - cll
#
#: array.d:4919
msgid "~: attempted rank ~ is too large"
msgstr "~: el rango intentado ~ es demasiado grande"

#: array.d:4933
msgid "~: ~ may not be specified for an array of rank ~"
msgstr "~: ~ no debe especificarse para una matriz de rango ~"

#: array.d:5132
msgid "~: array ~ is not adjustable"
msgstr "~: la matriz ~ no es ajustable"

#: array.d:5155
msgid "~: rank ~ of array ~ cannot be altered: ~"
msgstr "~: no es posible cambiar el rango ~ de la matriz ~: ~"

#
# "~: los elementos de la formación ~ no son de tipo ~" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#: array.d:5171
msgid "~: array ~ does not have element-type ~"
msgstr "~: los elementos de la matriz ~ no son del tipo ~"

#: array.d:5225
msgid "~: cannot displace array ~ to itself"
msgstr "~: no se puede desplazar la matriz ~ hacia ella misma"

#: array.d:5249
msgid "~: array ~ has no fill-pointer"
msgstr "~: la matriz ~ no tiene ningún puntero de relleno"

#: array.d:5264
msgid "~: the fill-pointer of array ~ is ~, greater than ~"
msgstr "~: el puntero de relleno de la matriz ~ es ~ que es mayor que ~"

# ... de la misma forma que uno no pone "START Índice" sv
#
# Si, si, ..., tienes toda la razón, ... cll
#
#: array.d:5415
msgid "Illegal START index ~ for ~"
msgstr "Índice START ~ inválido en ~"

#: array.d:5451
msgid "Illegal END index ~ for ~"
msgstr "Índice END ~ inválido en ~"

#: array.d:5465
msgid "~: invalid bit-vector length ~"
msgstr "~: la longitud de BIT-VECTOR ~ es inválida"

# Duda: hash lo he traducido por hash. ¿Alguna sugerencia? ¿Tablas de
# acceso rápido, o algo así?. Tened en cuenta que en Common Lisp, las
# tablas hash son una estructura bien definida que cuenta con sus
# propias instrucciones. A mí me gusta tal cual, ...
# Sugerencia: tabla de `hash'. sv
#
# No, no, no, no, ... :) `hash table' es `tabla hash'. Si se quiere,
# podríamos traducir la palabra `hash' pero si se deja es `tabla
# hash'. Todos los informáticos las llamamos así. Jamás he oído `Tabla
# *de* hash' cll
#
#: hashtabl.d:1151
msgid "Hash table size ~ too large"
msgstr "La tabla hash ~ es demasiado grande"

#
# "error interno al redimensionar ~" - lsg
#
# Me gusta, salvo que el error ocurre "durante" - cll
#
#: hashtabl.d:1197
msgid "internal error occured while resizing ~"
msgstr "error interno durante el redimensionamiento de ~"

#: hashtabl.d:1308
msgid "~: illegal :TEST argument ~"
msgstr "~: argumento :TEST inválido ~"

#: hashtabl.d:1325
msgid "~: :SIZE argument should be a fixnum >=0, not ~"
msgstr "~: el argumento :SIZE debe ser del tipo FIXNUM >= 0, no ~"

#: hashtabl.d:1348
msgid "~: :REHASH-SIZE argument should be a float > 1, not ~"
msgstr "~: el argumento :REHASH-SIZE debe ser del tipo FLOAT > 1, no ~"

#: hashtabl.d:1393
msgid "~: :REHASH-THRESHOLD argument should be a float between 0 and 1, not ~"
msgstr "~: el argumento :REHASH-THRESHOLD debe ser un número del tipo FLOAT entre 0 y 1, no ~"

#: hashtabl.d:1468
msgid "~: internal error while building ~"
msgstr "~: error interno durante la construcción de ~"

#: hashtabl.d:1512
msgid "~: argument ~ is not a hash-table"
msgstr "~: el argumento ~ no es una tabla hash"

#: list.d:634
msgid "~: ~ is not a nonnegative fixnum and therefore not a valid index"
msgstr "~: ~ no es un FIXNUM no negativo y por ello, no es un índice válido"

#: list.d:730
msgid "~: ~ is not a nonnegative integer and therefore not a valid argument"
msgstr "~: ~ no es un entero no negativo y por ello, no es un argumento válido"

#: list.d:857
msgid "~: ~ is not a nonnegative fixnum and therefore not a valid list length"
msgstr "~: ~ no es un FIXNUM no negativo y por ello, no es una longitud de lista válida"

#: list.d:1166
msgid "~: ~ is not a pair"
msgstr "~: ~ no es un par"

#: list.d:1887
msgid "~: lists ~ and ~ are not of same length"
msgstr "~: las listas ~ y ~ no son de la misma longitud"

#: list.d:2106
msgid "~: index ~ too large for ~"
msgstr "~: el índice ~ es demasiado grande para ~"

#: list.d:2168
msgid "~: start index ~ too large for ~"
msgstr "~: el índice :START ~ es demasiado grande para ~"

#: list.d:2213
msgid "~: end index ~ too large for ~"
msgstr "~: el índice :END ~ es demasiado grande para ~"

#: package.d:358
msgid "symbol ~ cannot be deleted from symbol table"
msgstr "el símbolo ~ no puede ser borrado de la tabla de símbolos"

#: package.d:729
msgid "~ inconsistent: symbol ~ is a shadowing symbol but not present"
msgstr "inconsistencia en ~: el símbolo ~ es un símbolo que eclipsa a otro/s, sin embargo no está presente."

#: package.d:1191
msgid "UNEXPORT in ~ is illegal"
msgstr "UNEXPORT en ~ es inválido"

#
# "UNEXPORT sólo funciona con símbolos accesibles, no con ~ en ~" - lsg
#
# Ya, o sea, que cambie "sobre" por "con". Vale, me gusta mucho más tu
# mensaje que el mío - cll
#
#: package.d:1215
msgid "UNEXPORT works only on accessible symbols, not on ~ in ~"
msgstr "UNEXPORT sólo funciona sobre símbolos accesibles, no con ~ en ~"

#: package.d:1817
msgid "The value of *PACKAGE* was not a package. Old value ~. New value ~."
msgstr "El valor de *PACKAGE* no era un paquete. Valor anterior ~. Nuevo valor ~."

#: package.d:1836
msgid "Package ~ has been deleted."
msgstr "El paquete ~ ha sido borrado."

#: package.d:1846
msgid "There is no package with name ~"
msgstr "No hay ningún paquete con el nombre ~"

#: package.d:1855
msgid "~: argument should be a package or a package name, not ~"
msgstr "~: el argumento debe ser un paquete o el nombre de un paquete, no ~"

#: package.d:1866
msgid "~: argument should be a string, not ~"
msgstr "~: el argumento debe ser una cadena de caracteres, no ~"

#: package.d:1886
msgid "~: argument ~ should be a string or a symbol"
msgstr "~: el argumento ~ debe ser una cadena o un símbolo"

#: package.d:1984
msgid "~: there is already a package named ~"
msgstr "~: ya hay un paquete llamado ~"

#: package.d:2105 predtype.d:1960
msgid "~: argument ~ is not a symbol"
msgstr "~: el argumento ~ no es un símbolo"

#
# "~: el argumento debe ser un símbolo o una lista de símbolos, no ~" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: package.d:2154
msgid "~: argument should be a symbol or a list of symbols, not ~"
msgstr "~: el argumento debe ser un símbolo o una lista de símbolos, no ~"

#: package.d:2366
msgid "Cannot change the case sensitiveness of ~."
msgstr "No es posible cambiar las mayúsculas/minúsculas de ~."

#: record.d:33
msgid "~: ~ is not a valid index into ~"
msgstr "~: ~ no es un índice válido en ~"

#: record.d:44
msgid "~: ~ is not a record"
msgstr "~: ~ no es un registro"

#: record.d:104
msgid "~: length ~ is illegal, should be of type (INTEGER (0) (65536))"
msgstr "~: la longitud ~ es inválida, debe ser del tipo (INTEGER (0) (65536))"

#: record.d:141
msgid "~: ~ is not a structure of type ~"
msgstr "~: ~ no es una estructura del tipo ~"

#: record.d:188
#, fuzzy
msgid "~: Slot ~ of ~ has no value"
msgstr "~: Una ranura de ~ no tiene valor"

#: record.d:287
msgid "~: ~ is not a closure"
msgstr "~: ~ no es una cerradura"

#: record.d:300
msgid "~: This is not a compiled closure: ~"
msgstr "~: No se trata de una cerradura compilada: ~"

#: record.d:371
msgid "~ is not a valid code-vector byte"
msgstr "~ no es un byte CODE-VECTOR válido"

#: record.d:387
msgid "~: invalid code-vector ~"
msgstr "~: CODE-VECTOR inválido ~"

#: record.d:397
msgid "~: function ~ is too big: ~"
msgstr "~: la función ~ es demasiado grande: ~"

#: record.d:425 record.d:467
msgid "~: This is not a generic function: ~"
msgstr "~: Ésta no es una función genérica: ~"

#: record.d:435
#, fuzzy
msgid "~: This is not a prototype of a generic function: ~"
msgstr "~: Ésta no es una función genérica: ~"

#: record.d:576
#, fuzzy
msgid "~: ~ is not a weak pointer"
msgstr "~: ~ no es un puntero de pila"

#: record.d:639
msgid "~: ~ is not a class"
msgstr "~: ~ no es una clase"

#: record.d:674
#, fuzzy
msgid "ALLOCATE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "SHARED-INITIALIZE: la lista de argumentos clave ~ tiene longitud impar"

#
# Yo pondría un guión entre argumento y clave. - lsg
#
# Hmm, o sea `argumento-clave'. No, no me gusta y de hecho, en el
# "Vocabulario bilingüe de términos técnicos" de "Lisp" (3ra edición) de
# Winston y Horn, los traductores al español ponen en la página 649:
#
# keyword arguments - argumentos clave
#
# sin guión por medio - cll
#
#: record.d:865
msgid ""
"~: illegal keyword/value pair ~, ~ in argument list.\n"
"The allowed keywords are ~"
msgstr ""
"~: par argumento clave/valor inválido ~, ~ en la lista de argumentos.\n"
"Los parámetros clave permitidos son ~"

#: record.d:899
msgid "SHARED-INITIALIZE: keyword argument list ~ has an odd length"
msgstr "SHARED-INITIALIZE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1013
msgid "REINITIALIZE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "REINITIALIZE-INSTANCE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1112
msgid "INITIALIZE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "INITIALIZE-INSTANCE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1239
msgid "MAKE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "MAKE-INSTANCE: la lista de argumentos clave ~S tiene longitud impar"

#: record.d:1300
msgid "~ method for ~ returned ~"
msgstr ""

#: sequence.d:219
msgid "There are no sequences of type ~"
msgstr "No hay secuencias del tipo ~"

#: sequence.d:285
msgid "~ is not a sequence"
msgstr "~ no es una secuencia"

#: sequence.d:302
msgid "sequence type forces length ~, but result has length ~"
msgstr ""

#: sequence.d:318
msgid "~: ~ should be an integer >=0, not ~"
msgstr "~: ~ debe ser un entero >=0, no ~"

#: sequence.d:369 sequence.d:400
msgid "~: ~ = ~ should not be greater than ~ = ~"
msgstr "~: ~ = ~ no debe ser mayor que ~ = ~"

#: sequence.d:550
msgid "~: the index should be a fixnum >=0, not ~"
msgstr "~: el índice debe ser un número >=0 del tipo FIXNUM, no ~"

#: sequence.d:567
msgid "~ ~: the index should be a fixnum >=0, not ~"
msgstr "~ ~: el índice debe ser del tipo fixnum >=0, no ~"

#: sequence.d:706
msgid "~: ~ is not a sequence"
msgstr "~: ~ no es una secuencia"

#: sequence.d:829 sequence.d:1068
msgid "~: bad length ~"
msgstr "~: longitud incorrecta ~"

#: sequence.d:930
msgid "~: size should be an integer >=0, not ~"
msgstr "~: el tamaño debe ser un entero >=0, no ~"

#: sequence.d:938
msgid "~: :update must not be specified without :initial-element"
msgstr "~: no debe especificarse :update sin :initial-element"

#: sequence.d:1919
msgid "~: Must not specify both arguments to :TEST and :TEST-NOT"
msgstr "~: Los argumentos :TEST y :TEST-NOT no deben tener valor simultáneamente"

#: sequence.d:2048
msgid "~: sequence ~ is too long"
msgstr "~: la secuencia ~ es demasiado larga"

#: sequence.d:2510
msgid "too long sequence ~"
msgstr "secuencia demasiado larga ~"

#: charstrg.d:946 charstrg.d:1028 charstrg.d:1060 charstrg.d:1107
msgid "This is not a string: ~"
msgstr "Esto no es una cadena: ~"

#: charstrg.d:1447
msgid "~: the radix must be an integer between 2 and 36, not ~"
msgstr "~: la base debe ser un entero entre 2 y 36, no ~"

#: charstrg.d:1821
msgid "~: the code argument should be an integer, not ~"
msgstr "~: el argumento del código debe ser un entero y no ~"

# "~: no se puede convertir ~ al tipo character"
#
# No sé si traducir la palabra character, puesto que es una palabra
# clave en Lisp. - lsg
#
# Yo ya había traducido este mensaje como:
#
# "~: ~ no puede convertirse a un carácter"
#
# Pero el tuyo me gusta mucho más, salvo que `character', puesto que es
# un término definido en el estándar Common Lisp, debe ir en mayúsculas
# - cll
#
#: charstrg.d:1843
msgid "~: cannot coerce ~ to a character"
msgstr "~: no se puede convertir ~ al tipo CHARACTER"

#: charstrg.d:1884
msgid "~: the weight argument should be an integer, not ~"
msgstr "~: el argumento de ponderación debe ser un entero, y no ~"

#: charstrg.d:1926
msgid "~: argument should be an integer, not ~"
msgstr "~: el argumento debe ser un entero, no ~"

#: charstrg.d:1953
msgid "~: index should be an integer, not ~"
msgstr "~: el índice debe ser un entero, no ~"

#: charstrg.d:1958
msgid "~: ~-index should be an integer, not ~"
msgstr "~: el índice ~ debe ser un entero, no ~"

#: charstrg.d:1975
msgid "~: index should be NIL or an integer, not ~"
msgstr "~: el índice debe ser NIL o un entero, no ~"

#: charstrg.d:1980
msgid "~: ~-index should be NIL or an integer, not ~"
msgstr "~: el índice ~ debe ser NIL o un entero, no ~"

#: charstrg.d:1997
msgid "~: index should not be negative: ~"
msgstr "~: el índice no debe ser negativo: ~"

#: charstrg.d:2002
msgid "~: ~-index should not be negative: ~"
msgstr "~: el índice ~ no debe ser negativo: ~"

#: charstrg.d:2026
msgid "~: index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:2031
msgid "~: ~-index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ = ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:2055
msgid "~: index ~ should be less than the length of the string"
msgstr "~: el índice ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:2060
msgid "~: ~-index ~ should be less than the length of the string"
msgstr "~: el índice ~ = ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:2165
#, fuzzy
msgid "~: argument should be a character, not ~"
msgstr "~: el argumento debe ser un entero, no ~"

#: charstrg.d:2236 charstrg.d:2333 charstrg.d:3338
msgid "~: :start-index ~ must not be greater than :end-index ~"
msgstr "~: El índice :start ~ no debe ser mayor que el índice :end ~"

#: charstrg.d:2291
#, fuzzy
msgid "~: argument ~ should be a string, a symbol or a character"
msgstr "~: el argumento ~ debe ser del tipo string o string-char, o un símbolo"

#: charstrg.d:2391
msgid "~: :start1-index ~ must not be greater than :end1-index ~"
msgstr "~: El índice start1 ~ no debe ser mayor que el índice :end1 ~"

#: charstrg.d:2415
msgid "~: :start2-index ~ must not be greater than :end2-index ~"
msgstr "~: El índice :start2 ~ no debe ser mayor que el índice :end2 ~"

#: charstrg.d:2993
msgid "~: the string length ~ should be nonnegative fixnum"
msgstr ""
"~: la longitud de la cadena de caracteres ~ debe ser un número no negativo\n"
"del tipo FIXNUM"

#: charstrg.d:3025
#, fuzzy
msgid "~: :initial-element ~ should be of type character"
msgstr "~: El :INITIAL-ELEMENT ~ debe ser del tipo STRING-CHAR"

#
# Duda: esta traducción ha sido muy difícil, y está basada en la
# traducción francesa que dice: "~: Mauvais mode de saut d'environnement
# ~."
#
#: debug.d:718
msgid "~: bad frame climbing mode ~"
msgstr "~: modo de salto de marco incorrecto"

#: debug.d:738
msgid "~: ~ is not a stack pointer"
msgstr "~: ~ no es un puntero de pila"

#: debug.d:930
msgid "~: ~ is not a pointer to an EVAL/APPLY frame"
msgstr "~: ~ no es un puntero a un marco de tipo EVAL/APPLY"

#: debug.d:1196
msgid "~: environment is not an alist"
msgstr "~: el entorno no es una a-lista"

#: debug.d:1290
msgid "~: unknown frame type"
msgstr "~: tipo de marco desconocido"

#: error.d:49 reploop.lsp:291
msgid "Unprintable error message"
msgstr "Mensaje de error no imprimible"

#: error.d:658
msgid "~: User break"
msgstr "~: Interrupción del usuario"

#: error.d:711
msgid "~: ~ is not a list"
msgstr "~: ~ no es una lista"

#: error.d:727
msgid "~: A true list must not end with ~"
msgstr "~: Una auténtica lista no debe finalizar con ~"

#: error.d:745
msgid "~: ~ is not a symbol"
msgstr "~: ~ no es un símbolo"

#: error.d:776
msgid "~: ~ is not a simple-vector"
msgstr "~: ~ no es un SIMPLE-VECTOR"

#: error.d:792
msgid "~: ~ is not a vector"
msgstr "~: ~ no es un vector"

#: error.d:808
msgid "~: argument ~ should be a nonnegative fixnum"
msgstr "~: el argumento ~ debe ser un número no negativo del tipo fixnum"

#: error.d:824
msgid "~: argument ~ is not a character"
msgstr "~: el argumento ~ no es un carácter"

#: error.d:839
msgid "~: argument ~ is not a string"
msgstr "~: el argumento ~ no es un string"

#: error.d:854
msgid "~: argument ~ is not a simple string"
msgstr "~: el argumento ~ no es una cadena simple"

#: error.d:868
msgid "Attempt to modify a read-only string: ~"
msgstr ""

#: error.d:884
#, fuzzy
msgid "~: argument ~ is neither a string nor an integer"
msgstr "~: el argumento ~ no es un string"

#: error.d:900
msgid "~: argument ~ should be a stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: error.d:918
msgid "~: argument ~ should be a stream of type ~"
msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#: error.d:934
msgid ""
"~: argument ~ is not a function.\n"
"To get a function in the current environment, write (FUNCTION ...).\n"
"To get a function in the global environment, write (COERCE '... 'FUNCTION)."
msgstr ""

#: error.d:950 error.d:968
msgid "~: ~ is not an 8-bit number"
msgstr "~: ~ no es un número de 8 bits"

#: error.d:984 error.d:1000
msgid "~: ~ is not a 16-bit number"
msgstr "~: ~ no es un número de 16 bits"

#: error.d:1016 error.d:1032
msgid "~: ~ is not an 32-bit number"
msgstr "~: ~ no es un número de 32 bits"

#: error.d:1048 error.d:1064
msgid "~: ~ is not an 64-bit number"
msgstr "~: ~ no es un número de 64 bits"

#: error.d:1084
msgid "~: ~ is not an `unsigned int' number"
msgstr "~: ~ no es un número del tipo `unsigned int'"

#: error.d:1104
msgid "~: ~ is not an `int' number"
msgstr "~: ~ no es un número del tipo `int'"

#: error.d:1124
msgid "~: ~ is not a `unsigned long' number"
msgstr "~: ~ no es un número del tipo `unsigned long'"

#: error.d:1144
msgid "~: ~ is not a `long' number"
msgstr "~: ~ no es un número del tipo `long'"

#: error.d:1160
msgid "~: ~ is not a single-float"
msgstr "~: ~ no es un SINGLE-FLOAT"

#: error.d:1176
msgid "~: ~ is not a double-float"
msgstr "~: ~ no es un DOUBLE-FLOAT"

# Sugerencia: "Error del Sistema Operativo Amiga " sv
#
# ¡Ajá! me parece muchísimo mejor que lo que había puesto, ...
#
#: erramiga.d:11
msgid "Amiga OS error "
msgstr "Error del Sistema Operativo Amiga "

#: erramiga.d:40
msgid "not enough memory available"
msgstr "no hay suficiente memoria disponible"

#: erramiga.d:43
msgid "process table full"
msgstr "tabla de procesos llena"

#: erramiga.d:53
msgid "bad template"
msgstr "plantilla incorrecta"

#: erramiga.d:55
msgid "bad number"
msgstr "número incorrecto"

#: erramiga.d:57
msgid "required argument missing"
msgstr "argumentos obligatorios ausentes"

#: erramiga.d:59
msgid "value after keyword missing"
msgstr "falta el valor después de la palabra clave"

#: erramiga.d:61
msgid "wrong number of arguments"
msgstr "~: número incorrecto de argumentos"

# Duda: Uuufff! Por favor, que alguien le eche un ojo a esto, ...
#
# Bueno, he encontrado un mensaje parecido a este en el glibc donde pone
# "desemparejados". Me suena bien. cll
#
#: erramiga.d:63
msgid "unmatched quotes"
msgstr "comillas desemparejadas"

#: erramiga.d:65
msgid "argument line invalid or too long"
msgstr "línea de argumentos inválida o demasiado larga"

#: erramiga.d:67
msgid "file is not executable"
msgstr "el fichero no es un ejecutable"

#: erramiga.d:69
msgid "invalid resident library"
msgstr "librería residente inválida"

#: erramiga.d:78
msgid "object is in use"
msgstr "el objeto está siendo usado"

#: erramiga.d:80
msgid "object already exists"
msgstr "el objeto ya existe"

#: erramiga.d:82
msgid "directory not found"
msgstr "directorio no encontrado"

#: erramiga.d:84
msgid "object not found"
msgstr "objeto no encontrado"

#: erramiga.d:86
msgid "invalid window description"
msgstr "descripción de ventana inválida"

#: erramiga.d:88
msgid "object too large"
msgstr "el objeto es demasiado grande"

#: erramiga.d:91
msgid "packet request type unknown"
msgstr "tipo de paquete de petición desconocido"

#: erramiga.d:93
msgid "object name invalid"
msgstr "nombre de objeto inválido"

#: erramiga.d:95
msgid "invalid object lock"
msgstr "bloqueo de objeto inválido"

#: erramiga.d:97
msgid "object is not of required type"
msgstr "el objeto no es del tipo requerido"

#: erramiga.d:99
msgid "disk not validated"
msgstr "disco no validado"

#: erramiga.d:101
msgid "disk is write-protected"
msgstr "el disco es de solo lectura"

#: erramiga.d:103
msgid "rename across devices attempted"
msgstr "se intentó un renombramiento entre unidades"

#: erramiga.d:105
msgid "directory not empty"
msgstr "directorio no vacío"

#: erramiga.d:107
msgid "too many levels"
msgstr "demasiados niveles"

#: erramiga.d:109
msgid "device (or volume) is not mounted"
msgstr "el dispositivo (o volumen) no está montado"

#: erramiga.d:111
msgid "seek failure"
msgstr "error durante un acceso directo (seek)"

#: erramiga.d:113
msgid "comment is too long"
msgstr "el comentario es demasiado largo"

#: erramiga.d:115
msgid "disk is full"
msgstr "el disco está lleno"

#: erramiga.d:117
msgid "object is protected from deletion"
msgstr "el objeto está protegido contra el borrado"

#: erramiga.d:119
msgid "file is write protected"
msgstr "el archivo está protegido contra escritura"

#: erramiga.d:121
msgid "file is read protected"
msgstr "el fichero está protegido contra escritura"

#: erramiga.d:123
msgid "not a valid DOS disk"
msgstr "no es un disquete DOS válido"

#: erramiga.d:125
msgid "no disk in drive"
msgstr "no hay ningún disquete en la unidad"

#: erramiga.d:132
msgid "no more entries in directory"
msgstr "no hay más entradas en el directorio"

#: erramiga.d:134
msgid "object is soft link"
msgstr "el objeto es un enlace blando"

#: erramiga.d:136
msgid "object is linked"
msgstr "el objeto está enlazado"

#: erramiga.d:138
msgid "bad loadfile hunk"
msgstr "trozo incorrecto del fichero de carga"

#: erramiga.d:140
msgid "function not implemented"
msgstr "función no implementada"

#: erramiga.d:145
msgid "record not locked"
msgstr "registro no bloqueado"

#: erramiga.d:147
msgid "record lock collision"
msgstr "colisión de bloqueo de registro"

#: erramiga.d:149
msgid "record lock timeout"
msgstr "tiempo de espera excedido del bloqueo del registro"

#: erramiga.d:151
msgid "record unlock error"
msgstr "error de desbloqueo de registro"

#: erramiga.d:158
msgid "buffer overflow"
msgstr "desbordamiento del buffer"

#: erramiga.d:160
msgid "break"
msgstr "interrupción"

#: erramiga.d:162
msgid "file not executable"
msgstr "fichero no ejecutable"

# Duda: ¿Ok por `vale'? Hmmm, no sé, no sé, ...
# Depende del caso, ¿qué te parece "correcto"? sv
#
# No, no me gusta demasiado, ..., me parece que es demasiado en plan
# "computadora". Prefiero "vale" antes que "correcto". cll
#
#: erramiga.d:170
msgid "Ok, No error"
msgstr "Vale, sin errores"

# Sugerencia: Error de DJDOS. sv
#: errdjgpp.d:11
msgid "DJDOS error "
msgstr "Error de DJDOS "

#: errdjgpp.d:40 errunix.d:618
msgid "Function not implemented"
msgstr "Función no implementada"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
# "No existe ese archivo o directorio" - lsg
#
# Pues si, me gusta más la traducción de Leo, que la de Enrique, salvo
# que, tal y como tu mismo apuntas, Leo, se debe decir "fichero" y no
# "archivo" - cll
#
#: errdjgpp.d:42 errunix.d:54
msgid "No such file or directory"
msgstr "No existe ese fichero o directorio"

#: errdjgpp.d:44 errunix.d:162
msgid "Not a directory"
msgstr "No es un directorio"

#: errdjgpp.d:46 errunix.d:186
msgid "Too many open files"
msgstr "Demasiados ficheros abiertos"

#: errdjgpp.d:48 errunix.d:120
msgid "Permission denied"
msgstr "Permiso denegado"

#: errdjgpp.d:50 errunix.d:96
msgid "Bad file number"
msgstr "Número de fichero incorrecto"

#: errdjgpp.d:52
msgid "Memory control blocks destroyed"
msgstr "Bloques de control de memoria destruídos"

#: errdjgpp.d:54 errunix.d:114
msgid "Not enough memory"
msgstr "No hay memoria suficiente"

#: errdjgpp.d:56
msgid "Invalid memory address"
msgstr "Dirección de memoria inválida"

#: errdjgpp.d:58
msgid "Invalid environment"
msgstr "Entorno inválido"

#: errdjgpp.d:61
msgid "Invalid access code"
msgstr "Código de acceso inválido"

#: errdjgpp.d:64 errunix.d:156
msgid "No such device"
msgstr "No existe tal dispositivo"

#: errdjgpp.d:66
msgid "Attempt to remove the current directory"
msgstr "Intento de borrar el directorio actual"

#: errdjgpp.d:68
msgid "Can't move to other than the same device"
msgstr "No se puede cambiar de dispositivo"

#: errdjgpp.d:70
msgid "No more files"
msgstr "No más ficheros"

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# ¡¡¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#: errdjgpp.d:72 errunix.d:174
msgid "Invalid argument"
msgstr "Argumento inválido"

#: errdjgpp.d:74 errunix.d:84
msgid "Arg list too long"
msgstr "Lista de argumentos demasiado larga"

#: errdjgpp.d:76 errunix.d:90
msgid "Exec format error"
msgstr "Formato de programa no ejecutable"

#: errdjgpp.d:78 errunix.d:150
msgid "Cross-device link"
msgstr "Enlace cruzado entre dispositivos"

#: errdjgpp.d:82 errunix.d:244
msgid "Argument out of domain"
msgstr "Argumento fuera del dominio"

#
# "El resultado es demasiado grande" - lsg
#
# Si, ya he cambiado `largo' por `grande' en todos los mensajes. Un
# fallo realmente infantil :( - cll
#
#: errdjgpp.d:84 errunix.d:250
msgid "Result too large"
msgstr "El resultado es demasiado grande"

#: errdjgpp.d:86 errunix.d:144
msgid "File exists"
msgstr "El fichero ya existe"

#: errunix.d:48
msgid "Operation not permitted"
msgstr "Operación no permitida"

#: errunix.d:60
msgid "No such process"
msgstr "No existe tal proceso"

#: errunix.d:66
msgid "Interrupted system call"
msgstr "Llamada al sistema interrumpida"

# Sugerencia: E/S. sv
#
# Vaya, tu sugerencia es tan informática que me impresiona que se me
# haya escapado. cll
#
#: errunix.d:72
msgid "I/O error"
msgstr "Error de E/S"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:78
msgid "No such device or address"
msgstr "Dispositivo no configurado"

# Sugerencia: No hay ningún proceso hijo. sv
#
# Bueno, Enrique tradujo este mensaje como "Ningún proceso hijo" en libc
# asi que, si te parece bien, lo pondré como él puesto que lo suyo es
# una traducción ya aceptada y que además, resulta de mezclar lo que yo
# he puesto y de tu sugerencia. cll
#
#: errunix.d:102
msgid "No child processes"
msgstr "Ningún proceso hijo"

#: errunix.d:108
msgid "No more processes"
msgstr "No hay más procesos"

#: errunix.d:126
msgid "Bad address"
msgstr "Dirección incorrecta"

# Pongo esto un poco más en español.
# Antes decía "Dispositivo de bloque requerido".
# Por cierto, en otros sitios hemos puesto "dispositivo de bloques".
# ¿cómo es? sv
#: errunix.d:132
msgid "Block device required"
msgstr "Se requiere un dispositivo de bloque"

#: errunix.d:138
msgid "Device busy"
msgstr "Dispositivo ocupado"

#: errunix.d:168
msgid "Is a directory"
msgstr "Es un directorio"

#: errunix.d:180
msgid "File table overflow"
msgstr "Desbordamiento de la tabla de ficheros"

#: errunix.d:192
msgid "Inappropriate ioctl for device"
msgstr "El dispositivo no acepta la llamada `ioctl'"

#: errunix.d:198
msgid "Text file busy"
msgstr "Fichero de texto en uso"

#: errunix.d:204
msgid "File too large"
msgstr "Fichero demasiado grande"

#: errunix.d:210
msgid "No space left on device"
msgstr "No queda espacio en el dispositivo"

#: errunix.d:216
msgid "Illegal seek"
msgstr "Desplazamiento inválido"

#: errunix.d:222
msgid "Read-only file system"
msgstr "Sistema de ficheros de sólo lectura"

#: errunix.d:228
msgid "Too many links"
msgstr "Demasiados enlaces"

#: errunix.d:234
msgid "Broken pipe, child process terminated or socket closed"
msgstr ""

#: errunix.d:257
msgid "Invalid multibyte or wide character"
msgstr ""

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:264
msgid "Operation would block"
msgstr "La operación se bloquearía"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:270
msgid "Operation now in progress"
msgstr "Operación en curso"

# Already sería "ya". aún sería still.
# Sugerencia: La operación ya se está realizando. sv
#
# Más aún, echando un ojo a la traducción de Enrique Melero en el glibc,
# me he encontrado con el mismo mensaje y el dice: "La operación ya se
# está llevando a cabo". Me gusta bastante. cll
#
#: errunix.d:276
msgid "Operation already in progress"
msgstr "La operación ya se está llevando a cabo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:283
msgid "Too many levels of symbolic links"
msgstr "Demasiados niveles de enlaces simbólicos"

#: errunix.d:289
msgid "File name too long"
msgstr "Nombre de fichero demasiado largo"

#: errunix.d:295
msgid "Directory not empty"
msgstr "El directorio no está vacío"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:302
msgid "Stale NFS file handle"
msgstr "Fichero NFS bloqueado"

# Duda: Aquí he seguido el consejo de Enrique Melero.
#
# En la versión 1.5 he decidido cambiar el término `camino' por
# `trayectoria', tal y como recomiendan los traductores del libro Lisp,
# (3ra edición) de Winston y Horn en el "Vocabulario bilingüe de
# términos técnicos", en la página 650.
#
#: errunix.d:308
msgid "Too many levels of remote in path"
msgstr "Demasiados niveles de profundidad en la trayectoria"

#: errunix.d:315
msgid "Socket operation on non-socket"
msgstr "Operación de `sockets' sobre un \"no-socket\""

#: errunix.d:321
msgid "Destination address required"
msgstr "Se necesita la dirección del destino"

#: errunix.d:327
msgid "Message too long"
msgstr "Mensaje demasiado largo"

#: errunix.d:333
msgid "Protocol wrong type for socket"
msgstr "Tipo de protocolo incorrecto para el `socket'"

#: errunix.d:339
msgid "Option not supported by protocol"
msgstr "Opción no soportada por el protocolo"

#: errunix.d:345
msgid "Protocol not supported"
msgstr "Protocolo no soportado"

#: errunix.d:351
msgid "Socket type not supported"
msgstr "Tipo de `socket' no soportado"

# Pongo `socket' en vez de socket. sv
#: errunix.d:357
msgid "Operation not supported on socket"
msgstr "Acción no permitida en un `socket'"

#: errunix.d:363
msgid "Protocol family not supported"
msgstr "Familia de protocolos no soportada"

#: errunix.d:369
msgid "Address family not supported by protocol family"
msgstr "Familia de direcciones no soportada por el protocolo"

#: errunix.d:375
msgid "Address already in use"
msgstr "Dirección en uso"

# Sugerencia: No se puede asignar. sv
#
# ¡Vale!, "No puede asignarse ..." es demasiado, ..., ¿impersonal? cll
#: errunix.d:381
msgid "Can't assign requested address"
msgstr "No se puede asignar la dirección requerida"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:387
msgid "Network is down"
msgstr "La red no está operativa"

#: errunix.d:393
msgid "Network is unreachable"
msgstr "No es posible conectarse con la red"

#: errunix.d:399
msgid "Network dropped connection on reset"
msgstr "Se ha perdido la conexión con la red debido a una reinicialización"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:405
msgid "Software caused connection abort"
msgstr "El software ha provocado la interrupción de la conexión"

#: errunix.d:411
msgid "Connection reset by peer"
msgstr "Conexión reinicializada por el otro extremo"

#
# Duda: ¿Y buffer? ¿Como traduzco buffer?
#
# Yo he visto a menudo 'memoria tampón', que es el término usado por los
# franceses. - lsg
#
# Tienes toda la razón, ... Sin embargo, en este caso, la traducción
# francesa es:
#
# "Pas d'espace disponible pour un buffer"
#
# Además, como en spanglish.txt pone:
#
# "buffer - memoria intermedia, tampón, buffer"
#
# pues he utilizado `buffer' tal cual, ... - cll
#
#: errunix.d:417
msgid "No buffer space available"
msgstr "No queda espacio en el buffer"

# Lo de socket, si te parece. sv
#
# Te digo lo mismo que te dije antes. Cuando hay finalizado con la
# traducción me pondré a cambiar todas estas cosas con macros. cll
#
#: errunix.d:423
msgid "Socket is already connected"
msgstr "El `socket' ya está conectado"

#: errunix.d:429
msgid "Socket is not connected"
msgstr "El `socket' no está conectado"

# Añado comitas a `socket'. Es una especie de convenio que seguimos
# cuando no nos queda más remedio que poner la palabra inglesa.
# Así al menos reconocemos que es una palabra extraña. sv
#: errunix.d:435
msgid "Can't send after socket shutdown"
msgstr "No se puede enviar después de la ruptura del `socket'"

#: errunix.d:441
msgid "Too many references: can't splice"
msgstr ""

# Duda: ¿ Se excedió el tiempo para la conexión ?
#: errunix.d:447
msgid "Connection timed out"
msgstr "Se excedió el tiempo para la conexión"

#: errunix.d:453
msgid "Connection refused"
msgstr "Conexión rechazada"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:458
#, fuzzy
msgid "Remote peer released connection"
msgstr "El software ha provocado la interrupción de la conexión"

# Estas dos darán que hablar, pero otro día las discutiremos... sv
#
# Al decir tú eso, he leído la traducción de este término en libc
# (traducido por Enrique Melero) y, madre mía, me he quedado
# "flipao". Aquello fue una discusión encarnizada, ...
#
# Para mas inri, yo no estoy de acuerdo con ninguno de los dos :) Verás,
# un host puede estar "caído" (que así es como se suele decir aunque es,
# evidentemente, incorrecto) y por ello no tiene por qué no estar
# operativo (en libc lo habeis traducido como "el `host' no está
# operativo"). De hecho, puede estar operando pero, por algún problema
# de la red o de tu propia transmisión, resultar inalcanzable, ... En
# fin, por este motivo prefiero "El `host' no está disponible"
#
# Por otra parte, no estoy muy de acuerdo con Enrique, ..., a mí lo de
# poner host no me gusta. Ciertamente, un `host' no tiene por qué ser un
# servidor, necesariamente, pero es el caso más común. En cualquier
# caso, todo el mundo comprende perfectamente que el `host' es un
# servidor. cll
#
#: errunix.d:463
msgid "Host is down"
msgstr "El servidor no está disponible"

# Aquí, pues idem de idem, ... :) cll
#
#: errunix.d:469
msgid "Host is unreachable"
msgstr "No se puede conectar con el servidor"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:474
#, fuzzy
msgid "Networking error"
msgstr "La red no está operativa"

#: errunix.d:480
msgid "Too many processes"
msgstr "Demasiados procesos"

#: errunix.d:486
msgid "Too many users"
msgstr "Demasiados usuarios"

#: errunix.d:492
msgid "Disk quota exceeded"
msgstr "Cuota de disco excedida"

#: errunix.d:499
msgid "Not a stream device"
msgstr "No es un dispositivo de flujo"

#: errunix.d:505
msgid "Timer expired"
msgstr "El temporizador expiró"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:511
msgid "Out of stream resources"
msgstr "Alcanzado el límite de recursos de `streams'"

#: errunix.d:517
msgid "No message of desired type"
msgstr "No hay mensajes del tipo deseado"

#: errunix.d:523
msgid "Not a data message"
msgstr "No es un mensaje de datos"

#: errunix.d:530
msgid "Identifier removed"
msgstr "Identificador desechado"

# Duda: Eso del `inter-bloqueo' ¿estará bien?
#
#: errunix.d:537
msgid "Resource deadlock would occur"
msgstr "Podría ocurrir un interbloqueo entre recursos"

# Duda: Aunque Bruno Haible me ha asegurado que la etiqueta
# sys_errlist[ENOLCK] del glibc.po en español contiene la traduccion que
# yo debiera usar, me he decidido por las indicaciones de Santiago Vila
# en su respuesta a mi mail y he puesto, simplemente: "No quedan
# registros de bloqueo disponibles"
#
#: errunix.d:543
msgid "No record locks available"
msgstr "No quedan registros de bloqueo disponibles"

#: errunix.d:550
msgid "Machine is not on the network"
msgstr "La máquina no está en la red"

#: errunix.d:556 errunix.d:562
msgid "Object is remote"
msgstr "El objeto es remoto"

#: errunix.d:568
msgid "Link has been severed"
msgstr "El enlace ha sido destruído"

#: errunix.d:574
msgid "Advertise error"
msgstr "Error de anuncio"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:580
msgid "Srmount error"
msgstr "Error de `srmount'"

#: errunix.d:586
msgid "Communication error on send"
msgstr "Error de comunicaciones en el envío"

#: errunix.d:592
msgid "Protocol error"
msgstr "Error de protocolo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:598
msgid "Multihop attempted"
msgstr "Se ha intentado un multihop"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:611
msgid "Remote address changed"
msgstr "La dirección remota ha cambiado"

#: errunix.d:625
msgid "Not supported under MS-DOS"
msgstr "No soportado en MS-DOS"

#: errunix.d:645
msgid "UNIX error "
msgstr "Error de Unix "

# Cambio librería por el término oficial. sv
#
# Uuuffffff, ..., aquí sí que podríamos discutir hasta la muerte. Pero
# bueno, se queda como tú lo has puesto. cll
#
#: errunix.d:647
msgid "UNIX library error "
msgstr "Error de biblioteca Unix "

#: errwin32.d:3879
msgid "Win32 error "
msgstr "Error de Win32 "

#: errwin32.d:3928
msgid "Winsock error "
msgstr "Error de `winsock'"

#: misc.d:44
msgid "This file was produced by another lisp version, must be recompiled."
msgstr "Este fichero fue producido por otra versión de lisp. Debe recompilarse."

#: misc.d:258
msgid "~: type of attribute ~ is unsupported"
msgstr "~: el tipo de atributo ~ no está soportado"

#: predtype.d:1720 predtype.d:1919
msgid "~: unidentifiable type!!!"
msgstr "~: ¡¡¡tipo irreconocible!!!"

#: predtype.d:1926
msgid "~: type ~ does not correspond to a class"
msgstr "~: el tipo ~ no se corresponde con una clase"

#: predtype.d:1969
msgid "~: ~ does not name a class"
msgstr "~: ~ no es el nombre de una clase"

#: predtype.d:2276
msgid "~: bad type specification ~"
msgstr "~: especificación de tipo incorrecta ~"

#: predtype.d:2284
msgid "~: ~ cannot be coerced to type ~"
msgstr "~: ~ no puede convertirse al tipo ~"

#: symbol.d:48
msgid "~: the property list of ~ has an odd length"
msgstr "~: la lista de propiedades de ~ tiene longitud impar"

#: symbol.d:108
msgid "SETF SYMBOL-FUNCTION: ~ is not a function"
msgstr "SETF SYMBOL-FUNCTION: ~ no es una función"

#: symbol.d:133
msgid "~: ~ is not a system function"
msgstr "~: ~ no es una función del sistema"

#: symbol.d:192 symbol.d:233
msgid "~: the property list ~ has an odd length"
msgstr "~: la lista de propiedades ~ tiene longitud impar"

#: intlog.d:567 symbol.d:423
msgid "~: index ~ is negative"
msgstr "~: el índice ~ es negativo"

#: symbol.d:434
msgid "~: invalid argument ~"
msgstr "~: el argumento ~ es inválido"

#: symbol.d:448
msgid "The value of *GENSYM-COUNTER* was not a nonnegative integer. Old value ~. New value ~."
msgstr "El valor de *GENSYM-COUNTER* no era un entero no negativo. Valor anterior ~. Nuevo valor ~."

#: lisparit.d:335
msgid "argument to ~ should be a number: ~"
msgstr "el argumento de ~ debe ser un número: ~"

#: lisparit.d:350
msgid "argument to ~ should be a real number: ~"
msgstr "el argumento de ~ debe ser un número real: ~"

#: lisparit.d:365
msgid "argument to ~ should be a floating point number: ~"
msgstr "el argumento de ~ debe ser un número en coma flotante: ~"

#: lisparit.d:380
msgid "argument to ~ should be a rational number: ~"
msgstr "el argumento de ~ debe ser un número racional: ~"

#: lisparit.d:395
msgid "argument to ~ should be an integer: ~"
msgstr "el argumento de ~ debe ser un entero: ~"

#: lisparit.d:410
msgid "~: argument should be a positive fixnum, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo FIXNUM, no ~"

#: lisparit.d:1673
msgid "~: argument should be a random-state, not ~"
msgstr "~: el argumento debe ser un estado aleatorio, no ~"

#: lisparit.d:1688
msgid "~: the value of ~ should be a random-state, not ~"
msgstr "~: el valor de ~ debe ser un RANDOM-STATE, no ~"

#: lisparit.d:1707
msgid "~: argument should be positive and an integer or float, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo INTEGER o FLOAT, no ~"

#: lisparit.d:1789
msgid "~ : argument should be a fixnum >=0, not ~"
msgstr "~ : El argumento debe ser del tipo FIXNUM >=0 y no ~"

#: aridecl.d:338
msgid "division by zero"
msgstr "división entre cero"

#: aridecl.d:348
msgid "floating point overflow"
msgstr "desbordamiento de coma flotante"

# Duda: Lo del desbordamiento inferior de coma flotante ha sido
# traducción super libre mía ;) Este mensaje ocurre cuando el resultado
# (expresado en coma flotante) ocurre mucho más cerca del cero de lo que
# permite la representación de números en coma flotante. Por ejemplo:
# 2.3e-30 * 2.3e-30 sería 5.29e-60 que excedió el límite inferior.
#
#: aridecl.d:358
msgid "floating point underflow"
msgstr "desbordamiento inferior de coma flotante"

#: intelem.d:211 intelem.d:309
msgid "not a 32-bit integer: ~"
msgstr "no es un entero de 32 bits: ~"

#: intelem.d:399 intelem.d:545
msgid "not a 64-bit integer: ~"
msgstr "no es un entero de 64 bits: ~"

#: intelem.d:1443
msgid "bignum overflow"
msgstr "desbordamiento de números grandes"

#: intlog.d:450
msgid "~: ~ is not a valid boolean operation"
msgstr "~: ~ no es una operación lógica válida"

#: intlog.d:690
msgid "~: too large shift amount ~"
msgstr "~: el tamaño del desplazamiento es muy grande ~"

# Duda: En Lisp existe un tipo predeterminado: `fixnum'. Por ese motivo,
# dejo sin traducir este término.
#
#: intbyte.d:15
msgid "The arguments to BYTE must be fixnums >=0: ~, ~"
msgstr "Los argumentos de BYTE deben ser números enteros del tipo FIXNUM >=0: ~, ~"

#: intbyte.d:39
msgid "~ is not a BYTE specifier"
msgstr "~ no es un especificador de BYTE"

#: intmal.d:7
msgid "overflow during multiplication of large numbers"
msgstr "desbordamiento durante la multiplicación de números grandes"

#: intdiv.d:347
msgid "quotient ~ / ~ is not an integer"
msgstr "el cociente ~ / ~ no es un entero"

#: intsqrt.d:388
msgid "~ applied to negative number ~"
msgstr "~ aplicado al número negativo ~"

# Duda: long-float es un tipo, así que lo dejo como `LONG-FLOAT'. Aunque
# Bruno Haible y Marcus Daniels lo han puesto como `long float' se
# refieren al tipo `long-float'
# Sugerencia: `long float'. sv
#
# No estoy de acuerdo con la sugerencia. No se trata de que `long' sea
# un adjetivo de `float', sino que en CLisp existe el tipo "long-float"
# (Common Lisp The Language, 2nd edition, Guy L. Steele, pag. 39). De
# hecho, en muchos otros sitios de CLisp se pone "long-float". Más aún,
# la traducción francesa de este mensaje es: "LONG-FLOAT trop long".
#
# De hecho, en mi opinion, Bruno Haible y Marcus Daniels se equivocaron
# aquí y debían haber puesto el guión. cll
#
#: lfloat.d:7
msgid "long float too long"
msgstr "LONG-FLOAT demasiado largo"

#: flo_konv.d:446
msgid "floating point NaN occurred"
msgstr "aparición de NaN en coma flotante"

# Duda: ¿alguien sabe qué es eso de ARexx?
#
#: rexx.d:34
msgid "Communication with ARexx isn't possible."
msgstr "La comunicación con ARexx no es posible."

#
# Siguiendo con las recomendaciones de Santiago y de "spanglish",
# `command' será `orden' - cll
#
#: rexx.d:116
msgid "~ must be a string for commands or a vector of strings for a function"
msgstr "~ debe ser una cadena para órdenes o un vector de cadenas para una función"

#: rexx.d:125
msgid "~: an ARexx function must have 0 to ~ arguments: ~"
msgstr "~: Una función ARexx debe tener entre 0 y ~ argumentos: ~"

#: rexx.d:139
msgid "~: must be a string for ARexx: ~"
msgstr "~: debe ser una cadena para ARexx: ~"

#: rexx.d:161
msgid "Only NIL, T and strings are accepted for ~ : ~"
msgstr "~ sólo acepta NIL, T o cadenas de caracteres: ~"

#: rexx.d:474
msgid "~: Not a Fixnum: ~"
msgstr "~: No es del tipo Fixnum: ~"

#: rexx.d:484
msgid "~: Not an incoming Rexx message: ~"
msgstr "~: No es un nuevo mensaje Rexx: ~"

#: affi.d:85
msgid "~: Unsupported call mechanism: ~"
msgstr "~: mecanismo de llamado no soportado: ~"

#: affi.d:96
msgid "~: Bad function prototype: ~"
msgstr "~: Prototipo de función incorrecto: ~"

#: affi.d:107
msgid "~: Wrong number of arguments for prototype ~"
msgstr "~: número incorrecto de argumentos para el prototipo ~"

#: affi.d:121
msgid "~: Bad argument for prototype ~: ~"
msgstr "~: Argumento incorrecto para el prototipo ~: ~"

#: affi.d:132
msgid "~: Bad argument: ~"
msgstr "~: El argumento ~ es inválido"

#: affi.d:153
msgid "~: ~ is not a valid address"
msgstr "~: ~ no es una dirección válida"

#: foreign.d:27
msgid "~ comes from a previous Lisp session and is invalid"
msgstr "~ proviene de una sesion anterior de Lisp y es inválido"

#: foreign.d:100
msgid "A foreign variable ~ already exists"
msgstr "La variable extranjera ~ ya existe"

# Duda: he traducido `foreign' por `ajeno/a'.
#
# Lo he pensado mejor y `extranjera' me gusta mucho más, ..., ¿qué os
# parece? cll
#
#: foreign.d:140
msgid "A foreign function ~ already exists"
msgstr "La función extranjera ~ ya existe"

#: foreign.d:182
msgid "illegal foreign data type ~"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign.d:196
msgid "~ cannot be converted to the foreign type ~"
msgstr "~ no puede ser compartido al tipo extranjero ~"

#: foreign.d:209
msgid "64 bit integers are not supported on this platform and with this C compiler: ~"
msgstr "los enteros de 64 bits no están soportados en esta arquitectura, para este compilador de C:"

#: foreign.d:353 foreign.d:519
msgid "~ cannot be converted to a foreign function with another calling convention."
msgstr "~ no puede ser convertido a una función extranjera con otra convención de llamada."

#: foreign.d:564
msgid "No more room for foreign language interface"
msgstr "No queda espacio para el interfaz con otros lenguajes"

#: foreign.d:573
msgid ":MALLOC-FREE is not available under AMIGAOS."
msgstr ":MALLOC-FREE no está disponible en AMIGAOS."

#: foreign.d:1101 foreign.d:1162 foreign.d:1317 foreign.d:1358
msgid "element type has size 0: ~"
msgstr "el tipo del elemento tiene tamaño 0: ~"

#: foreign.d:2104
msgid "~: argument is not a foreign variable: ~"
msgstr "~: el argumento no es una variable extranjera: ~"

#: foreign.d:2114
msgid "~: foreign variable with unknown type, missing DEF-C-VAR: ~"
msgstr "~: variable externa de tipo desconocido, se ha omitido DEF-C-VAR: ~"

#: foreign.d:2128
msgid "A foreign variable ~ does not exist"
msgstr "La variable extranjera ~ no existe"

#: foreign.d:2140
msgid "~: foreign variable ~ does not have the required size or alignment"
msgstr "~: la variable externa ~ no tiene el tamaño o alineamiento requerido"

#: foreign.d:2154
msgid "~: type specifications for foreign variable ~ conflict: ~ and ~"
msgstr "~: conflicto de especificación de tipo de la variable extranjera ~: ~ y ~"

#: foreign.d:2203
msgid "~: foreign variable ~ may not be modified"
msgstr "~: no se puede modificar la variable externa ~"

#: foreign.d:2263
msgid "~: foreign variable ~ of type ~ is not an array"
msgstr "~: la variable externa ~ del tipo ~ no es una matriz"

#: foreign.d:2349
msgid "~: foreign variable ~ of type ~ is not a pointer"
msgstr "~: la variable externa ~ del tipo ~ no es un puntero"

#: foreign.d:2453
msgid "~: foreign variable ~ of type ~ is not a struct or union"
msgstr "~: la variable externa ~ del tipo ~ no es, ni una estructura, ni una unión"

#: foreign.d:2462
msgid "~: foreign variable ~ of type ~ has no component with name ~"
msgstr "~: la variable externa ~ del tipo ~ no tiene ningún componente con el nombre ~"

#: foreign.d:2532 foreign.d:3624
msgid "~: foreign variable ~ does not have the required alignment"
msgstr "~: la variable externa ~ no tiene el alineamiento requerido"

#: foreign.d:2548
msgid "~: argument is not a foreign function: ~"
msgstr "~: el argumento no es una función extranjera: ~"

#: foreign.d:2559
msgid "~: foreign function with unknown calling convention, missing DEF-CALL-OUT: ~"
msgstr "~: función externa con convención de llamada desconocida, se ha omitido DEF-CALL-OUT: ~"

#: foreign.d:2577 foreign.d:3650
msgid "~: illegal foreign function type ~"
msgstr "~: tipo de función externa inválido ~"

#: foreign.d:2585
msgid "~: A foreign function ~ does not exist"
msgstr "~: La función extranjera ~ no existe"

#: foreign.d:2592
msgid "~: calling conventions for foreign function ~ conflict"
msgstr "~: conflicto en la convención de llamada de la función externa ~"

#: foreign.d:2875
msgid "~: Too few arguments (~ instead of at least ~) to ~"
msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#: foreign.d:2887
msgid "~: :OUT argument is not a pointer: ~"
msgstr "~: el argumento :OUT no es un puntero: ~"

#: foreign.d:2932
msgid "~: Too many arguments (~ instead of ~) to ~"
msgstr "~: Demasiados argumentos (~ en vez de ~) para ~"

#: foreign.d:3501
msgid "~: Cannot open library ~"
msgstr "~: No se puede abrir la biblioteca ~"

#: foreign.d:3598
msgid "~: ~ is not a library"
msgstr "~: ~ no es una biblioteca"

#: amigaaux.d:212
msgid "This version of CLISP runs only in low address memory.\n"
msgstr ""

#: init.lsp:349
msgid "~S is a special form and may not be redefined."
msgstr "~S es una forma especial y por ello, no puede ser redefinida"

#: clos.lsp:205 init.lsp:355
msgid "The old definition will be lost"
msgstr "Se perderá la definición anterior."

#: init.lsp:356
msgid "Redefining the COMMON LISP ~A ~S"
msgstr "La ~A de COMMON LISP ~S será redefinida"

# Junto las ¡! sv
# Sugerencia "¡Se estaba trazando!" (es como más "en español") sv
#
# Sí, tu sugerencia me gusta. Como se nota que tienes experiencia, ...,
# ¿eh? cll
#
#: init.lsp:373
msgid "DEFUN/DEFMACRO: redefining ~S; it was traced!"
msgstr "DEFUN/DEFMACRO: redefiniendo ~S; ¡se estaba rastreando!"

#: init.lsp:393
msgid "~S is impossible in compiled code"
msgstr "~S es imposible en código compilado"

#: init.lsp:480
msgid "~S is an invalid function environment"
msgstr "~S es un entorno de función inválido"

#: init.lsp:527
msgid "~S is an invalid variable environment"
msgstr "~S es un entorno de variable inválido"

#: init.lsp:592
msgid "~S: ~S is illegal since ~S is a local macro"
msgstr "~S: ~S es inválido, puesto que ~S es una macro local"

#: init.lsp:596
msgid "~S: invalid function environment ~S"
msgstr "~S: ~S es un entorno de función inválido"

#: init.lsp:602
msgid "~S: ~S is invalid since ~S is not a symbol"
msgstr "~S: ~S es incorrecto, puesto que ~S no es un símbolo"

#: init.lsp:776
msgid "code after MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de MACROLET contiene una lista punteada que termina con ~S"

#: init.lsp:792
msgid "illegal syntax in MACROLET: ~S"
msgstr "sintaxis inválida en MACROLET: ~S"

#: init.lsp:801
msgid "code after SYMBOL-MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de SYMBOL-MACROLET contiene una lista punteada que termina con ~S"

#: compiler.lsp:7129 init.lsp:810
msgid "~S: symbol ~S must not be declared SPECIAL and a macro at the same time"
msgstr "~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo"

#: compiler.lsp:7124 init.lsp:825
#, fuzzy
msgid "~S: symbol ~S is declared special and must not be declared a macro"
msgstr "~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo"

#: init.lsp:832
msgid "illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "sintaxis inválida en SYMBOL-MACROLET: ~S"

#: init.lsp:870
msgid "bad function environment occurred in ~S: ~S"
msgstr "se encontró un entorno de función incorrecto en ~S: ~S"

#: init.lsp:879
msgid "~S: invalid form ~S"
msgstr "~S: forma inválida ~S"

#: init.lsp:890
msgid "code contains a dotted list, ending with ~S"
msgstr "el código contiene una lista punteada que termina con ~S"

#: init.lsp:933
msgid "~S: ~S should be a lambda expression"
msgstr "~S: ~S debe ser una expresión lambda"

#: init.lsp:974
msgid "lambda list must not end with the atom ~S"
msgstr "la lista lambda no debe terminar con el átomo ~S"

#: init.lsp:1006 init.lsp:1023
msgid "~S: variable list ends with the atom ~S"
msgstr "~S: la lista de variables termina con el átomo ~S"

#: init.lsp:1136
msgid "FLET/LABELS: code contains a dotted list, ending with ~S"
msgstr "FLET/LABELS: el código contiene una lista punteada que termina con ~S"

#: init.lsp:1145
msgid "illegal syntax in FLET/LABELS: ~S"
msgstr "sintaxis inválida en FLET/LABELS: ~S"

#: init.lsp:1280
msgid "Loading file "
msgstr "Cargando el fichero \""

#: init.lsp:1282
msgid " ..."
msgstr " ..."

#: init.lsp:1308
msgid "Loading of file "
msgstr "La carga del fichero "

# Nota: `is finished' debería traducirse por `está finalizado' o `está
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: init.lsp:1310
msgid " is finished."
msgstr " ha finalizado."

#: init.lsp:1317
msgid "A file with name ~A does not exist"
msgstr "No existe ningún fichero con el nombre ~A"

#: init.lsp:1331
msgid "~S: missing function name and/or parameter list"
msgstr "~S: no se ha indicado el nombre de la función y/o la lista de parámetros"

#: init.lsp:1339
msgid "~S: ~S is not a symbol."
msgstr "~S: ~S no es un símbolo."

#: init.lsp:1344
msgid "~S: special form ~S cannot be redefined."
msgstr "~S: la forma especial ~S no puede ser redefinida."

#: init.lsp:1389 macros1.lsp:148
msgid "exit clause in ~S must be a list"
msgstr "la cláusula exit en ~S debe ser una lista"

#: init.lsp:1540
msgid "~S: cannot define a function from that: ~S"
msgstr "~: no es posible definir una función a partir de ~S"

#: clos.lsp:2947 clos.lsp:3004 init.lsp:1545
msgid "~S: the name of a function must be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: init.lsp:1550
msgid "~S: function ~S is missing a lambda list"
msgstr "~S: la función ~S debe tener una lista lambda"

#: conditio.lsp:1464 init.lsp:1780 reploop.lsp:308
msgid "If you continue (by typing 'continue'): "
msgstr "Si continúa (tecleando `continue'): "

# Duda: Aquí, igual que en el caso de la traducción francesa, he
# preferido preservar el término `backquote' y ---porque así se ha
# decidido en Spanish GNU Translation Team---, el término está con
# comillas simples.
#
# He tomado esta decisión porque el `backquote' (que es la tilde
# invertida `) es un término muy familiar para todos los programadores
# de Lisp que, con toda seguridad, conocerán.
#
#: backquot.lsp:39
msgid "~S: comma is illegal outside of backquote"
msgstr "~S: la coma es inválida fuera del `backquote'"

#: backquot.lsp:44
msgid "~S: more commas out than backquotes in, is illegal"
msgstr "~S: no se pueden emplear más comas fuera que apóstrofes invertidos dentro"

#: backquot.lsp:205
msgid "The syntax ,@form is valid only in lists"
msgstr "La sintaxis ,@forma es válida únicamente en las listas"

#: backquot.lsp:210
msgid "The syntax ,.form is valid only in lists"
msgstr "La sintaxis ,.forma es válida únicamente en las listas"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# A partir de la versión 1997-05-03, este mensaje ha cambiado y se
# refiere a elementos que serán ignorados. Como no puede anticiparse
# cual será el género del objeto que se ignora, he preferido poner lo de
# os/as. ¿Qué os parece?
#
#: defmacro.lsp:44
msgid "Both will be ignored."
msgstr "Ambos/as serán ignorados/as."

#: defmacro.lsp:45
msgid "Invalid keyword-value-pair: ~S ~S"
msgstr "Par argumento clave y valor inválido: ~S ~S"

#: defmacro.lsp:54
msgid "The macro ~S may not be called with ~S arguments: ~S"
msgstr "La macro ~S no puede ser invocada con ~S argumentos: ~S"

#: defmacro.lsp:125 defmacro.lsp:150 defmacro.lsp:295
msgid "The rest of the lambda list will be ignored."
msgstr "El resto de la lista lambda será ignorado."

#: defmacro.lsp:126
msgid "The lambda list of macro ~S contains a dot after &AUX."
msgstr "La lista lambda de la macro ~S contiene un punto después de &AUX"

#: defmacro.lsp:132
msgid "in macro ~S: ~S may not be used as &AUX variable."
msgstr "en la macro ~S: ~S no debe usarse como una variable &AUX."

#: defmacro.lsp:151
msgid "The lambda list of macro ~S contains a dot after &KEY."
msgstr "La lista lambda de la macro ~S contiene un punto después de &KEY"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
#: defmacro.lsp:160 defmacro.lsp:178 defmacro.lsp:374 defmacro.lsp:390 defmacro.lsp:395
msgid "It will be ignored."
msgstr "Será ignorado."

#: defmacro.lsp:161
msgid "The lambda list of macro ~S contains a badly placed ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S mal situado."

#: defmacro.lsp:179
msgid "The lambda list of macro ~S contains the invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene el elemento inválido ~S"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# No tengo ni idea de qué significa ese "0*"
#: defmacro.lsp:209
msgid "~0*It will be ignored."
msgstr "Será ignorado."

#: defmacro.lsp:210
msgid "The lambda list of macro ~S contains an invalid keyword specification ~S"
msgstr "La lista lambda de la macro ~S contiene una especificación de argumento clave inválida: ~S"

#: defmacro.lsp:281
msgid "The lambda list of macro ~S is missing a variable after &REST/&BODY."
msgstr "La lista lambda de la macro ~S necesita una variable después de &REST/&BODY."

#: defmacro.lsp:286
msgid "The lambda list of macro ~S contains an illegal variable after &REST/&BODY: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable inválida después de &REST/&BODY: ~S"

#: defmacro.lsp:296
msgid "The lambda list of macro ~S contains a misplaced dot."
msgstr "La lista lambda de la macro ~S contiene un punto mal situado."

# Ojo. sv
#
# :) Vale :) cll
#
#: defmacro.lsp:301
msgid "They will be ignored."
msgstr "Serán ignorados."

#: defmacro.lsp:302
msgid "The lambda list of macro ~S contains superfluous elements: ~S"
msgstr "La lista lambda de la macro ~S contiene elementos innecesarios: ~S"

#: defmacro.lsp:355
msgid "The lambda list of macro ~S contains an illegal &REST variable: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable &REST inválida: ~S"

#: defmacro.lsp:369
msgid "The lambda list of macro ~S contains an invalid &WHOLE: ~S"
msgstr "La lista lambda de la macro ~S contiene un &WHOLE inválido: ~S"

#: defmacro.lsp:375
msgid "The lambda list of macro ~S contains a superfluous ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S innecesario."

#: defmacro.lsp:391
msgid "The lambda list of macro ~S contains ~S before &KEY."
msgstr "La lista lambda de la macro ~S contiene ~S antes de &KEY."

#: defmacro.lsp:396
msgid "The lambda list of macro ~S contains ~S which is illegal here."
msgstr "La lista lambda de la macro ~S contiene ~S, lo cual es incorrecto aquí."

#: defmacro.lsp:415
msgid "The lambda list of macro ~S contains an invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene un elemento inválido: ~S"

#: defmacro.lsp:429
msgid "The lambda list of macro ~S contains an invalid supplied-variable ~S"
msgstr "La lista lambda de la macro ~S contiene una \"variable-proporcionada\" inválida ~S"

#: defmacro.lsp:491
msgid "In the lambda list of macro ~S, &ENVIRONMENT must be followed by a non-NIL symbol: ~S"
msgstr "En la lista lambda de la macro ~S, &ENVIRONMENT debe estar seguido de un símbolo no nulo: ~S"

#: defmacro.lsp:513
msgid "Cannot define a macro from that: ~S"
msgstr "No se puede definir una macro a partir de: ~S"

#: defmacro.lsp:518
msgid "The name of a macro must be a symbol, not ~S"
msgstr "El nombre de una macro debe ser un símbolo, no ~S"

#: defmacro.lsp:523
msgid "Macro ~S is missing a lambda list."
msgstr "La macro ~S necesita una lista lambda."

#: macros1.lsp:11 macros1.lsp:34
msgid "~S: non-symbol ~S can't be a variable"
msgstr "~S: sólo los símbolos pueden ser variables, y no ~S"

#: macros1.lsp:16 macros1.lsp:39
msgid "~S: the constant ~S must not be redefined to be a variable"
msgstr "~S: la constante ~S no debe redefinirse como una variable"

#: macros1.lsp:53
msgid "~S: non-symbol ~S can't be a defined constant"
msgstr "~S: ~S no es un símbolo, y por lo tanto no puede definirse como una constante"

#: macros1.lsp:86
msgid "~S redefines the constant ~S. Its old value was ~S."
msgstr "~S redefine la constante ~S. Su valor anterior era ~S."

#: macros1.lsp:153
msgid "Invalid syntax in ~S form: ~S."
msgstr "Sintaxis inválida en la forma ~S: ~S."

#: macros1.lsp:269 places.lsp:697
msgid "~S called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: macros1.lsp:321
msgid "~S: missing key list"
msgstr "~S: falta la lista de claves"

#: macros1.lsp:328
msgid "~S: the ~S clause must be the last one"
msgstr "~S: la clausula ~S debe ser la última"

#: macros1.lsp:381 macros1.lsp:454
msgid "Not a list of COND clauses: ~S"
msgstr "No es una lista de cláusulas COND: ~S"

#: macros1.lsp:386 macros1.lsp:459
msgid "The atom ~S must not be used as a COND clause."
msgstr "El átomo ~S no debe usarse como una cláusula COND."

#: macros1.lsp:422
msgid "COND code contains a dotted list, ending with ~S"
msgstr "El código de COND contiene una lista punteada que termina con ~S"

#: compiler.lsp:7180 macros1.lsp:428
msgid "COND clause without test: ~S"
msgstr "Cláusula COND sin prueba condicional: ~S"

#: macros2.lsp:40
msgid "Language ~S is not defined"
msgstr "El lenguaje ~S no está definido"

#: macros2.lsp:50
msgid "Language ~S inherits from ~S"
msgstr "El lenguaje ~S hereda de ~S"

#: macros2.lsp:100
msgid "~S: Language ~S is not defined"
msgstr "~S: El lenguaje ~S no está definido"

#: macros2.lsp:123
msgid "~S ~S: no value for default language ~S"
msgstr "~S ~S: no hay ningún valor para el lenguaje por defecto ~S"

#: macros2.lsp:138
msgid "Invalid clause in ~S: ~S"
msgstr "Cláusula inválida en ~S: ~S"

#: macros2.lsp:157
msgid "~A~%The value is: ~S"
msgstr "~A~%El valor es: ~S"

#: macros2.lsp:161
msgid "The value of ~S should be ~:[of type ~S~;~:*~A~]."
msgstr "El valor de ~S debe ser ~:[del tipo ~S~;~:*~A~]."

#: macros2.lsp:165
msgid "You may input a new value."
msgstr "Puede introducir un nuevo valor."

#: macros2.lsp:168
msgid "~%New ~S: "
msgstr "~%Nuevo ~S: "

#: macros2.lsp:189
msgid "Retry"
msgstr "Reintentar"

#: macros2.lsp:192
msgid "You may input new values."
msgstr "Puede introducir nuevos valores."

#: macros2.lsp:196
msgid "~S must evaluate to a non-NIL value."
msgstr "~S no puede evaluarse como NIL."

#: macros2.lsp:232
msgid "The value of ~S must be of one of the types ~{~S~^, ~}"
msgstr "El valor de ~S debe ser de uno de los tipos ~{~S~^, ~}"

#: macros2.lsp:237
msgid "The value of ~S must be one of ~{~S~^, ~}"
msgstr "El valor de ~S debe ser uno de los siguientes ~{~S~^, ~}"

#: conditio.lsp:1292 macros2.lsp:253
msgid "~S used as a key in ~S, it would be better to use parentheses."
msgstr "~S es usado como una clave en ~S, sería mejor utilizar paréntesis."

#: macros2.lsp:338
msgid "type name should be a symbol, not ~S"
msgstr "el nombre del tipo debe ser un símbolo, no ~S"

#: macros2.lsp:343
msgid "~S is a built-in type and may not be redefined."
msgstr "~S es un tipo predefinido y no puede ser redefinido."

#: macros2.lsp:376
msgid "The deftype expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de DEFTYPE para ~S no puede invocarse con ~S argumentos."

#: macros2.lsp:384
msgid "~S: the name of a symbol macro must be a symbol, not ~S"
msgstr "~S: el nombre de un símbolo de macro debe ser un símbolo, no ~S"

#: macros2.lsp:399
msgid "~S: the symbol ~S names a global variable"
msgstr "~S: el símbolo ~S nombra una variable global"

#: defs1.lsp:98
msgid "missing symbol types (~S/~S/~S) in ~S"
msgstr ""

#: defs1.lsp:105
#, fuzzy
msgid "~S: flag must be one of the symbols ~S, ~S, ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: defs1.lsp:418
msgid "~S: ~S does not name a logical host"
msgstr "~S: ~S no es el nombre de un anfitrión \"lógico\""

#: defs1.lsp:456
msgid "No translations for logical host ~S found"
msgstr ""

#: defs1.lsp:542
msgid "~S: argument ~S should be a nonnegative number"
msgstr "~S: el argumento ~S debe ser un número no negativo"

#: defs1.lsp:704
msgid "incorrect date: ~S.~S.~S, ~Sh~Sm~Ss, time zone ~S"
msgstr "fecha incorrecta: ~S/~S/~S, ~Sh~Sm~Ss, zona horaria ~S"

#: defs1.lsp:773
msgid "special form"
msgstr "forma especial"

#: defs1.lsp:776
msgid "function"
msgstr "función"

#: defs1.lsp:778
msgid "macro"
msgstr "macro"

#: places.lsp:24
msgid "The function (~S ~S) is hidden by a SETF expander."
msgstr "Una función de expansión de SETF oculta a la función (~S ~S)"

#: places.lsp:85
msgid "The argument ~S to ~S should be a keyword."
msgstr "El argumento ~S de ~S debe ser un argumento clave."

# Lo mismo de antes. A lo mejor se puede poner "modificable setf". sv
#: places.lsp:140
msgid "Argument ~S is not a SETF place."
msgstr "El argumento ~S no es un lugar `setf' modificable"

#: places.lsp:153
msgid "SETF place ~S produces more than one store variable."
msgstr "El lugar `setf' ~ genera más de una variable de almacenamiento."

#: places.lsp:177 places.lsp:185
msgid "~S: first argument ~S is illegal, not a symbol"
msgstr "~S: el primer argumento ~S es inválido, no es un símbolo"

#: places.lsp:221
msgid "The name of the access function must be a symbol, not ~S"
msgstr "El nombre de la función de acceso debe ser un símbolo, no ~S"

# Duda: En esta y otras partes de este archivo .po aparece la expresión
# `expander' (¡expansor es horrible!). Me dio muchisimos quebraderos de
# cabeza, pero muchos y francamente, estaba absolutamente atascado
# cuando lo pregunté en las listas de Spanish GNU y CLisp.
#
# Curiosamente, la única persona que respondió no tiene ni idea de
# español (Bruno Haible):
#
# "expander" or "expansion function", I would say.
#
# ¡Pues leches, eso mismo! Función de expansión me suena
# perfectísimamente, ...
#
#: places.lsp:254
msgid "The SETF expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de SETF para ~S no puede invocarse con ~S argumentos."

#: places.lsp:291
msgid "Too many arguments to DEFSETF: ~S"
msgstr "Demasiados argumentos para DEFSETF: ~S"

#: places.lsp:295
msgid "The doc string to DEFSETF must be a string: ~S"
msgstr "La cadena de documentación de DEFSETF debe ser una cadena: ~S"

#: places.lsp:305
msgid "Missing store variable in DEFSETF."
msgstr "No se encuentra ninguna variable de almacenamiento en DEFSETF."

#: places.lsp:346
msgid "Illegal syntax in DEFSETF for ~S"
msgstr "Sintaxis inválida en DEFSETF: ~S"

#: places.lsp:359
msgid "(SETF (NTH ...) ...) : index ~S is too large for ~S"
msgstr "(SETF (NTH ...) ...) : el índice ~S es demasiado grande para ~S"

#: places.lsp:459
#, fuzzy
msgid "PSETF called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: places.lsp:505
msgid "REMF: property list with an odd length"
msgstr "REMF: lista de propiedades de longitud impar"

#: places.lsp:555
msgid "In the definition of ~S: &REST variable ~S should be a symbol."
msgstr "En la definición de ~S: la variable &REST ~S debe ser un símbolo."

#: places.lsp:561
msgid "Only one variable is allowed after &REST, not ~S"
msgstr "Sólo se permite una variable después de &REST, no ~S"

#: places.lsp:566
msgid "Illegal in a DEFINE-MODIFY-MACRO lambda list: ~S"
msgstr "Lista lambda inválida en DEFINE-MODIFY-MACRO: ~S"

#: places.lsp:574
msgid "lambda list may only contain symbols and lists, not ~S"
msgstr "la lista lambda sólo puede contener símbolos y listas, no ~S"

# En cristiano creo que sería "Lugar SETF incorrecto". sv
#
# Sí, tienes razón. Creo que cuando traduje este mensaje llevaba
# demasiadas horas delante del ordenador, ... tienes razón, ... cll
#
#: places.lsp:691
msgid "Illegal SETF place: ~S"
msgstr "Lugar `setf' inválido: ~S"

#: places.lsp:710
msgid "SHIFTF called with too few arguments: ~S"
msgstr "SHIFTF ha sido llamado con muy pocos argumentos: ~S"

#: places.lsp:750
msgid "(SETF (GETF ...) ...) : property list with an odd length"
msgstr "(SETF (GETF ...) ...) : lista de propiedades de longitud impar"

#: places.lsp:785
msgid "first argument ~S is illegal, not a symbol"
msgstr "el primer argumento ~S es inválido, no es un símbolo"

#: places.lsp:896
msgid "SETF APPLY is only defined for functions of the form #'symbol."
msgstr "SETF APPLY sólo está definido para funciones de la forma #'símbolo."

# Duda: en Common Lisp existe lo que se denominan los `setf places'. En
# realidad, es una manera bastante correcta de referirse a posiciones de
# memoria (cuyos nombres pueden ser variables, funciones, etc.) que son
# modificables con la primitiva SETF de Lisp. Por ello, traducirlo como
# `modificable' es eminentemente correcto, pero en realidad me da miedo
# porque a los programadores experimentados les mosqueará lo de
# `modificable' a secas. Les resultará mucho más familiar algo como
# `setf modificables', aunque en español esto suene bastante
# regular. cll
#
# En cualquier caso, cuando uno se empeña en emplear la palabra inglesa,
# siempre queda la posibilidad de conservar la sintaxis española,
# por ejemplo: "... no es un lugar modificable `setf'" sv
#
#: places.lsp:902
msgid "APPLY on ~S is not a SETF place."
msgstr "APPLY de ~S no es un lugar `setf' modificable"

#: places.lsp:957
msgid "SETF FUNCALL is only defined for functions of the form #'symbol."
msgstr "SETF FUNCALL sólo está definido para funciones de la forma #'símbolo."

#: floatpri.lsp:341
msgid "argument is not a float: ~S"
msgstr "el argumento no es un número en coma flotante: ~S"

#: type.lsp:30
msgid "~S: invalid type specification ~S"
msgstr "~S: la especificación de tipo ~S es inválida"

#: compiler.lsp:8321 type.lsp:57
msgid "~S: argument to SATISFIES must be a symbol: ~S"
msgstr "~S: el argumento de SATISFIES debe ser un símbolo: ~S"

#: type.lsp:327 type.lsp:336 type.lsp:346 type.lsp:356
msgid "~S: argument to ~S must be *, ~S or a list of ~S: ~S"
msgstr "~S: el argumento de ~S debe ser *, ~S o una lista de ~S: ~S"

#: type.lsp:443
msgid "~S: argument to MOD must be an integer: ~S"
msgstr "~S: el argumento de MOD debe ser un entero: ~S"

#: type.lsp:451
msgid "~S: argument to SIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de SIGNED-BYTE debe ser un entero o * : ~S"

#: type.lsp:461
msgid "~S: argument to UNSIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de UNSIGNED-BYTE debe ser un entero o * : ~S"

#: type.lsp:635
msgid "Invalid type specifier ~S"
msgstr "Especificador de tipo inválido: ~S"

#: defstruc.lsp:63 foreign1.lsp:423
msgid "~S: this is not a symbol: ~S"
msgstr "~S: esto no es un símbolo: ~S"

#: defstruc.lsp:425
msgid "~S: invalid syntax for name and options: ~S"
msgstr "~S: la sintáxis del nombre y las opciones es inválida: ~S"

#: defstruc.lsp:449
msgid "~S ~S: argument list should be a list: ~S"
msgstr "~S ~S: la lista de argumentos debe ser una lista: ~S"

#: defstruc.lsp:472
msgid "~S ~S: At most one :INCLUDE argument may be specified: ~S"
msgstr "~S ~S: Sólo puede especificarse un argumento :INCLUDE como mucho: ~S"

#: defstruc.lsp:480
msgid ""
"~S: Use of ~S implicitly applies FUNCTION.~@\n"
"                                     Therefore using ~S instead of ~S."
msgstr ""
"~S: El uso de ~S aplica, implícitamente, FUNCTION.~@\n"
"                                     Por lo tanto, se utilizará ~S en vez de ~S."

#: conditio.lsp:106 defstruc.lsp:493
msgid "~S ~S: unknown option ~S"
msgstr "~S ~S: opción ~S desconocida"

#: clos.lsp:3082 conditio.lsp:112 defstruc.lsp:497
msgid "~S ~S: invalid syntax in ~S option: ~S"
msgstr "~S ~S: la sintaxis de la opción ~S es inválida: ~S"

#: clos.lsp:3017 conditio.lsp:116 defstruc.lsp:501
msgid "~S ~S: not a ~S option: ~S"
msgstr "~S ~S: no se trata de una opción ~S: ~S"

# Duda: (y además gorda) Podría parecer que el siguiente mensaje debiera
# traducirse por:
#
# ~S ~S: No hay ningún :PREDICATE sobre estructuras sin nombre.
#
# Sin embargo, el manual "Common Lisp, The Language - 2nd Edition", en
# la página 477 advierte que, en realidad, la opción :PREDICATE no debe
# usarse con estructuras sin nombre:
#
# `A predicate can be defined only if the structure is "named"'
#
# Por lo tanto, he preferido traducir este mensaje de otra manera, tal y
# como veis:
#
#: defstruc.lsp:525
msgid "~S ~S: There is no :PREDICATE on unnamed structures."
msgstr "~S ~S: No puede definirse un :PREDICATE sobre estructuras sin nombre."

#: defstruc.lsp:551
msgid "~S ~S: invalid :TYPE option ~S"
msgstr "~S ~S: opción :TYPE inválida ~S"

#: defstruc.lsp:557
msgid "~S ~S: The :INITIAL-OFFSET must be a nonnegative integer, not ~S"
msgstr "~S ~S: El :INITIAL-OFFSET debe ser un entero no negativo, y no ~S"

#: defstruc.lsp:563
msgid "~S ~S: :INITIAL-OFFSET must not be specified without :TYPE : ~S"
msgstr "~S ~S: El :INITIAL-OFFSET no debe especificarse sin :TYPE : ~S"

#: defstruc.lsp:581
msgid "~S ~S: included structure ~S has not been defined."
msgstr "~S ~S: la estructura incluida ~S no ha sido definida."

#: defstruc.lsp:593
msgid "~S ~S: included structure ~S must be of the same type ~S."
msgstr "~S ~S: la estructura incluida ~S debe ser del tipo ~S."

#: defstruc.lsp:618
msgid "~S ~S: included structure ~S has no component with name ~S."
msgstr "~S ~S: la estructura incluida ~S no tiene ninguna componente con el nombre ~S."

#: defstruc.lsp:647
msgid "~S ~S: The READ-ONLY slot ~S of the included structure ~S must remain READ-ONLY in ~S."
msgstr "~S ~S: La ranura READ-ONLY ~S de la estructura incluida ~S debe permanecer READ-ONLY en ~S."

#: defstruc.lsp:657
msgid "~S ~S: The type ~S of slot ~S should be a subtype of the type defined for the included strucure ~S, namely ~S."
msgstr "~S ~S: El tipo ~S de la ranura ~S debe ser un subtipo del que ha sido definido para la estructura incluida ~S, a saber, ~S."

#: defstruc.lsp:663 defstruc.lsp:761
msgid "~S ~S: ~S is not a slot option."
msgstr "~S ~S: ~S no es una opción de ranura."

#: defstruc.lsp:695
msgid "~S ~S: structure of type ~S can't hold the name."
msgstr "~S ~S: una estructura del tipo ~S no puede contener el nombre."

#: defstruc.lsp:747
msgid "~S ~S: There may be only one slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura con el nombre ~S."

#: format.lsp:70
msgid "The control string terminates within a directive."
msgstr "La cadena de control termina en una directiva."

#: format.lsp:137
msgid "~A must introduce a number."
msgstr "~A debe introducir un número."

#: format.lsp:147
msgid "The control string terminates in the middle of a parameter."
msgstr "La cadena de control termina en medio de un parámetro."

#: format.lsp:227
msgid "Non-existent directive"
msgstr "Directiva no existente"

#: format.lsp:235
msgid "Closing '/' is missing"
msgstr ""

#: format.lsp:248
#, fuzzy
msgid "There is no package with name ~S"
msgstr "No hay ningún paquete con el nombre ~"

#: format.lsp:263
msgid "The closing directive '~A' does not have a corresponding opening one."
msgstr "No existe una directiva de apertura para la de cierre `~A'."

#: format.lsp:268
msgid "The closing directive '~A' does not match the corresponding opening one. It should read '~A'."
msgstr "La directiva de cierre `~A' no se corresponde con la de apertura. Debe leerse `~A'."

#: format.lsp:277 format.lsp:1641 format.lsp:2445
msgid "The ~~; directive is not allowed at this point."
msgstr "La directiva ~~; no está permitida aquí."

#: format.lsp:287
msgid "The ~~newline directive cannot take both modifiers."
msgstr "La directiva ~~newline no puede tomar ambos modificadores."

# Ojo: Estos "ing" no son siempre gerundios.
# Tal vez sea simplemente "...; se esperaba '~A'." sv
#
# Bueno, ..., cuando el mensaje ha salido es que se ha producido un
# error. En tal caso, no se puede estar `esper*ando*', sino que se
# esperaba, ... Si, creo que tienes toda la razón. cll
#
#: format.lsp:308
msgid "An opening directive is never closed; expecting '~A'."
msgstr "No se ha cerrado una directiva; se esperaba `~A'."

#: format.lsp:333
msgid "~%Current point in control string:"
msgstr "~%Posición en curso en la cadena de control:"

# Duda: `fill pointer' (puntero de llenado, o de relleno) es un
# recurso que existe en Common Lisp (y por lo tanto, en CLisp) para
# determinar qué parte de un vector está en uso (la que hay desde el
# principio hasta la posición apuntada por el `fill pointer'). Se trata
# de un término que cualquier programador en Lisp debe conocer porque
# esta palabra clave se utiliza en ocasiones, incluso, como palabra
# reservada para indicar una determinada opción en algunas funciones.
#
# Por ese motivo, he decidido dejarla tal cual, sin traducir. Cuando
# pregunté a Bruno Haible sobre esto me respondió:
#
# Imagine a device attached to a bottle or tank, which shows how much full
# the bottle is, in percent. How would you call this device?
#
# ... y francamente, ¡no se me ocurre como!
#
# Bueno, con el tiempo he decidido que (tal y como señala Bruno Haible)
# lo mejor sería: "puntero de relleno".
#
#: format.lsp:383
msgid "The destination string ~S should have a fill pointer."
msgstr "La cadena de destino ~S debe tener un puntero de relleno."

#: format.lsp:390
msgid "The destination argument ~S is invalid (not NIL or T or a stream or a string)."
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

#: format.lsp:419
msgid "~S: The control-string must be a string, not ~S"
msgstr "~S: La cadena de control debe ser una cadena, y no ~S"

#: format.lsp:430
msgid "There are not enough arguments left for this directive."
msgstr "No hay argumentos suficientes para esta directiva."

#: format.lsp:528
msgid "The ~~:@R directive requires an integer in the range 1 - 4999, not ~S"
msgstr "La directiva ~~:@R necesita un entero en el rango 1 - 4999, no ~S"

#: format.lsp:547
msgid "The ~~@R directive requires an integer in the range 1 - 3999, not ~S"
msgstr "La directiva ~~@R necesita un entero en el rango 1 - 3999, no ~S"

#: format.lsp:611
msgid "The argument for the ~~R directive is too large."
msgstr "El argumento de la directiva ~~R es demasiado grande."

#: format.lsp:1331
msgid "The ~~R and ~~:R directives require an integer argument, not ~S"
msgstr "Las directivas ~~R y ~~:R necesitan un argumento entero, no ~S"

#: format.lsp:1353
msgid "The ~~C directive requires a character argument, not ~S"
msgstr "La directiva ~~C necesita un carácter como argumento, no ~S"

#: format.lsp:1579
msgid "The control string argument for the ~~? directive is invalid: ~S"
msgstr "La cadena de control de la directiva ~~? es inválida: ~S"

#: format.lsp:1584
msgid "The argument list argument for the ~~? directive is invalid: ~S"
msgstr "El argumento de la lista de argumentos de la directiva ~~? es inválido: ~S"

#: format.lsp:1646
msgid "The ~~[ parameter must be an integer, not ~S"
msgstr "El parámetro para ~~[ debe ser un entero, no ~S"

#: format.lsp:1665
msgid "The ~~[ directive cannot take both modifiers."
msgstr "La directiva ~~[ no puede tomar ambos modificadores."

#: format.lsp:1691
msgid "The ~~{ directive requires a list argument, not ~S"
msgstr "La directiva ~~{ requiere una lista de argumentos, no ~S"

#: format.lsp:2179
msgid "Too many arguments for this directive"
msgstr "Demasiados argumentos para esta directiva"

#: format.lsp:2718
msgid "The control-string must be a string, not ~S"
msgstr "La cadena de control debe ser una cadena, no ~S"

#: trace.lsp:85 trace.lsp:253
msgid "~S: function name should be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: trace.lsp:95
msgid "~S: undefined function ~S"
msgstr "~S: la función ~S no está definida"

#: trace.lsp:101
msgid "~S: cannot trace special form ~S"
msgstr "~S: no es posible rastrear la forma especial ~S"

#: trace.lsp:112
msgid "~&;; Tracing ~:[function~;macro~] ~S."
msgstr "~&;; Rastreando la ~:[función~;macro~] ~S."

#: trace.lsp:266
msgid "~S: ~S was traced and has been redefined!"
msgstr "~S: ¡~S estaba siendo rastreada y ha sido redefinida!"

# Este es el formato de las fechas, ... Lo he cogido de la traducción
# alemana y de la francesa, donde es al contrario que la inglesa.
#
#: compiler.lsp:215
msgid "~1{~5@*~D/~4@*~D/~3@*~D ~2@*~2,'0D.~1@*~2,'0D.~0@*~2,'0D~:}"
msgstr "~1{~3@*~D/~4@*~D/~5@*~D ~2@*~2,'0D:~1@*~2,'0D:~0@*~2,'0D~:}"

# Duda: En Lisp, todo el mundo sabe lo que es un `closure'. Bueno, me parece
#       que la mejor traducción es `cierre'.
#
# He visto que los traductores del libro Lisp (3ra edición), de Winston
# y Horn, dicen al final de la página 234 y principio de la 235: "Los
# procedimientos objeto, producidos a partir de una combinación de #' y
# lambda se denominan cerraduras léxicas. El término es usado porque la
# palabra cerradura sugiere que se están involucrando cercas, en tanto
# que la palabra léxica sugiere que las cercas son colocadas de acuerdo
# con las reglas del alcance léxico (o visibilidad) (...) Como no existe
# una forma impresa conveniente para la información de las cercas, la
# forma impresa de una cerradura léxica, sin ser clara, aparecería como:
# #<CERRADURA LÉXICA ...>." Pues bien, propongo que cuando se hagan
# referencias al léxico se diga "cerradura léxica" y, en otro caso,
# "cerradura".
#
# Estos términos me parecen mejores que "cierre léxico" o "cierre" - cll
#
#: compiler.lsp:356
msgid "Bad length of closure vector: ~S"
msgstr "Longitud incorrecta del vector de cerradura: ~S"

# Aquí también junto las exclamaciones. sv
#: compiler.lsp:1752
msgid "Compiler bug!! Occurred in ~A~@[ at ~A~]."
msgstr "¡¡Error del compilador!! Ocurrió en ~A~@[ en ~A~]."

# Soy alérgico al verbo "ignorar". Ignorar en español significa no saber.
# Y eso en inglés se dice "not to know".
# Posibilidades: Descartar, no tener en cuenta. sv
#
# :) Bueno, ... :) Lo cierto es que en el diccionario pone:
#
# "No saber una cosa o muchas cosas, o, de lo contrario, no tener
# noticia de ellas."
#
# O sea, que algo se ignora si no se tienen noticias de ello, ... Creo
# que la traducción está, por lo tanto, correcta. Ahora bien, "no tener
# en cuenta" o "descartar" también me parece muy correcto así que, ¿por
# qué no iba a cambiarlo? :) cll
#
#: compiler.lsp:2429
msgid "Bad declaration syntax: ~S~%Will be ignored."
msgstr "Sintaxis de la declaración incorrecta:~S~%No se tendrá en cuenta."

#: compiler.lsp:2449
msgid "Non-symbol ~S may not be declared SPECIAL."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lsp:2456
msgid "Non-symbol ~S may not be declared IGNORE."
msgstr "El \"no símbolo\" ~S no debe declararse IGNORE."

#: compiler.lsp:2463
msgid "Non-symbol ~S may not be declared IGNORABLE."
msgstr "El \"no-símbolo\" ~S no debe declararse IGNORABLE."

#: compiler.lsp:2470
#, fuzzy
msgid "Non-symbol ~S may not be declared READ-ONLY."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lsp:2475
msgid "Unknown declaration ~S.~%The whole declaration will be ignored."
msgstr "Declaración desconocida ~S.~%La declaración completa será ignorada."

#: compiler.lsp:2807
msgid " in line ~D"
msgstr " en la línea ~D"

#: compiler.lsp:2808
msgid " in lines ~D..~D"
msgstr " en las líneas ~D..~D"

#
# Duda: He querido traducir la palabra `warning' por `aviso' que es como
# debería decirse en español, ¿no?. ¿Hay algún término adoptado en
# es@li.org, para esta palabra?.
#
# Sí, atención. sv
#
# Si, si, ya lo he hecho, ... En todas partes he puesto "WARNING" por
# "ATENCIÓN". No es exactamente lo mismo, pero me parece una sugerencia
# genial, de hecho me gusta muchísimo más que aquello de "AVISO:". De
# esta manera, parecía que te estaban hablando los "super-tacañones" :) - cll
#
# Sin embargo, Santiago, este caso es bastante peculiar. Verás, si dejo
# "ATENCIÓN" aquí, entonces, durante la compilación de un proyecto con
# varios ficheros en Lisp, podría salir, por ejemplo, un mensaje como el
# siguiente (tomado de un ejemplo real, que conste, ...):
#
# --------------
# ATENCIÓN en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
# Y yo pregunto, en este caso ¿no es mejor poner "ADVERTENCIA"? La
# verdad es que "ADVERTENCIA" me suena mucho mejor que "ATENCIÓN" y que
# "AVISO". En este caso, lo que se tendría es:
#
# --------------
# ADVERTENCIA en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
#
#: compiler.lsp:2820
msgid "~%WARNING~@[ in function ~S~]~A :~%"
msgstr "~%ADVERTENCIA~@[ en la función ~S~]~A :~%"

#: compiler.lsp:2852
msgid "~%ERROR~@[ in function ~S~]~A :~%~?"
msgstr "~% ERROR~@[ en la función ~S~]~A : ~%~?"

#: compiler.lsp:2993
msgid "Code contains dotted list ~S"
msgstr "El código contiene la lista punteada ~S"

# En ocasiones como esta hemos puesto a veces:
# "insuficiente número de argumentos" sv
#
# ¡Pues no me gusta nada!, todavía si dijeses "número insuficiente de
# argumentos". No se, ..., la verdad es que a mí me gusta mucho más "muy
# pocos argumentos" o, si quieres, "pocos argumentos" pero eso de la
# "insuficiencia", ... (me trae otros recuerdos). cll
#
#: compiler.lsp:2997
msgid "Form too short, too few arguments: ~S"
msgstr "Forma demasiado corta, muy pocos argumentos: ~S"

#: compiler.lsp:3002
msgid "Form too long, too many arguments: ~S"
msgstr "Forma demasiado larga, demasiados argumentos: ~S"

#: compiler.lsp:3141
msgid "Invalid form: ~S"
msgstr "La forma ~S es inválida"

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#: compiler.lsp:3194
msgid "Not the name of a function: ~S"
msgstr "No es el nombre de una función: ~S"

#: compiler.lsp:3269 compiler.lsp:3349
msgid ""
"~S is neither declared nor bound,~@\n"
"                        it will be treated as if it were declared SPECIAL."
msgstr ""
"~S no está ni declarado ni ligado,~@\n"
"                        será tratado como si hubiese sido declarado SPECIAL."

#: compiler.lsp:3366
msgid ""
"The constant ~S may not be assigned to.~@\n"
"                                                  The assignment will be ignored."
msgstr ""
"La constante ~S no puede asignarse. ~@\n"
"                                                  La asignación será ignorada."

#: compiler.lsp:3508
msgid "argument list to function ~S is dotted: ~S"
msgstr "el argumento de la función ~S es una lista punteada: ~S"

#: compiler.lsp:3514
msgid ""
"~S called with ~S~:[~; or more~] arguments, but it requires ~\n"
"                        ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] arguments."
msgstr ""
"~S fue invocado con ~S~:[~; o más~] argumentos, pero requiere ~\n"
"                        ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lsp:3527
msgid "keyword arguments to function ~S should occur pairwise: ~S"
msgstr "los argumentos clave de la función ~S deben aparecer por pares: ~S"

#
# Afortunadamente, la convención ~#[, para imprimir los términos de una
# lista (en inglés, como dice el estándar) sirve perfectamente para el
# español
#
#: compiler.lsp:3538
msgid ""
"keyword ~S is not allowed for function ~S.~\n"
"                              ~%The only allowed keyword~:[s are ~{~S~#[~; and ~S~:;, ~]~}~; is ~{~S~}~]."
msgstr ""
"la palabra clave ~S no está permitida en la función ~S.~\n"
"                              ~%La~:[s~;~] única~:*~:[s~;~] palabra~:*~:[s~;~] clave permitida~:*~:[s son ~{~S~#[~; y ~S~:;, ~]~}~; es ~{~S~}~]."

#: compiler.lsp:3550
#, fuzzy
msgid "argument ~S to function ~S is not a symbol"
msgstr "el argumento ~S para la función ~S no es un argumento clave"

#: compiler.lsp:4218
msgid ""
"~S called with ~S arguments, but it requires ~\n"
"                                   ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] arguments."
msgstr ""
"~S ha sido invocado con ~S argumentos, pero requiere ~\n"
"                                   ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lsp:4398
msgid "Illegal syntax in LET/LET*: ~S"
msgstr "Sintaxis inválida en LET/LET*: ~S"

#: compiler.lsp:4435
msgid "Lambda list marker ~S not allowed here."
msgstr "El marcador de la lista lambda ~S no está permitido aquí."

#: compiler.lsp:4441
msgid "Missing &REST parameter in lambda list ~S"
msgstr "La lista lambda ~S necesita un parámetro &REST"

#: compiler.lsp:4447
msgid "Lambda list element ~S is superfluous."
msgstr "El elemento ~S de la lista lambda es innecesario."

#: compiler.lsp:4622
msgid "Lambda lists with dots are only allowed in macros, not here: ~S"
msgstr "Sólo se permiten las listas lambda con puntos en la macros, no aquí: ~S"

#: compiler.lsp:4638
msgid "Illegal lambda list element ~S"
msgstr "Elemento inválido en lista lambda ~S"

#: compiler.lsp:4734
msgid "Binding variable ~S can cause side effects despite of IGNORE declaration~%since it is declared SPECIAL."
msgstr "Asociar la variable ~S puede causar otros efectos, a pesar de la declaración~%IGNORE puesto que está declarada como SPECIAL."

#: compiler.lsp:4738
msgid "variable ~S is used despite of IGNORE declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lsp:4749
msgid "variable ~S is not used.~%Misspelled or missing IGNORE declaration?"
msgstr "La variable ~S no está siendo usada.~%¿Está mal escrita o es que falta la declaración IGNORE?"

#: compiler.lsp:4755
#, fuzzy
msgid "The variable ~S is assigned to, despite of READ-ONLY declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lsp:4801 compiler.lsp:4937
msgid "Constant ~S cannot be bound."
msgstr "La constante ~S no puede ligarse."

#: compiler.lsp:5685
msgid "Misplaced declaration: ~S"
msgstr "Declaración situada incorrectamente: ~S"

#: compiler.lsp:5897
msgid "Odd number of arguments to SETQ: ~S"
msgstr "Número impar de argumentos de SETQ: ~S"

#: compiler.lsp:5934 compiler.lsp:5971 compiler.lsp:6069
msgid "Cannot assign to non-symbol ~S."
msgstr "No se puede asignar a un \"no-símbolo\" ~S."

#: compiler.lsp:5946
msgid "Odd number of arguments to PSETQ: ~S"
msgstr "Número impar de argumentos de PSETQ: ~S"

#: compiler.lsp:6207
msgid "Only symbols may be used as variables, not ~S"
msgstr "Sólo pueden usarse los símbolos como variables, no ~S"

#: compiler.lsp:6312
msgid "Illegal syntax in COMPILER-LET: ~S"
msgstr "Sintaxis inválida en COMPILER-LET: ~S"

#: compiler.lsp:6320
msgid "Block name must be a symbol, not ~S"
msgstr "El nombre de un bloque debe ser un símbolo, no ~S"

#: compiler.lsp:6369
msgid "RETURN-FROM block ~S is impossible from here."
msgstr "No es posible hacer RETURN-FROM del bloque ~S desde aquí."

#: compiler.lsp:6440
msgid "Only numbers and symbols are valid tags, not ~S"
msgstr "Sólo son etiquetas de salto válidas los números y los símbolos, no ~S"

#: compiler.lsp:6511
msgid "Tag must be a symbol or a number, not ~S"
msgstr "Una etiqueta de salto debe ser un símbolo o un número, no ~S"

#: compiler.lsp:6516
msgid "GO to tag ~S is impossible from here."
msgstr "No es posible ir (GO) a la etiqueta de salto ~S desde aquí."

#: compiler.lsp:6591
msgid "~S is not a function. It is a locally defined macro."
msgstr "~S no es una función. Se trata de una macro definida localmente."

#: compiler.lsp:6627
msgid "Only symbols and lambda expressions are function names, not ~S"
msgstr "Sólo los símbolos y las expresiones lambda son nombres de funciones válidos, no ~S"

#: compiler.lsp:6678
msgid "Illegal function definition syntax in ~S: ~S"
msgstr "La sintaxis para la definición de la función en ~S es inválida: ~S"

#: compiler.lsp:7118
msgid "Illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "Sintaxis inválida en SYMBOL-MACROLET: ~S"

# Duda: He traducido `EVAL-WHEN situation' por `instante de EVAL-WHEN',
# puesto que el primer argumento de EVAL-WHEN es el *instante* en el que
# debe evaluarse la expresión que viene a continuación y, que de hecho,
# puede ser ---como dice el mensaje--- EVAL, LOAD o COMPILE.
#
#: compiler.lsp:7159
msgid "EVAL-WHEN situation must be EVAL or LOAD or COMPILE, but not ~S"
msgstr "El instante de EVAL-WHEN debe ser EVAL, LOAD o COMPILE, pero no ~S"

#: compiler.lsp:7202
msgid "CASE clause without objects: ~S"
msgstr "Cláusula CASE sin objetos: ~S"

#: compiler.lsp:7212
msgid "~S: the ~S clause must be the last one: ~S"
msgstr "~S: la clausula ~S debe ser la última: ~S"

#: compiler.lsp:7222
msgid "Duplicate ~S label ~S : ~S"
msgstr "~S : La etiqueta ~S se repite: ~S"

#: compiler.lsp:7484
msgid "Too many arguments to ~S"
msgstr "Demasiados argumentos para ~S"

#: compiler.lsp:7499
msgid "Too few arguments to ~S"
msgstr "Muy pocos argumentos para ~S"

#: compiler.lsp:8390
#, fuzzy
msgid "The ~S destination is invalid (not NIL or T or a stream or a string with fill-pointer): ~S"
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

# eso de función "a compilar" siempre
# me pareció un vicio moderno.
# Sugerencia: El nombre de la función que hay que compilar ... sv
#
# Perfecto, ... cll
#
#: compiler.lsp:11874
msgid "Name of function to be compiled must be a symbol, not ~S"
msgstr "El nombre de una función que hay que compilar debe ser un símbolo, no ~S"

#: compiler.lsp:11885
msgid "~S: redefining ~S; it was traced!"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: compiler.lsp:11893 compiler.lsp:11926
msgid "~S is already compiled."
msgstr "~S ya está compilada."

#: compiler.lsp:11914 compiler.lsp:12505
msgid "Undefined function ~S"
msgstr "La función ~S no está definida"

# Sugerencia: No es blabla ni bla bla. sv
# El ni se ponía la segunda pero no la primera vez, ¿no?
#
# ¡No, hombre, no! Creo que estas equivocado, ..., en el diccionario
# Larousse de Inglés-Español pone:
#
# "nor conj. Ni: he is neither big nor small, no es ni grande ni
# pequeño; neither you nor I, ni tú ni yo || ..."
#
# O sea, que es " ... ni ... ni ..." cll
#
#: compiler.lsp:11935
msgid "Not a lambda expression nor a function: ~S"
msgstr "Ni es una expresión lambda ni es una función: ~S"

#: compiler.lsp:12166
msgid "~&Listing of compilation of file ~A~%on ~@? by ~A, version ~A"
msgstr "~&Listado de la compilación del fichero ~A~%el ~@? por ~A, versión ~A"

#: compiler.lsp:12209
msgid "~%Compiling file ~A ..."
msgstr "~%Compilando el fichero ~A ..."

#: compiler.lsp:12259
msgid "~&~%Compilation of file ~A is finished."
msgstr "~&~%La compilación del fichero ~A ha finalizado."

#
# Duda: ¡atención a la utilización de la directiva ~P!
#
# La siguiente traducción funcionará si, para el caso del español (como
# para el alemán), se pasa el parámetro (eql *error-count* 1), en
# segundo lugar.
#
# Ya no hace falta. Tal y como está hecho no es necesario pasar ningún
# parámetro extra. Así funciona correctamente.
#
# Aquí dudo porque atención no es tan "pluralizable" como aviso. sv
#
# Claro, de hecho, a mí también me pasa lo mismo. He preferido cambiar
# la traducción de "aviso" por "advertencia", en este mensaje y en aquél
# en el que se sacan los mensajes del compilador. ¿No os suena muchísimo
# mejor esta segunda alternativa? - cll
#
#: compiler.lsp:12262
msgid "~%~D error~:P, ~D warning~:P"
msgstr "~%~D error~:*~[es~;~:;es~], ~D advertencia~:P"

#: compiler.lsp:12267
msgid "~%There were errors in the following functions:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Ha habido errores en las siguientes funciones:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12274
msgid "~%The following functions were used but not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12280
msgid "~%The following special variables were not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales no han sido definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12284
msgid "~%The following special variables were defined too late:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales fueron definidas demasiado tarde:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12288
msgid "~%The following functions were used but are deprecated:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no aprobadas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12349
msgid "~%~%Disassembly of function ~S"
msgstr "Desensamblado de la función ~S"

#: compiler.lsp:12360
msgid "~%~S required arguments"
msgstr "~%~S argumentos obligatorios"

#: compiler.lsp:12363
msgid "~%~S optional arguments"
msgstr "~%~S argumentos opcionales"

#: compiler.lsp:12366
msgid "~%~:[No rest parameter~;Rest parameter~]"
msgstr "~%~:[Sin parámetro resto~;Parámetro resto~]"

#: compiler.lsp:12371
msgid "~%~S keyword parameter~:P: ~{~S~^, ~}."
msgstr "~%~S parámetro~:P clave: ~{~S~^, ~}."

#: compiler.lsp:12375
msgid "~%Other keywords are allowed."
msgstr "~%Se permiten otros parámetros clave."

#: compiler.lsp:12377
msgid "~%No keyword parameters"
msgstr "~%Sin parámetros clave"

#: compiler.lsp:12394
msgid "Disassembly of function "
msgstr "Desensamblado de la función "

#: compiler.lsp:12412
msgid " required arguments"
msgstr " argumentos obligatorios"

#: compiler.lsp:12417
msgid " optional arguments"
msgstr " argumentos opcionales"

#: compiler.lsp:12422
msgid "Rest parameter"
msgstr "Parámetro resto"

#: compiler.lsp:12425
msgid "No rest parameter"
msgstr "Sin parámetro de resto"

#
# ¡¡Atención a la utilización de la directiva ~P!!
#
# Bueno, en este caso es perfecta :) No hay ningún problema de ningún
# tipo
#
#: compiler.lsp:12432
msgid " keyword parameter~P: "
msgstr "parámetro~P clave: "

#: compiler.lsp:12442
msgid "Other keywords are allowed."
msgstr "Se permiten otras palabras clave."

#: compiler.lsp:12447
msgid "No keyword parameters"
msgstr "Sin parámetros clave"

#: compiler.lsp:12528
msgid "Cannot disassemble ~S"
msgstr "No se puede desensamblar ~S"

#: defs2.lsp:63
msgid "~S: ~S is not a function"
msgstr "~S: ~S no es una función"

#: defs2.lsp:77
msgid "~S: package name ~S should be a string or a symbol"
msgstr "~S: el nombre del paquete ~S debe ser una cadena de caracteres o un símbolo"

#: defs2.lsp:84
msgid "~S ~A: symbol name ~S should be a string or a symbol"
msgstr "~S ~A: el nombre del símbolo ~S debe ser una cadena de caracteres o un símbolo"

#: defs2.lsp:104
msgid "~S ~A: the symbol ~A must not be specified more than once"
msgstr "~S ~A: el símbolo ~A no debe especificarse más de una vez"

#: defs2.lsp:116 defs2.lsp:124
msgid "~S ~A: the ~S option must not be given more than once"
msgstr "~S ~A: no se debe poner la opción ~S más de una vez"

#: defs2.lsp:182
msgid "~S ~A: unknown option ~S"
msgstr "~S ~A: la opción ~S es desconocida"

#: defs2.lsp:186
msgid "~S ~A: invalid syntax in ~S option: ~S"
msgstr "~S ~A: la sintaxis de la opción ~S es inválida: ~S"

#: defs2.lsp:190
msgid "~S ~A: not a ~S option: ~S"
msgstr "~S ~A: no se trata de una opción ~S: ~S"

#: defs2.lsp:246
msgid "This symbol will be created."
msgstr "Este símbolo será creado."

#: defs2.lsp:247
msgid "~S ~A: There is no symbol ~A::~A ."
msgstr "~S ~A: El símbolo ~A::~A no existe."

#: defs2.lsp:321
msgid "The object to be destructured should be a list with ~:[at least ~*~S~;~:[from ~S to ~S~;~S~]~] elements, not ~4@*~S."
msgstr "Los objetos a desmontar deben ser una lista ~:[con al menos ~*~S~;de ~:[~S a ~S~;~S~]~] elementos, y no ~4@*~S."

#: defs2.lsp:390
msgid "~S: macro name should be a symbol, not ~S"
msgstr "~S: el nombre de una macro debe ser un símbolo, no ~S"

#: defs2.lsp:425
msgid "~S: input stream ~S ends within read macro beginning to ~S"
msgstr "~S: el flujo de entrada ~S ha terminado durante el procesamiento de una macro de lectura que empezaba en ~S"

#: defs2.lsp:431
#, fuzzy
msgid "~S from ~S: character read should be a character: ~S"
msgstr "~S en ~S: el carácter leído debe ser un STRING-CHAR: ~S"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: defs2.lsp:452
msgid "~S from ~S: After ~S is ~S an undefined dispatch macro character"
msgstr "~S en ~S: Después de ~S está ~S, un macro carácter sencundario indefinido"

#: defs2.lsp:518 defs2.lsp:533
msgid "~S: ~S of ~S is ambiguous. Please use ~S or ~S."
msgstr ""

#: loop.lsp:48
msgid "~S: syntax error after ~A in ~S"
msgstr "~S: error de sintaxis después de ~A en ~S"

#: loop.lsp:259
#, fuzzy
msgid "~S: missing variable."
msgstr "~S: variable ausente"

#: loop.lsp:270
msgid "~S: After ~S, ~S is interpreted as a type specification"
msgstr "~S: Después de ~S, ~S es interpretado como una especificación de tipo"

#: loop.lsp:574
msgid "~S: ~A clauses should occur before the loop's main body"
msgstr "~S: las claúsulas ~A deben aparecer antes del cuerpo principal del bucle"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lsp:736
msgid "~S: After ~S a plural loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un plural, y no ~A"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lsp:743
msgid "~S: After ~S a singular loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un singular, y no ~A"

#: loop.lsp:912
msgid "~S: questionable iteration direction after ~A"
msgstr "~S: dirección incierta de la iteración después de ~A"

#: loop.lsp:924
msgid "~S: specifying ~A requires FROM or DOWNFROM"
msgstr "~S: especificar ~A requiere FROM o DOWNFROM"

#: loop.lsp:1000
msgid "~S: illegal syntax near ~S in ~S"
msgstr "~S: sintaxis inválida cerca de ~S en ~S"

#: loop.lsp:1007
msgid "~S: ambiguous result of loop ~S"
msgstr "~S: el resultado del bucle ~S es ambiguo"

#: loop.lsp:1168
msgid "~S is possible only from within ~S"
msgstr "~S sólo es posible desde ~S"

#: loop.lsp:1172
msgid "Use of ~S in FINALLY clauses is deprecated because it can lead to infinite loops."
msgstr "La utilización de ~S en las cláusulas FINALLY está desaconsejada puesto que puede provocar bucles infinitos"

#: loop.lsp:1176
msgid "~S is not possible here"
msgstr "~S es imposible aquí"

#: clos.lsp:167 clos.lsp:188
msgid "~S: argument ~S is not a symbol"
msgstr "~S: el argumento ~S no es un símbolo"

#: clos.lsp:174
msgid "~S: ~S does not name a class"
msgstr "~S: ~S no nombra una clase"

#: clos.lsp:194
msgid "~S: ~S is not a class"
msgstr "~S: ~S no es una clase"

#: clos.lsp:201
msgid "~S: cannot redefine built-in class ~S"
msgstr "~S: no se puede redefinir la clase predefinida ~S"

#: clos.lsp:206
msgid "~S: Redefining the COMMON LISP class ~S"
msgstr "~S: Redefiniendo la clase de COMMON LISP ~S"

#: clos.lsp:361
msgid "instance ~S of class ~S has no slots (wrong metaclass)"
msgstr "la instancia ~S de la clase ~S no tiene ranuras (metaclase errónea)"

#: clos.lsp:382 clos.lsp:427
msgid "~S: not a list of slots: ~S"
msgstr "~S: no es una lista de ranuras: ~S"

#: clos.lsp:390
msgid "~S: invalid slot and variable specification ~S"
msgstr "~S: especificación inválida de ranura y variable: ~S"

#: clos.lsp:396 clos.lsp:438
msgid "~S: variable ~S should be a symbol"
msgstr "~S: la variable ~S debe ser un símbolo"

#: clos.lsp:402
msgid "~S: slot name ~S should be a symbol"
msgstr "~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lsp:433
msgid "~S: invalid slot and accessor specification ~S"
msgstr "~S: especificación inválida de ranura y función de acceso: ~S"

#: clos.lsp:443
msgid "~S: accessor name ~S should be a symbol"
msgstr "~S: el nombre de la función de acceso ~S debe ser un símbolo"

#: clos.lsp:534
msgid "~S: class name ~S should be a symbol"
msgstr "~S: el nombre de la clase ~S debe ser un símbolo"

#: clos.lsp:541
msgid "~S ~S: expecting list of superclasses instead of ~S"
msgstr "~S ~S: se esperaba una lista de superclases en vez de ~S"

#: clos.lsp:547
msgid "~S ~S: superclass name ~S should be a symbol"
msgstr "~S ~S: el nombre de la superclase ~S debe ser un símbolo"

#: clos.lsp:559
msgid "~S ~S: expecting list of slot specifications instead of ~S"
msgstr "~S ~S: se esperaba una lista de especificación de ranuras en vez de ~S"

#: clos.lsp:569
msgid "~S ~S: slot name ~S should be a symbol"
msgstr "~S ~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lsp:574
msgid "~S ~S: There may be only one direct slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura directa con el nombre ~S."

#: clos.lsp:589
msgid "~S ~S: slot options for slot ~S don't come in pairs"
msgstr "~S ~S: las opciones de ranura para ~S no aparecen por pares"

#: clos.lsp:600
msgid "~S ~S, slot option for slot ~S: ~S is not a function name"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una función"

#: clos.lsp:610 clos.lsp:632
msgid "~S ~S, slot option for slot ~S: ~S is not a symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo"

#: clos.lsp:620 clos.lsp:640 clos.lsp:649 clos.lsp:657
msgid "~S ~S, slot option ~S for slot ~S may only be given once"
msgstr "~S ~S, la opción de ranura ~S para ~S solo debe indicarse una vez"

#: clos.lsp:626
msgid "~S ~S, slot option for slot ~S must have the value ~S or ~S, not ~S"
msgstr "~S ~S, la opción de ranura para ~S debe tener el valor ~S o ~S, y no ~S"

#: clos.lsp:662
msgid "~S ~S, slot option for slot ~S: ~S is not a string"
msgstr "~S ~S, opción de ranura para ~S: ~S no es una cadena de caracteres"

#: clos.lsp:669
msgid "~S ~S, slot option for slot ~S: ~S is not a valid slot option"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una opción de ranura válida"

#: clos.lsp:720
msgid "~S ~S, option ~S may only be given once"
msgstr "~S ~S, la opción ~S sólo se puede indicar una vez"

#: clos.lsp:729 clos.lsp:756
msgid "~S ~S, option ~S: ~S is not a symbol"
msgstr "~S ~S, opción ~S: ~S no es un símbolo"

#: clos.lsp:740
msgid "~S ~S: option ~S should be written ~S"
msgstr "~S ~S: la opción ~S debe escribirse como ~S"

#: clos.lsp:745
msgid "~S ~S, option ~S: arguments don't come in pairs"
msgstr "~S ~S, opción ~S: los argumentos no aparecen en pares"

#: clos.lsp:761
msgid "~S ~S, option ~S: ~S may only be given once"
msgstr "~S ~S, opción ~S: ~S sólo se puede poner una vez"

#: clos.lsp:781
msgid "~S ~S, option ~S: ~S is not a string"
msgstr "~S ~S, opción ~S: ~S no es una cadena de caracteres"

#: clos.lsp:790
msgid "~S ~S: invalid option ~S"
msgstr "~S ~S: la opción ~S es inválida"

#: clos.lsp:897
msgid "~S: Class ~S is being redefined, instances are obsolete"
msgstr "~S: La clase ~S ha sido redefinida, las instancias son obsoletas"

#: clos.lsp:984
msgid "~S ~S: superclass ~S should belong to class STANDARD-CLASS"
msgstr "~S ~S: la superclase ~S debe pertenecer a la clase STANDARD-CLASS"

#: clos.lsp:1154
msgid "~S ~S: inconsistent precedence graph, cycle ~S"
msgstr "~S ~S: grafo de precedencia inconsistente, ciclo ~S"

#: clos.lsp:1193
msgid "(class-precedence-list ~S) and (class-precedence-list ~S) are inconsistent"
msgstr "(class-precedence-list ~S) y (class-precedence-list ~S) son inconsistentes"

#: clos.lsp:1350
msgid "~S: superclass ~S should belong to class BUILT-IN-CLASS"
msgstr "~S: la superclase ~S debe pertenecer a la clase BUILT-IN-CLASS"

#: clos.lsp:1392
msgid "~S: metaclass STRUCTURE-CLASS forbids more than one direct superclass"
msgstr "~S: la metaclase STRUCTURE-CLASS prohibe más de una superclase directa"

#: clos.lsp:1398
msgid "~S: superclass ~S should belong to class STRUCTURE-CLASS"
msgstr "~S: la superclase ~S debe pertenecer a la clase STRUCTURE-CLASS"

#: clos.lsp:1438
msgid "~S: metaclass STRUCTURE-CLASS does not support shared slots"
msgstr "~S: la metaclase STRUCTURE-CLASS no mantiene ranuras compartidas"

#: clos.lsp:1711
msgid "~S ~S: missing lambda list"
msgstr "~S ~S: falta la lista lambda"

#: clos.lsp:1723
msgid "STANDARD method combination doesn't allow the method qualifiers to be ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos.lsp:1876 clos.lsp:1881
msgid "~S ~S: ~S is invalid within ~S methods"
msgstr "~S ~S: ~S es inválido dentro de los métodos ~S"

#: clos.lsp:2119
msgid "Too few arguments to ~S: ~S"
msgstr "Muy pocos argumentos para ~S: ~S"

#: clos.lsp:2248
msgid "The generic function ~S is being modified, but has already been called."
msgstr "La función genérica ~S está siendo modificada, pero ya ha sido invocada."

#: clos.lsp:2807
msgid "~S in ~S: the new arguments ~S have a different effective method than the old arguments ~S"
msgstr "~S en ~S: los argumentos nuevos ~S tienen un método en vigor diferente que los argumentos antiguos ~S"

#: clos.lsp:2832
msgid "~S has ~S, but ~S has ~S required parameters"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros obligatorios"

#: clos.lsp:2837
msgid "~S has ~S, but ~S has ~S optional parameters"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros opcionales"

#: clos.lsp:2842 clos.lsp:2847
msgid "~S has &REST or &KEY, but ~S hasn't."
msgstr "~S tiene parámetros &REST o &KEY, pero ~S no."

#: clos.lsp:2859
msgid "~S doesn't accept the keywords ~S of ~S"
msgstr "~S no acepta las palabras clave ~S de ~S"

#: clos.lsp:2889
msgid "Replacing method ~S in ~S"
msgstr "Reemplazando el método ~S de ~S"

#: clos.lsp:2907
msgid "Removing method ~S in ~S"
msgstr "Borrando el método ~S de ~S"

#: clos.lsp:2935
msgid "~S has no method with qualifiers ~:S and specializers ~S"
msgstr "~S no tiene ningún método con cualificadores ~:S y especializadores ~S"

#: clos.lsp:2964 clos.lsp:3271
msgid "~S doesn't name a generic function"
msgstr "~S no es una función genérica"

#: clos.lsp:3026
msgid "~S ~S: Only ~S declarations are permitted: ~S"
msgstr "~S ~S: Sólo la declaraciones ~S están permitidas: ~S"

#: clos.lsp:3035
msgid "~S ~S: ~S may only be specified once."
msgstr "~S ~S: ~S sólo puede especificarse una vez."

#: clos.lsp:3043
msgid "~S ~S: A string must be specified after ~S : ~S"
msgstr "~S ~S: Debe especificarse una cadena de caracteres después de ~S: ~S"

#: clos.lsp:3048
msgid "~S ~S: Only one ~S string is allowed"
msgstr "~S ~S: Sólo se permite una cadena de caracteres ~S"

#: clos.lsp:3056
msgid "~S ~S: The only valid method combination is ~S : ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos.lsp:3064
msgid "~S ~S: The only valid generic function class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de función genérica es ~S : ~S"

#: clos.lsp:3072
msgid "~S ~S: The only valid method class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de métodos es ~S : ~S"

#: clos.lsp:3091
msgid "~S ~S: ~S is not one of the required parameters: ~S"
msgstr "~S ~S: ~S no es uno de los parámetros obligatorios: ~S"

#: clos.lsp:3103
msgid "~S ~S: some variable occurs twice in ~S"
msgstr "~S ~S: alguna variable ha aparecido dos veces en ~S"

#: clos.lsp:3108
msgid "~S ~S: ~S is missing some required parameter"
msgstr "~S ~S: ~S necesita algunos parámetros obligatorios"

#: clos.lsp:3137
msgid "~S ~S: No initializations are allowed in a generic function lambda-list: ~S"
msgstr "~S ~S: No están permitidas las inicializaciones en la lista lambda de una función genérica: ~S"

#: clos.lsp:3143
msgid "~S ~S: variable name ~S should be a symbol"
msgstr "~S ~S: el nombre de la variable ~S debe ser un símbolo"

#: clos.lsp:3148
msgid "~S ~S: duplicate variable name ~S"
msgstr "~S ~S: el nombre de la variable ~S está duplicado"

#: clos.lsp:3199
msgid "~S ~S: invalid lambda list portion: ~S"
msgstr "~S ~S: parte de la lista lambda es inválida: ~S"

#: clos.lsp:3252
msgid "Removing all methods of ~S"
msgstr "Borrando todos los métodos de ~S"

#: clos.lsp:3260
msgid "Modifying the parameter profile of ~S"
msgstr "Modificando el perfil de parámetro de ~S"

#: clos.lsp:3316
msgid "~S: ~S is not a generic function specification"
msgstr "~S: ~S no es una especificación de función genérica"

#: clos.lsp:3379
msgid "~S: The name of a class must be a symbol, not ~S"
msgstr "~S: El nombre de una clase debe ser un símbolo, no ~S"

#: clos.lsp:3384
msgid "~S: The name of the built-in class ~S cannot be modified"
msgstr "~S: No es posible modificar el nombre de la clase predefinida ~S"

#: clos.lsp:3427 clos.lsp:3431
msgid "~S: When calling ~S with arguments ~S, no method is applicable."
msgstr "~S: No se puede aplicar ningún método al invocar ~S con los argumentos ~S."

#: clos.lsp:3449 clos.lsp:3453
msgid "~S: When calling ~S with arguments ~S, no primary method is applicable."
msgstr "~S: No se puede aplicar ningún método primario al invocar ~S con los argumentos ~S"

#: clos.lsp:3463
msgid "~S: When calling ~S with arguments ~S, there is no next method after ~S, and ~S was called."
msgstr "~S: Mientras se invoca ~S con los argumentos ~S, no hay ningún método después de ~S, y ~S fue llamado."

#: clos.lsp:3514
msgid "~S: The class ~S has no slot named ~S"
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: clos.lsp:3524
msgid "~S: The slot ~S of ~S has no value"
msgstr "~S: La ranura ~S de ~S no tiene ningún valor"

#: clos.lsp:4032
msgid "~S method for ~S returned ~S"
msgstr ""

#: conditio.lsp:80
msgid "~S: the name of a condition must be a symbol, not ~S"
msgstr "~S: el nombre de una condición debe ser un símbolo, y no ~S"

# En este mensaje, el término `parent-type' se refiere al segundo
# argumento de la macro `define-condition' que, según el estándar, se
# utiliza como lista de super-tipos del que se obtiene una nueva
# condición.
#
# Por ese motivo, he añadido la expresión "super-tipos" - cll
#
#: conditio.lsp:85
msgid "~S: the parent-type list must be a list of symbols, not ~S"
msgstr "~S: la lista de \"super-tipos\" debe ser una lista de símbolos, y no ~S"

#: conditio.lsp:90
msgid "~S: the slot description list must be a list, not ~S"
msgstr "~S: la lista de descripción de la ranura debe ser una lista, y no ~S"

#: conditio.lsp:145
msgid "~S: type ~S is not a subtype of ~S"
msgstr "~S: el tipo ~S no es un subtipo de ~S"

#: conditio.lsp:161
msgid "~S ~S: superfluous arguments ~S"
msgstr "~S ~S: los argumentos ~S son superfluos"

#: conditio.lsp:178
msgid "~S: the condition argument must be a string, a symbol or a condition, not ~S"
msgstr "~S: el argumento de la condición debe ser una cadena de caracteres, un símbolo o una condición, y no ~S"

#: conditio.lsp:571
msgid "~S: illegal syntax of clause ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: conditio.lsp:577
msgid "~S: misplaced ~S clause: ~S"
msgstr "~S: la clausula ~S está mal colocada: ~S"

#: conditio.lsp:583
msgid "~S: too many variables ~S in clause ~S"
msgstr "~S: demasiadas variables ~S en la clausula ~S"

# Duda: ¿y cómo traduzco `restart'?
#
# He decidido dejar `restart' sin traducir, ... :(
#
#: conditio.lsp:796
msgid "~S: ~S is not a valid restart name here. Use ~S instead."
msgstr "~S: ~S no es válido como nombre de `restart' aquí. En su lugar, use ~S."

#: conditio.lsp:817
msgid "~S: invalid restart name ~S"
msgstr "~S: ~S es un nombre inválido de `restart'"

#: conditio.lsp:824
msgid "~S: No restart named ~S is visible."
msgstr "~S: No hay ningún `restart' visible llamado ~S"

#: conditio.lsp:882 conditio.lsp:941
msgid "~S: not a list: ~S"
msgstr "~S: no es una lista: ~S"

#: conditio.lsp:891 conditio.lsp:950
msgid "~S: invalid restart specification ~S"
msgstr "~S: ~S no es una especificación válida de `restart'"

#: conditio.lsp:902 conditio.lsp:988
msgid "~S: unnamed restarts require ~S to be specified: ~S"
msgstr "~S: es necesario especificar ~S en los `restart' sin nombre: ~S"

#: conditio.lsp:973
msgid "~S: missing lambda list in restart specification ~S"
msgstr "~S: falta la lista lambda en la especificación del `restart' ~S"

#: conditio.lsp:996
msgid "~S: restart cannot be invoked interactively because it is missing a ~S option: ~S"
msgstr "~S: el `restart' no puede invocarse interactivamente porque falta la opción ~S: ~S"

#: conditio.lsp:1195
msgid "~%New ~S [value ~D of ~D]: "
msgstr ""

#: conditio.lsp:1414 conditio.lsp:1530
msgid "Return from ~S loop"
msgstr "Retorno del bucle ~S"

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: conditio.lsp:1498 conditio.lsp:1521
msgid "WARNING:"
msgstr "ATENCIÓN:"

#
# En este caso he tenido que traducir `warning' por `advertencia', en
# vez de `atención'. ¿No querreis que diga algo así como "Esto es más
# serio que un toque de atención"? Así parecería que el compilador le va
# a meter una paliza al pobre programador, ... :) - cll
#
#: conditio.lsp:1510
msgid "~S: This is more serious than a warning: ~A"
msgstr "~S: Esto es más serio que una advertencia: ~A"

#: xcharin.lsp:36
#, fuzzy
msgid "~: argument ~S is not a character"
msgstr "~: el argumento ~ no es un carácter"

#: xcharin.lsp:57
#, fuzzy
msgid "~S: the font argument should be an integer, not ~S"
msgstr "~: el argumento de la fuente debe ser un número y no ~"

#: xcharin.lsp:66
#, fuzzy
msgid "~S: the bits argument should be an integer, not ~S"
msgstr "~: el argumento de los bits debe ser un entero y no ~"

# Ya, ya se que eso de "los nombres de bit" puede sonar muy raro, pero
# es que realmente es así en Common Lisp.  Consúltese el Cltl2, 13.5
# Character Control-Bit Functions, página 385
#
#: xcharin.lsp:88
#, fuzzy
msgid "~S: the only bit names are ~S, ~S, ~S, ~S, not ~S"
msgstr "~: los únicos nombres de bit son :CONTROL, :META, :SUPER y :HYPER, y no ~"

#: screen.lsp:227
msgid "Got bad response from ~S: ~S"
msgstr "Se obtuvo una respuesta incorrecta de ~S: ~S"

#: amigasock.lsp:30
#, fuzzy
msgid "~S: ~S is not a SOCKET-SERVER"
msgstr "~: ~ no es un SOCKET-SERVER"

#: runprog.lsp:162
msgid "~S: File ~S already exists"
msgstr "~S: El fichero ~S ya existe"

# Con un poco de suerte, aquí se podría poner directamente " (s/n) ".
# En fileutils ya se puede. sv
#
# Bueno, pues sí, ..., sí podría hacerse. Ahora bien, para eso es
# necesario modificar el código fuente del clisp (lo cual no es nada
# complicado gracias a la localizacion de codigo fuente del modo .PO
# desde Emacs :). De momento, lo dejo tal cual (aunque queda pachín,
# pachán, ... :( ) y luego lo modificaré, ..., ¿vale?. cll
#
#: query.lsp:12
msgid " (y/n) "
msgstr " (si(y)/no(n)) "

#: query.lsp:23
msgid "Please answer with y or n : "
msgstr "Por favor, responda con y(si) o n(no) : "

#: query.lsp:33
msgid " (yes/no) "
msgstr " (si(yes)/no(no)) "

#: query.lsp:43
msgid "Please answer with yes or no : "
msgstr "Por favor, responda con yes(si) o no(no) : "

# paquete (?) sv
#
# Bueno, podría parecer muy conveniente. Sin embargo, verás, ..., lo de
# *package* está puesto a nivel de programa. Es decir, Bruno Haible y
# compañía lo tienen puesto así desde su propio programa. Por lo tanto,
# si lo cambio en un par de mensajes seguirá apareciendo en muchos otros
# sitios. Prefiero ser consistente y dejarlo así. cll
#
# Además, no está traducido ni en alemán ni en inglés. cll
#
#: reploop.lsp:53
msgid "[*package* invalid]"
msgstr "[*package* inválido]"

#: reploop.lsp:162
#, fuzzy
msgid "Values: "
msgstr "valores: "

# Me suele gustar más "utilice" (porque me parece más "fino"). sv
#
# De acuerdo, ..., cambiado `use' por `utilice'. A mí también me gusta más. cll
#
# Y además, (recomendación tuya, Santiago), `command' por `orden', en
# vez de `comando' - cll
#
#: reploop.lsp:170
#, fuzzy
msgid ""
"\n"
"Help = this list\n"
"Use the usual editing capabilities.\n"
"(quit) or (exit) leaves CLISP."
msgstr ""
"\n"
"Help = esta lista\n"
"Utilice las órdenes de edición habituales"

#
# Cambiado `comando' por `orden', que parece ser muchísimo mejor - cll
#
#: reploop.lsp:179
msgid ""
"\n"
"Help   = this command list\n"
"Abort  = abort to the next recent input loop\n"
"Unwind = abort to the next recent input loop\n"
"Mode-1 = inspect all the stack elements\n"
"Mode-2 = inspect all the frames\n"
"Mode-3 = inspect only lexical frames\n"
"Mode-4 = inspect only EVAL and APPLY frames (default)\n"
"Mode-5 = inspect only APPLY frames\n"
"Where  = inspect this frame\n"
"Up     = go up one frame, inspect it\n"
"Top    = go to top frame, inspect it\n"
"Down   = go down one frame, inspect it\n"
"Bottom = go to bottom (most recent) frame, inspect it\n"
"Backtrace-1 = list all stack elements\n"
"Backtrace-2 = list all frames\n"
"Backtrace-3 = list all lexical frames\n"
"Backtrace-4 = list all EVAL and APPLY frames\n"
"Backtrace-5 = list all APPLY frames\n"
"Backtrace   = list stack in current mode\n"
"Break+ = set breakpoint in EVAL frame\n"
"Break- = disable breakpoint in EVAL frame\n"
"Redo   = re-evaluate form in EVAL frame\n"
"Return = leave EVAL frame, prescribing the return values"
msgstr ""
"\n"
"Help   = esta lista de órdenes\n"
"Abort  = volver al bucle de entrada más reciente\n"
"Unwind = volver al bucle de entrada más reciente\n"
"Mode-1 = inspeccionar todos los elementos de la pila\n"
"Mode-2 = inspeccionar todos los marcos\n"
"Mode-3 = inspeccionar únicamente los marcos léxicos\n"
"Mode-4 = inspeccionar sólo los marcos de los tipos EVAL y APPLY (por\n"
"         defecto)\n"
"Mode-5 = inspeccionar sólo los marcos de tipo APPLY\n"
"Where  = inspeccionar el marco actual\n"
"Up     = ascender un marco, e inspeccionarlo\n"
"Top    = ir al primer marco, e inspeccionarlo\n"
"Down   = descender un marco e inspeccionarlo\n"
"Bottom = ir al último marco (el más reciente) e inspeccionarlo\n"
"Backtrace-1 = mostrar todos los elementos de la pila\n"
"Backtrace-2 = mostrar todos los marcos\n"
"Backtrace-3 = mostrar todos los marcos léxicos\n"
"Backtrace-4 = mostrar todos los marcos de los tipos EVAL y APPLY\n"
"Backtrace-5 = mostrar todos los marcos del tipo APPLY\n"
"Backtrace   = mostrar la pila en el modo actual\n"
"Break+ = establecer un punto de ruptura en un marco de tipo EVAL\n"
"Break- = desactivar un punto de ruptura en un marco de tipo EVAL\n"
"Redo   = re-evaluar la forma en un marco EVAL\n"
"Return = abandonar un marco EVAL con los valores de vuelta indicados"

#: reploop.lsp:234
msgid ""
"\n"
"Continue = continue evaluation"
msgstr ""
"\n"
"Continue = continuar la evaluación"

#: reploop.lsp:301
msgid "You can continue (by typing 'continue')."
msgstr "Puede continuar (tecleando `continue')."

# Duda: Los `restarts' son un mecanismo muy, muy eficiente en Common
# Lisp para la recuperación de errores.
#
# Es posible programar una sección de código de modo que cuando sucede
# algún error se invoquen determinados `restarts' (elegidos y, más aún,
# programados por el propio programador). CLisp, entonces, presenta un
# menú con todos los `restarts' disponibles; el usuario debe elegir
# entre los posibles `restarts' para continuar la evaluación o
# cualquiera de las acciones de depuración que proporciona el entorno.
#
# Pero ¿cómo traducir `restart'? ¿re-entrada, ...? Hmmm, ..., no me
# suena nada bien. Por ese motivo, he preferido sustituir la palabra por
# una expresión: `También es posible continuar en los siguientes
# puntos:", y cuando no sea posible aplicar una expresión de este tipo,
# dejaré `restart' sin traducir hasta que se me ocurra algo más
# original.
#
# ¡¡Necesito ayuda!! :)
#
#: reploop.lsp:320
msgid "The following restarts are available too:"
msgstr "También es posible continuar en los siguientes puntos:"

#: reploop.lsp:321
msgid "The following restarts are available:"
msgstr "Es posible continuar en los siguientes puntos:"

# ¿form no era formulario? (o a lo mejor es algo de lisp que no sé). sv
#
# En Visual Basic (y los lenguajes orientados a eventos), form es formulario.
# Sin embargo, en Lisp form es forma. Se refiere a las sentencias Lisp. cll
#
#: reploop.lsp:413
msgid ""
"\n"
"Step     = step into form: evaluate this form in single step mode\n"
"Next     = step over form: evaluate this form at once\n"
"Over     = step over this level: evaluate at once up to the next return\n"
"Continue = switch off single step mode, continue evaluation\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           same as above, specify a condition when to stop"
msgstr ""
"\n"
"Step     = entrar en una forma: evaluar esta forma en el modo paso a paso\n"
"Next     = saltarse una forma: evaluar esta forma en un solo paso\n"
"Over     = saltarse este nivel: evaluar hasta el siguiente retorno\n"
"Continue = desactivar el modo paso a paso y continuar la evaluación\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           lo mismo que antes, especifique una condición de parada"

# Duda: Francamente, no sé porqué motivo esto no fué traducido al
# FRANCÉS o al INGLÉS (compruébese en el código, ...) porque en
# realidad, queda pero que muy bien poner `paso' cuando se hace la
# depuración paso a paso, ...
#
# Este mensaje, de hecho, aparece cuando se hace algo del tipo:
#
# > (step (+ 2 3))
# step 1 --> (+ 2 3)
# Step 1>
#
# ..., donde, traduciendo el primer `step' al español, queda algo muy
# propio:
#
# > (step (+ 2 3))
# paso 1 --> (+ 2 3)
# Step 1>
#
# A mi me gusta así, ..., ¡¡A SACO!!
#
#: reploop.lsp:434 reploop.lsp:479
msgid "step "
msgstr "paso "

#: reploop.lsp:438
msgid "no values"
msgstr "sin valores"

#: reploop.lsp:439
msgid "value: "
msgstr "valor: "

#: reploop.lsp:443
msgid " values: "
msgstr " valores: "

#: reploop.lsp:507
msgid "condition when to stop: "
msgstr "condición de parada: "

# Nota: La utilización de dribbling viene de la función dribble de Lisp.
#       Dicha función graba una sesión Lisp en el archivo que se indique en la
#       llamada a la función.
#
# La traducción no juega, de esa manera, con las palabras.
#
#: dribble.lsp:19
msgid "Already dribbling to ~S"
msgstr "Ya se está grabando la sesión en ~S"

#: dribble.lsp:105
msgid "Currently not dribbling."
msgstr "En este momento, no se está grabando la sesión."

#: describe.lsp:44
msgid "constant"
msgstr "constante"

#: describe.lsp:46
msgid "symbol-macro"
msgstr ""

#: describe.lsp:47
msgid "variable"
msgstr "variable"

#: describe.lsp:54
msgid "type"
msgstr "tipo"

#: describe.lsp:60
msgid "class"
msgstr "clase"

# Duda: Lo que he dicho unos pocos mensajes más arriba --> Slot por
# slot, ...
#
# Pues no, ... A partir de la versión 1.4, `slot' es "ranura", tal y
# como se propone en la lista de spanglish.
#
#: describe.lsp:134
#, fuzzy
msgid "~%Slots:"
msgstr "~%Ranuras:"

#: describe.lsp:141
msgid "unbound"
msgstr "sin asociar"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: describe.lsp:144
#, fuzzy
msgid "~%No slots."
msgstr "~%Sin ranuras."

#: describe.lsp:151
msgid "a foreign pointer"
msgstr "una puntero externo"

#: describe.lsp:154
msgid "a foreign address"
msgstr "una dirección externa"

#: describe.lsp:157
msgid "a foreign variable of foreign type ~S."
msgstr "una variable externa del tipo extranjero ~S."

#: describe.lsp:161
msgid "a foreign function taking foreign types ~:S and returning foreign type ~S."
msgstr ""

#: describe.lsp:165
msgid "a byte specifier, denoting the ~S bits starting at bit position ~S of an integer."
msgstr "un especificador de byte que denota los ~S bits que comienzan en el bit ~S de un entero"

#: describe.lsp:168
msgid "a special form handler."
msgstr "un manipulador de forma especial."

#: describe.lsp:170
msgid "a load-time evaluation promise."
msgstr "una promesa de evaluación en tiempo de carga."

#: describe.lsp:172
#, fuzzy
msgid "a symbol macro handler."
msgstr "un manipulador de forma especial."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lsp:174
#, fuzzy
msgid "an encoding."
msgstr "un cons."

#: describe.lsp:179
msgid "a GC-invisible pointer to ~S."
msgstr ""

#: describe.lsp:182
msgid "a GC-invisible pointer to a now defunct object."
msgstr ""

#: describe.lsp:184
msgid "a label used for resolving #~D# references during READ."
msgstr "una etiqueta para resolver #~D# referencias en READ."

#: describe.lsp:188
msgid "a pointer into the stack. It points to:"
msgstr "Un puntero a la pila. Apunta a:"

#: describe.lsp:191
msgid "a special-purpose object."
msgstr "un objeto de propósito especial."

#: describe.lsp:193
msgid "a machine address."
msgstr "una dirección de máquina."

#: describe.lsp:195
msgid "an instance of the CLOS class ~S."
msgstr "una instancia de la clase CLOS ~S."

#: describe.lsp:199
msgid "a structure of type ~S."
msgstr "una estructura del tipo ~S."

#: describe.lsp:203
msgid "~%As such, it is also a structure of type ~{~S~^, ~}."
msgstr "Como tal, también es una estructura del tipo ~{~S~^, ~}."

#: describe.lsp:217
msgid "a list of length ~S."
msgstr "una lista de longitud ~S."

#: describe.lsp:220
msgid "a dotted list of length ~S."
msgstr "una lista punteada de longitud ~S."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: describe.lsp:222
msgid "a cons."
msgstr "un cons."

#: describe.lsp:225
msgid "a cyclic list."
msgstr "una lista cíclica."

#: describe.lsp:227
msgid "the empty list, "
msgstr "la lista vacía, "

#: describe.lsp:230
#, fuzzy
msgid "the symbol ~S, "
msgstr "el símbolo ~S"

#: describe.lsp:234
msgid "lies in ~S"
msgstr "está en el ~S"

# Duda: He traducido al estilo del mensaje en francés: "n'appartient à
# aucun paquetage"
#
#: describe.lsp:237
msgid "is uninterned"
msgstr "no aparece en ningún paquete"

# Nota: Caso brillante de la generación de mensajes diferentes gracias a las
#       directivas condicionales del Clisp (y del Common Lisp en general).
#
#: describe.lsp:251
#, fuzzy
msgid ", is accessible in the package~:[~;s~] ~{~A~^, ~}"
msgstr " y es accesible desde ~:[el paquete~;los paquetes~] ~{~A~^, ~}"

#: describe.lsp:256
#, fuzzy
msgid ", is a keyword"
msgstr ", una palabra clave"

#: describe.lsp:259
msgid ", a constant"
msgstr ", una constante"

#: describe.lsp:261
msgid ", a variable declared SPECIAL"
msgstr ", una variable declarada SPECIAL"

#: describe.lsp:262
msgid ", a variable"
msgstr ", una variable"

#: describe.lsp:264
#, fuzzy
msgid " (macro: ~s)"
msgstr " (macro)"

#: describe.lsp:267
#, fuzzy
msgid ", value: ~s"
msgstr " valores: "

#: describe.lsp:270
msgid ", names "
msgstr ", nombra "

#: describe.lsp:272
#, fuzzy
msgid "a special operator"
msgstr "una forma especial"

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: describe.lsp:274
msgid " with macro definition"
msgstr " con definición de macro"

#: describe.lsp:276
#, fuzzy
msgid "a~:[~; deprecated~] function"
msgstr "una función ~:[interpret~;compil~]ada."

#: describe.lsp:279
msgid "a macro"
msgstr "una macro"

#: describe.lsp:284
msgid ", names a type"
msgstr ", nombra un tipo"

#: describe.lsp:288
msgid ", names a class"
msgstr ", nombra una clase"

#: describe.lsp:294
msgid ", has the propert~@P ~{~S~^, ~}"
msgstr ", tiene ~[~;la propiedad~:;las propiedades~] ~{~S~^, ~}"

#: describe.lsp:297 describe.lsp:331 describe.lsp:354 describe.lsp:373 describe.lsp:416
msgid "."
msgstr "."

#: describe.lsp:301
#, fuzzy
msgid "~%Documentation as a ~a:~%~a"
msgstr "~%documentación: ~A"

#: describe.lsp:303 describe.lsp:442
#, fuzzy
msgid "~%For more information, evaluate ~{~S~^ or ~}."
msgstr "~%Para más información, evalúe ~{~S~^ o ~}."

#: describe.lsp:307
#, fuzzy
msgid "an integer, uses ~S bit~:p, is represented as a ~(~A~)."
msgstr "un entero que usa ~S bits y se representa como un ~(~A~)."

#: describe.lsp:310
msgid "a rational, not integral number."
msgstr "un racional, no un número entero."

#: describe.lsp:312
msgid "a float with ~S bits of mantissa (~(~A~))."
msgstr "un número en coma flotante con ~S bits de mantisa (~(~A~))."

#: describe.lsp:315
msgid "a complex number "
msgstr "un número complejo "

#: describe.lsp:320
msgid "at the origin"
msgstr "en el origen"

#: describe.lsp:321
msgid "on the ~:[posi~;nega~]tive real axis"
msgstr "en el eje real ~:[posi~;nega~]tivo"

#: describe.lsp:324
msgid "on the ~:[posi~;nega~]tive imaginary axis"
msgstr "en el eje imaginario ~:[posi~;nega~]tivo"

#: describe.lsp:326
#, fuzzy
msgid "in the ~:[~:[first~;fourth~]~;~:[second~;third~]~] quadrant"
msgstr "en el ~:[~:[primer~;cuarto~]~;~:[segundo~;tercer~]~] cuadrante"

# Si es lo que me imagino, tal vez sería mejor poner "del plano complejo".
# (como matemático que soy, me suena mejor :-). sv
#
# Pues sí, es exactamente lo que te imaginas, ..., "el plano de los números
# gaussianos" era una >>horrible<< traducción, ... ¡Gracias! cll
#
#: describe.lsp:328
msgid " of the Gaussian number plane."
msgstr " del plano complejo."

#: describe.lsp:330
msgid "a character"
msgstr "un carácter"

#: describe.lsp:335
msgid "~%Unicode name: ~A"
msgstr ""

#: describe.lsp:336
msgid "~%It is not defined by the Unicode standard."
msgstr ""

#: describe.lsp:337
msgid "~%It is a ~:[non-~;~]printable character."
msgstr "~% Se trata de un carácter ~:[no ~;~]imprimible."

#: describe.lsp:340
msgid "~%Its use is non-portable."
msgstr "~%Su utilización no es portable."

#: describe.lsp:342
msgid "a~:[~:[ closed ~;n output-~]~;~:[n input-~;n input/output-~]~]stream."
msgstr "un flujo ~:[~:[cerrado~;de salida~]~;~:[de entrada~;de entrada/salida~]~]."

#: describe.lsp:348
msgid "the package named ~A"
msgstr "el paquete ~A"

#: describe.lsp:352
msgid ". It has the nicknames ~{~A~^, ~}"
msgstr ". Tiene los apodos ~{~A~^, ~}"

# Duda: Debo comprobarlo en el código fuente de CLisp pero estoy casi
# seguro que esto es mucho mejor dejarlo sin traducir, ... cll
#
#: describe.lsp:357
#, fuzzy
msgid "~%It "
msgstr "~%"

#: describe.lsp:359
msgid "imports the external symbols of the package~:[~;s~] ~{~A~^, ~} and "
msgstr "importa los símbolos externos de~:[l paquete~; los paquetes~] ~{~A~^, ~} y "

#: describe.lsp:364
#, fuzzy
msgid "exports ~:[no symbols~;the symbols~:*~{~<~%~:; ~S~>~^~}~%~]"
msgstr "~:[no exporta ningún símbolo~;exporta los símbolos~:*~{~<~%~:; ~S~>~^~}~]"

#: describe.lsp:366
#, fuzzy
msgid "exports ~[no symbols~:;~:*~:d symbols~]"
msgstr "~:[no exporta ningún símbolo~;exporta los símbolos~:*~{~<~%~:; ~S~>~^~}~]"

#: describe.lsp:369
#, fuzzy
msgid " to the package~:[~;s~] ~{~A~^, ~}"
msgstr " ~:[al paquete~;a los paquetes~]: ~{~A~^, ~}"

#: describe.lsp:372
msgid ", but no package uses these exports"
msgstr ""

#: describe.lsp:374
msgid "a deleted package."
msgstr "un paquete borrado."

#
# Nota: Muy, muy importante.
#
# En la `españolización' de CLisp, debe programarse de nuevo la
# directiva ~P, para que los plurales se formen añadiendo "es" si el
# argumento no es `eql' a 1.
#
# Asimismo, debieran revisarse otras directivas de `format' como, por
# ejemplo, ~@P, ~:R, etc.
#
# ¡¡Pues no!! Cuando le dije esto a Bruno Haible, él me dijo que el
# estándar Common Lisp - The Language, no contemplaba la realización de
# este tipo de directivas en otros idiomas, sino especificamente en
# inglés. Ni español, ni alemán, ni francés, ...
#
#: describe.lsp:376
msgid "a hash table with ~S entr~:@P."
msgstr "una tabla hash con ~S entrada~:*~[s~;~:;s~]."

# Este mensaje tiene una especial dificultad, porque de el deberían
# salir cosas del tipo: "una tabla de lectura" (con `tabla de lectura'
# al final del mensaje) o "la tabla de lectura de Common Lisp" (con
# `tabla de lectura' al principio).
#
# Afortunadamente, la situación puede salvarse sin ningún problema
# gracias a la directiva ~:* de format
#
#: describe.lsp:379
msgid "~:[a~;the Common Lisp~] readtable."
msgstr "~:[una~;la~] tabla de lectura~:*~:[~; de Common Lisp~]"

#: describe.lsp:382
msgid "a ~:[~;portable ~]pathname~:[.~;~:*, with the following components:~{~A~}~]"
msgstr "una trayectoria~:[~; portátil~]~:[.~;~:*, constituída por: ~{~A~}~]"

#: describe.lsp:397
msgid "a random-state."
msgstr "un estado aleatorio."

#: describe.lsp:401
msgid "a~:[~; simple~] ~A dimensional array"
msgstr "una matriz~:[~; simple~] de dimensión ~A"

#: describe.lsp:404
msgid " (vector)"
msgstr " (vector)"

#: describe.lsp:406
msgid " of ~(~A~)s"
msgstr " de ~(~A~)s"

#: describe.lsp:409
msgid ", adjustable"
msgstr ", ajustable"

#: describe.lsp:411
msgid ", of size ~{~S~^ x ~}"
msgstr ", de tamaño ~{~S~^ x ~}"

#: describe.lsp:414
msgid " and current length (fill-pointer) ~S"
msgstr " y longitud actual (fill-pointer) ~S"

#: describe.lsp:421
msgid "a foreign function."
msgstr "una función externa."

#: describe.lsp:427
msgid "a built-in system function."
msgstr "una función predefinida del sistema."

#: describe.lsp:435
msgid "a~:[n interpret~; compil~]ed function."
msgstr "una función ~:[interpret~;compil~]ada."

#: describe.lsp:445
#, fuzzy
msgid "~%argument list: ~:S"
msgstr "~%lista de argumentos: ~S"

#: describe.lsp:448
#, fuzzy
msgid "~%documentation: ~A"
msgstr "~%documentación: ~A"

#: describe.lsp:453
msgid "~&~%~A [see above]"
msgstr ""

#: describe.lsp:456
msgid "~&~%~A is "
msgstr ""

#: describe.lsp:520
msgid "~S: ~S is not a function."
msgstr "~S: ~S no es una función."

#: describe.lsp:549
#, fuzzy
msgid "~%Argument list: "
msgstr "~%lista de argumentos: "

#: room.lsp:17
msgid "~S: argument must be ~S, ~S or ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: room.lsp:51 room.lsp:215
msgid "Total"
msgstr "Total"

#: room.lsp:59
msgid "~%Bytes permanently allocated:   ~9D~%Bytes currently in use:        ~9D~%Bytes available until next GC: ~9D~%"
msgstr "~%Bytes permanentemente asignados:   ~9D~%Bytes actualmente en uso:        ~9D~%Bytes disponibles hasta el próximo GC: ~9D~%"

#: edit.lsp:31
msgid "No external editor installed."
msgstr "No hay ningún editor externo instalado"

#: edit.lsp:103
msgid "~S cannot be edited."
msgstr "~S no puede ser editado."

#: edit.lsp:122
msgid "~S: source code for ~S not available."
msgstr "~S: el código fuente de ~S no está disponible."

#: macros3.lsp:13
msgid ""
"The form ~S yielded ~:[no values~;~:*~{~S~^ ; ~}~] ,~@\n"
"                       that's not of type ~S."
msgstr ""
"La forma ~S ~:[no produjo ningún valor~;produjo ~:*~{~S~^ ; ~}~] ,~@\n"
"                       que no es del tipo ~S."

#: macros3.lsp:64
msgid "LETF* code contains a dotted list, ending with ~S"
msgstr "El código del LETF* contiene una lista punteada que termina con ~S"

#: macros3.lsp:83
msgid "illegal syntax in LETF* binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF*: ~S"

#: macros3.lsp:227
msgid "LETF code contains a dotted list, ending with ~S"
msgstr "El código de LETF contiene una lista punteada que termina con ~S"

#: macros3.lsp:246
msgid "illegal syntax in LETF binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF: ~S"

# Creo que si ~S es un sólo carácter, te cabe en la misma línea :-) sv
#
#: foreign1.lsp:86
msgid "Cannot map string ~S to C since it contains a character ~S"
msgstr "La cadena ~S no puede convertirse a C puesto que contiene el carácter ~S"

#: foreign1.lsp:128
msgid "Incomplete FFI type ~S is not allowed here."
msgstr "El tipo incompleto FFI ~S no está permitido aquí"

#: foreign1.lsp:134
msgid "FFI type should be a symbol, not ~S"
msgstr "Un tipo FFI debe ser un símbolo, no ~S"

# Duda: pues un poco lo de siempre. FFI significa Foreign Function
# Interface y todo el mundo sabe que es el módulo de llamadas a
# funciones escritas en otro lenguaje (lo que yo he traducido como
# llamadas extranjeras). Los programadores avanzados en Lisp (y sólo
# ellos podrían ver un mensaje como este, ...) saben muy bien lo que es
# FFI. ¿Lo dejo así?, ...
#
# Uno de nuestros revisores (César Ballardini) dijo en cierta ocasión:
# "No es necesario explicar la terminología dentro de su propio contexto."
# Es decir: Si finalmente te decides por FFI (que por lo que dices
# parece lo más razonable), pon cuidado de no explicarlo tanto, por ejemplo,
# en el mensaje anterior al anterior a este. sv
#
# Vale, pues entonces se queda como FFI ¡y listo! cll
#
#: foreign1.lsp:138
msgid "Invalid FFI type: ~S"
msgstr "Tipo FFI inválido: ~S"

#: foreign1.lsp:155 foreign1.lsp:220
msgid "Invalid ~S component: ~S"
msgstr "Componente ~S inválida: ~S"

#: foreign1.lsp:329
msgid "Invalid option in ~S: ~S"
msgstr "Opción inválida en ~S: ~S"

#: foreign1.lsp:333
msgid "Only one ~S option is allowed: ~S"
msgstr "Sólo se permite una opción ~S: ~S"

#: foreign1.lsp:350
msgid "Invalid parameter specification in ~S: ~S"
msgstr "Especificación de parámetro inválida en ~S: ~S"

#: foreign1.lsp:411
msgid "The name must be a string, not ~S"
msgstr "El nombre debe ser una cadena, no ~S"

#: foreign1.lsp:416
msgid "The name ~S is not a valid C identifier"
msgstr "El nombre ~S no es un identificador válido en C"

#: foreign1.lsp:671
msgid "illegal foreign data type ~S"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign1.lsp:801
msgid "~S: ~S option missing in ~S"
msgstr "~S: falta la opción ~S en ~S"

#: foreign1.lsp:996
msgid "~S: :OUT argument is not a pointer: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#: foreign1.lsp:1060
msgid "~S is only allowed after ~S: ~S"
msgstr "Sólo se puede poner ~S después de ~S: ~S"

#: affi1.lsp:41
msgid "Basename ~S not a keyword or libraryname ~S not a string"
msgstr "La base ~S no es una palabra clave o el nombre de la biblioteca ~S no es una cadena de caracteres"

#: affi1.lsp:48
msgid "Library redefinition: old ~S, new ~S"
msgstr "La biblioteca llamada ~S ha sido redefinida como ~S"

#: affi1.lsp:58
msgid "Unknown library: ~S"
msgstr "Biblioteca desconocida: ~S"

#: affi1.lsp:85
msgid "Library ~S is not open"
msgstr "La biblioteca ~S no está abierta"

#: affi1.lsp:147
msgid "Unknown function of library ~S: ~S"
msgstr "No se conoce ninguna función en la biblioteca ~S con el nombre ~S"

#: affi1.lsp:173
msgid "Offset must be a fixnum: ~S"
msgstr "El desplazamiento no es del tipo FIXNUM: ~S"

#: affi1.lsp:184
msgid "~&;; redefining foreign library function ~S~%;;  from ~S to ~S~%"
msgstr "~&;; redefiniendo la función ~S de la biblioteca externa~%;;  de ~S a ~S~% "

#: affi1.lsp:203
msgid "Unknown register: ~S"
msgstr "Registro desconocido: ~S"

#: affi1.lsp:215
msgid "Invalid parameter specification ~S in function ~S"
msgstr "La especificación de parámetros ~S de la función ~S es incorrecta"

#: affi1.lsp:227
msgid "Unknown library function: ~S"
msgstr "La función de biblioteca ~S no está definida"

#: affi1.lsp:244
msgid "Bad number of arguments for ~S: ~S"
msgstr "El número de argumentos de ~S es incorrecto: ~S"

#: rexx1.lsp:146
msgid "No waiting for ~S possible."
msgstr "No se puede esperar por ~S."

#: defs3.lsp:231
#, fuzzy
msgid "~S: argument ~S should be a string or a symbol"
msgstr "~: el argumento ~ debe ser una cadena o un símbolo"

#~ msgid "stack overflow during bignum arithmetic"
#~ msgstr "desbordamiento de la pila durante la realización de operaciones aritméticas con números grandes"

#~ msgid "graphics not initialized"
#~ msgstr "los gráficos no han sido inicializados"

#~ msgid "~: cannot switch to graphics mode"
#~ msgstr "~: no es posible conmutar al modo gráfico"

#~ msgid "~%Description of~%"
#~ msgstr "~%Descripción de~%"

# Duda: ¡Atención! "This is" se debería traducir por "Este es" o "Esta
# es". Desgraciadamente, cuando se escribe este mensaje (que es el
# principio de una frase más larga) no se dispone de ninguna variable
# cuyo contenido se pueda examinar para comprobar si se debe usar el
# masculino o el femenino. Sin embargo, "Se trata de" queda al pelo.
#
# Para que lo veais, a continuación muestro dos sesiones diferentes
# donde "Se trata de" queda que ni pintado, ... (sin embargo, sustituid
# mentalmente por "Este es" o "Esta es" y vereis que el primer caso,
# necesariamente debería ser masculino y el segundo femenino):
#
# > (describe 'a)
#
# Descripción de
# A
# Se trata de el símbolo A.
# El símbolo está en el #<PACKAGE USER> y es accesible desde el paquete USER.
#
# > (describe '(a b c))
#
# Descripción de
# (A B C)
# Se trata de una lista de longitud 3.
#
#~ msgid "~%This is "
#~ msgstr "~%Se trata de "

#~ msgid "a function"
#~ msgstr "una función"

#~ msgid "~%The symbol "
#~ msgstr "~%El símbolo "

# Duda: pipe, todo el mundo sabe lo que es un pipe. Más aún, todo el mundo
#       conoce el mensaje `broken pipe'. Para no guiar a confusiones considero
#       que, excepcionalmente, se debe añadir la palabra pipe entre paréntesis,
#       con la intención de recordar al usuario lo que se quiere decir con
#       Tubería, ...
#
# Si en los cursillos de Unix se enseñara a los niños que esto | 
# es una tubería, no tendríamos que andar haciendo estas tonterías.
# Voto por eliminarlas de una vez por todas.
# "Tubería rota". sv
#
# Precisamente en estos días se discute esto mismo en la lista es@li.org
# (todavía no he enviado mi mensaje con mi opinión, pero lo haré,
# ...). La verdad es que creo que tienes razón. Sin ser exagerados y
# "eliminar de una vez por todas", creo que, en este caso, hay que
# arriesgarse y tirar p'alante, ¿no? ¡¡pues eso!! ¡¡¡"Tuberías rotas" al
# poder!!! - cll
#
#~ msgid "Broken pipe"
#~ msgstr "Tubería rota"

#~ msgid "character ~ is not a string-char, cannot be output onto ~"
#~ msgstr "el carácter ~ no es del tipo STRING-CHAR, y por ello no puede escribirse en ~"

#~ msgid "~: argument should be a string-char, not ~"
#~ msgstr "~: el argumento debe ser del tipo STRING-CHAR, no ~"

#~ msgid "~: ~ is not a string-char"
#~ msgstr "~: ~ no es un STRING-CHAR"

# Duda: uufff!!! Keypad, keypad, ..., ¿Teclado auxiliar?
#
# A continuacion reproduzco la pregunta que formule en la lista de CLisp:
#
# > 2. When does the message "Keypad-" appear?. The Keypad is the set of
# > numeric keys that are at the left of the keyboard. But I need to know
# > with which kind of messages does it join to know how to translate it.
#
# Y la respuesta de Bruno Haible:
#
# In phrases like "Please press Keypad-Enter when done".
#
# Francamente, me parece que la utilizacion de Keypad, a secas, será lo
# mejor.
#
#
#~ msgid "Keypad-"
#~ msgstr "Keypad-"

#~ msgid " with additional bits"
#~ msgstr " con bits adicionales"

#~ msgid " from font ~S"
#~ msgstr " de la fuente ~S"

#~ msgid "cursor up"
#~ msgstr "cursor arriba"

#~ msgid "cursor down"
#~ msgstr "cursor abajo"

#~ msgid "cursor left"
#~ msgstr "cursor a la izquierda"

#~ msgid "cursor right"
#~ msgstr "cursor a la derecha"

#~ msgid "cursor to start of line"
#~ msgstr "cursor al principio de línea"

#~ msgid "cursor to end of line"
#~ msgstr "cursor al final de la línea"

#~ msgid "cursor to start of text"
#~ msgstr "cursor al principio del texto"

#~ msgid "cursor to end of text"
#~ msgstr "cursor al final del texto"

#~ msgid "page up"
#~ msgstr "retroceso de página"

#~ msgid "page down"
#~ msgstr "avance de página"

#~ msgid "line up"
#~ msgstr "retroceder una línea"

#~ msgid "line down"
#~ msgstr "avanzar una línea"

#~ msgid "set mark ~D"
#~ msgstr "poner la marca ~D"

#~ msgid "cursor to mark ~D"
#~ msgstr "mover el cursor a la marca ~D"

#~ msgid "delete character at cursor"
#~ msgstr "borrar el carácter bajo el cursor"

#~ msgid "combine two lines"
#~ msgstr "juntar dos líneas"

#~ msgid "delete character at cursor, across lines"
#~ msgstr "borrar el carácter bajo el cursor, a través de varias líneas"

#~ msgid "delete character before cursor"
#~ msgstr "borrar el carácter antes del cursor"

#~ msgid "delete character before cursor, across lines"
#~ msgstr "borrar el carácter antes del cursor, a través de varias líneas"

#~ msgid "delete line"
#~ msgstr "borrar una línea"

#~ msgid "delete part of line left to the cursor"
#~ msgstr "borrar la línea hasta donde está el cursor"

#~ msgid "delete up to end of line"
#~ msgstr "borrar hasta el final de la línea"

#~ msgid "begin new line at cursor"
#~ msgstr "comenzar una nueva línea en la posición del cursor"

#~ msgid "cursor to start of block"
#~ msgstr "mover el cursor al comienzo del bloque"

#~ msgid "cursor to end of block"
#~ msgstr "mover el cursor al final del bloque"

#~ msgid "set block start"
#~ msgstr "establecer el comienzo de un bloque"

#~ msgid "set block end"
#~ msgstr "establecer el final de un bloque"

#~ msgid "remove block marks"
#~ msgstr "desechar las marcas del bloque"

#~ msgid "delete block"
#~ msgstr "borrar un bloque"

#~ msgid "move block to cursor position"
#~ msgstr "mover el bloque a la posición del cursor"

#~ msgid "copy block to cursor position"
#~ msgstr "copiar un bloque a la posición del cursor"

#~ msgid "copy block into cut-and-paste buffer"
#~ msgstr "copiar un bloque en el buffer de cortar-y-pegar"

#~ msgid "yank block into cut-and-paste buffer"
#~ msgstr "insertar un bloque en el buffer de cortar-y-pegar"

#~ msgid "insert cut-and-paste buffer contents"
#~ msgstr "inserta los contenidos del buffer cortar-y-pegar"

#~ msgid " Key bindings "
#~ msgstr " Asociaciones de teclado "

#~ msgid "                           K E Y   B I N D I N G S"
#~ msgstr "                 A S O C I A C I O N E S   D E   T E C L A D O"

#~ msgid " File to load: "
#~ msgstr " Lectura del fichero: "

#~ msgid " Save as: "
#~ msgstr " Salvar como: "

#~ msgid "evaluate block contents"
#~ msgstr "evaluar los contenidos del bloque"

#~ msgid "skip whitespace right"
#~ msgstr "ignorar los espacios en blanco a la derecha"

#~ msgid "~S from ~S: |# is legal only after #|"
#~ msgstr "~ en ~: |# es legal solo después de #|"

#~ msgid "mark next Lisp object"
#~ msgstr "marcar el siguiente objeto Lisp"

#
# Duda: `surrounding' por `circundante'
#
# ¿ Qué os parece ?
#
#~ msgid "mark surrounding top level form"
#~ msgstr "marcar la forma circundante"

#
# Duda: `surrounding' por `circundante'
#
# ¿ Qué os parece ?
#
#~ msgid "evaluate surrounding top level form"
#~ msgstr "evaluar la forma circundante"

#~ msgid "insert spaces up to next tab stop"
#~ msgstr "insertar espacios hasta la siguiente marca de tabulación"

#~ msgid "search for a string"
#~ msgstr "buscar una cadena de caracteres"

#~ msgid " Search: "
#~ msgstr " Buscar: "

#~ msgid "continue searching"
#~ msgstr "continuar la búsqueda"

#~ msgid "show window ~D"
#~ msgstr "mostrar la ventana ~D"

#~ msgid "hide window ~D"
#~ msgstr "ocultar la ventana ~D"

#~ msgid "show help window (this text)"
#~ msgstr "muestra la ventana de ayuda (este texto) "

#~ msgid "show error window"
#~ msgstr "mostrar la ventana de error"

#~ msgid "show trace window"
#~ msgstr "mostrar la ventana de rastreo"

#~ msgid "delete current window"
#~ msgstr "borrar la ventana actual"

#~ msgid "load file"
#~ msgstr "cargar el fichero \""

#~ msgid "store to file"
#~ msgstr "almacenar en el fichero"

#~ msgid "store to new file"
#~ msgstr "almacenar en un fichero nuevo"

#~ msgid "quit editor"
#~ msgstr "salir del editor"

#~ msgid "hide top window"
#~ msgstr "ocultar la ventana superior"
