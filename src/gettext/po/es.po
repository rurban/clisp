# Mensajes en español para GNU CLISP.
# Copyright (C) 1996 Free Software Foundation, Inc.
# Carlos Linares López <clinares@delicias.dia.fi.upm.es>, 1997.
#
# Han contribuido a esta traducción:
#
# cll - Carlos Linares López 	(Traducción)
# sv  - Santiago Vila Doncel	(Revisión)
# lsg - Leonardo Sarasúa García	(Traducción y Revisión)
#
# Agradecimientos especiales a:
#
# Bruno Haible
# Marcus Daniels
# 					(Programadores de CLisp)
#
# Enrique Melero
# 				    (Coordinador de Spanish GNU)
#
# Por haber atendido siempre mis preguntas y por mostrar tanto interés
# en esta traducción.
#
# Asimismo, quisiera expresar mi agradecimiento a las siguientes
# personas, por responder pacientemente todas mis preguntas: Joerg
# Hoehle (traductor de la versión francesa) y Juan Jordana.
#
# Por último, a toda la lista de Spanish GNU Translation Team
# (es@li.org) por sus sugerencias.
#
# NOTAS.
#
# * Los mensajes en los que se han realizado anotaciones de interés,
# bien porque haya alguna duda, bien porque contenga notas importantes
# relativas a las traducciones tienen la palabra `Duda:' al principio de
# su comentario.
#
# * Por favor, si alguien realiza alguna modificación a este archivo que
# ponga sus iniciales al final del comentario explicando el cambio y el
# motivo. Si su nombre no está en esta cabecera que lo añada poniendo
# las iniciales.
#
# * Todas las líneas que comienzan con #~ son mensajes obsoletos que no
# hace falta revisar
#
# $Id$
# $Log$
# Revision 1.9  1997/09/18 13:36:38  clinares
# He incluído nuevas modificaciones de Leo Sarasúa.
#
# Entre las más representativas está el hecho de haber modificado
# `trama' por `marco' y `# macro carácter' por `macro carácter
# secundario'. Nuevamente gracias, Leo, ...
#
# Revision 1.8  1997/09/05 17:23:30  clinares
# He introducido todas las modificaciones propuestas por Santiago Vila a
# la versión 1.6. Además, las he adaptado para el nuevo .pot que se
# empleó en la versión 1.7.
#
# Entre los cambios más importantes está: `command' es `orden', no
# `comando'; `warning' es, preferiblemente, `atención' y, en otro caso,
# propongo que sea `advertencia', en vez de `aviso'.
#
# Revision 1.7  1997/09/03 17:51:44  clinares
# He modificado la traducción de las directivas ~P, puesto que nunca se
# escribirán versiones en español de ellas, ya que el estándar Common
# Lisp - The Language es muy específico: solo en inglés. Ni en alemán,
# ni francés, ni español, ...
#
# Además, he adaptado los cambios del POT de la versión 1.6
# (POT-Creation-Date: 1997-05-04) a la última versión que existe
# actualmente (POT-Creation-Date: 1997-09-02). Para ello, he traducido 9
# mensajes nuevos, he corregido los mensajes difusos y he borrado todos
# los obsoletos.
#
# Revision 1.6  1997/08/30 14:04:08  clinares
# El 100% de los mensajes están traducidos :)
# En total, 9 meses de trabajo (es decir, ¡¡ha sido un parto!! :)
#
# Revision 1.5  1997/08/27 00:48:46  clinares
# Esta es la traducción que resulta de programar todos los cambios
# propuestos por lsg (Leonardo Sarasúa García). En total, ¡¡alrededor de
# 800 líneas!!, ahí es nada :)
#
# Muchísimas gracias, Leo. Te debo la cerveza más grande del mundo, ...
#
#
# ------------------------------------------------------------------
# msgfmt --statistics -c -v -o /dev/null /home/clinares/GNU/clisp.po
# 1387 mensajes traducidos.
# ------------------------------------------------------------------
#
msgid ""
msgstr ""
"Project-Id-Version: GNU clisp 1996-03-31\n"
"POT-Creation-Date: 1998-08-09 16:06:00 EDT\n"
"PO-Revision-Date: 1997-08-11 18:16 MET DST\n"
"Last-Translator: Carlos Linares López <clinares@delicias.dia.fi.upm.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: constobj.d:422
msgid "Please choose:"
msgstr "Por favor, escoja:"

#: constobj.d:428
msgid "Please choose one of ~:{~A~:^, ~} ."
msgstr "Por favor, elija uno/a de ~:{~A~:^, ~} ."

#: constobj.d:433
msgid "symbol ~A from #<PACKAGE ~A> will become a shadowing symbol"
msgstr "el símbolo ~A del paquete #<PACKAGE ~A> se convertirá en un símbolo que eclipsa a otro"

#: constobj.d:437
msgid "You may choose the symbol in favour of which to resolve the conflict."
msgstr "Puede elegir el símbolo en favor del cual se resolverá el conflicto."

#: constobj.d:441
msgid "uninterning ~S from ~S uncovers a name conflict."
msgstr "Al sacar ~S de ~S se ha puesto de manifiesto un conflicto entre nombres."

#: constobj.d:445 constobj.d:475
msgid "You may choose how to proceed."
msgstr "Puede elegir cómo continuar."

#: constobj.d:449
msgid "importing ~S into ~S produces a name conflict with ~S."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S."

#: constobj.d:453
msgid "importing ~S into ~S produces a name conflict with ~S and other symbols."
msgstr "la importación de ~S en ~S produce un conflicto de nombres con ~S y otros símbolos."

#
# publicar está mal y ademas no es consistente con el mensaje d:329 en el que dice 'sacar'
# En este y en otros mensajes, el texto no es una orden dada al usuario, sino una opción que
# se le ofrece. Por tanto, no debe traducirse como un imperativo (impórtelo)  sino en
# infinitivo (importarlo). Pero deberías confirmar esto. - lsg
#
# Si, creo que tienes toda la razón, ... Entonces pongo `sacar' que
# aunque suene muy burro, creo que es muy, muy claro, ...
#
#: constobj.d:457
msgid "((\"I\" \"import it and unintern the other symbol\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"impórtarlo y sacar el otro símbolo\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Aquí tengo la misma duda anterior - lsg
#
#: constobj.d:464
msgid "((\"I\" \"import it, unintern one other symbol and shadow the other symbols\" T) (\"N\" \"do not import it, leave undone\" NIL))"
msgstr "((\"I\" \"importarlo, sacar uno de los otro símbolos y eclipsar el resto\" T) (\"N\" \"no importarlo, dejarlo como está\" NIL))"

#
# Lo mismo de antes - lsg
#
#: constobj.d:471
msgid "((\"I\" \"import it and shadow the other symbol\" T) (\"N\" \"do nothing\" NIL))"
msgstr "((\"I\" \"importarlo y eclipsar el otro símbolo\" T) (\"N\" \"no hacer nada\" NIL))"

#: constobj.d:479
msgid "symbol ~S should be imported into ~S before being exported."
msgstr "el símbolo ~S debe ser importado a ~S antes de ser exportado."

#
# La misma cuestión anterior entre imperativo e infinitivo - lsg
#
#: constobj.d:483
msgid "((\"I\" \"import the symbol first\" T) (\"N\" \"do nothing, don't export the symbol\" NIL))"
msgstr "((\"I\" importar el símbolo primero\" T) (\"N\" \"no hacer nada, no exportar el símbolo\"))"

#: constobj.d:490
msgid "You may choose in favour of which symbol to resolve the conflict."
msgstr "Puede elegir en favor de qué símbolo se debe resolver el conflicto."

#
# El segundo from deberia ser 'de', porque quiere decir que un símbolo
# a de un paquete A entra en conflicto con el símbolo b _del_ paquete
# B. Luego, debe ser 'de'.
#
#: constobj.d:494
msgid "exporting ~S from ~S produces a name conflict with ~S from ~S."
msgstr "la exportación de ~S desde ~S produce un conflicto de nombres con ~S de ~S."

#: constobj.d:498
msgid "Which symbol should be accessible in ~S ?"
msgstr "¿ Qué símbolo debe ser accesible en ~S ?"

#: constobj.d:504
msgid "the symbol to export, "
msgstr "el símbolo a exportar, "

#: constobj.d:508
msgid "the old symbol, "
msgstr "El símbolo original, "

#: constobj.d:512
msgid "You may choose for every conflict in favour of which symbol to resolve it."
msgstr "Puede elegir en favor de qué símbolo se debe resolver cada conflicto."

#
# Es una traducción un poco libre (literalmente sería "el nombre = ~S
# entra en conflicto...."), pero ésta me parece más corta y correcta. - lsg
#
#: constobj.d:516
msgid "~S name conflicts while executing USE-PACKAGE of ~S into package ~S."
msgstr "Conflicto de nombre ~S al ejecutar USE-PACKAGE de ~S al paquete ~S"

#: constobj.d:520
msgid "which symbol with name ~S should be accessible in ~S ?"
msgstr "¿ Qué símbolo con nombre ~S debe ser accesible en ~S ?"

#: constobj.d:524
msgid "You can input another name."
msgstr "Puede introducir otro nombre."

#: constobj.d:528
msgid "You can input another nickname."
msgstr "Puede introducir otro apodo."

#: constobj.d:532
msgid "a package with name ~S already exists."
msgstr "ya existe un paquete con el nombre ~S."

#
# Si fuera inglés corriente, estaría bien tu traducción, pero es inglés
# 'telegráfico', y en realidad quieren decir lo que te he escrito, es
# decir, 'nuevo' afecta a 'nombre', no a 'paquete'.
#
# Eres un gran maestro, algo así como un quinto dan de las traducciones,
# ... ¡Tienes toda la razón! :) - cll
#
#: constobj.d:536
msgid "Please input new package name:"
msgstr "Por favor, introduzca un nuevo nombre de paquete:"

#: constobj.d:540
msgid "Please input new package nickname:"
msgstr "Por favor, introduzca un nuevo apodo de paquete:"

# Ojo con el ignorar. sv
#
# No, ya te he puesto antes las acepciones de esta palabra y esta vez,
# viene al caso, ... cll
#
# O sea, que estás 'ignorando ' la sugerencia de sv, ;-) - lsg
#
# Muy bueno, muy bueno, ... :) Santiago, por aquí hay mucho cachondeo :) - cll
#
#
#: constobj.d:544
msgid "Ignore."
msgstr "Ignorar."

#
# Leo, aunque tu propones "No existe ningún paquete con nombre ~S.",
# pienso que "No hay ningún paquete con el nombre ~S" es ligeramente
# mejor, ¿qué te parece? - cll
#
#: constobj.d:548
msgid "~S: There is no package with name ~S."
msgstr "~S: No hay ningún paquete con el nombre ~S."

#: constobj.d:552
msgid "~*Nevertheless delete ~S."
msgstr "~*No obstante borre ~S."

#
# Leo, en vez de "está siendo utilizado", ¿no crees que es mejor "es
# utilizado"? - cll
#
# Propongo *se utiliza*, es mucho más español. sv
#
# Pero, ¿cómo pones algo así? "~S se utiliza en ~{~S~^, ~}.", ¿por
# ejemplo? Es que el problema es que no ~S (el primero) no "se utiliza"
# en la segunda expresión, sino que la segunda expresión es una que
# emplea a la primera. No se si me explico, ...
#
# En cualquier caso, creo que tienes toda la razón al decir "es mucho
# más español", es que de hecho la expresión "es utilizado" aunque es
# correcta, no parece muy española, por favor, ¿sugerencias? - cll
#
#: constobj.d:556
msgid "~S: ~S is used by ~{~S~^, ~}."
msgstr "~S: ~S es utilizado por ~{~S~^, ~}."

#: constobj.d:570
msgid "January"
msgstr "Enero"

#: constobj.d:576
msgid "February"
msgstr "Febrero"

#: constobj.d:582
msgid "March"
msgstr "Marzo"

#: constobj.d:588
msgid "April"
msgstr "Abril"

#: constobj.d:594
msgid "May"
msgstr "Mayo"

#: constobj.d:600
msgid "June"
msgstr "Junio"

#: constobj.d:606
msgid "July"
msgstr "Julio"

#: constobj.d:612
msgid "August"
msgstr "Agosto"

#: constobj.d:618
msgid "September"
msgstr "Septiembre"

#: constobj.d:624
msgid "October"
msgstr "Octubre"

#: constobj.d:630
msgid "November"
msgstr "Noviembre"

#: constobj.d:636
msgid "December"
msgstr "Diciembre"

#: constobj.d:652
msgid "ANSI C program"
msgstr "programa ANSI C"

#: constobj.d:658
msgid "GNU C++ "
msgstr "GNU C++"

#: constobj.d:663
msgid "GNU C "
msgstr "GNU C "

#: constobj.d:672
msgid "C++ compiler"
msgstr "Compilador de C++"

#: constobj.d:677
msgid "C compiler"
msgstr "Compilador de C"

# Ojo: ¿¿No sería "INGLÉS"?? sv
#
# No, esto está bien, esta expresión se utiliza en una parte del código
# de CLisp en la que se realiza la inicialiación dependiente del idioma,
# de modo que en la traducción alemana pone "DEUTSCH" y en la francesa
# "FRANCAIS", pues en la española, "ESPAÑOL", como corresponde - cll
#
#: constobj.d:684
msgid "ENGLISH"
msgstr "ESPAÑOL"

#: constobj.d:843
msgid "The value of ~S was not a pathname. ~:*~S is being reset."
msgstr "El valor de ~S no es del tipo PATHNAME. ~:*~S se reinicializará."

#: constobj.d:850
#, fuzzy
msgid "Creating directory: "
msgstr "no es un directorio: ~"

#: constobj.d:988
msgid ""
"The variable ~S had an illegal value.\n"
"~S has been reset to ~S."
msgstr ""
"La variable ~S tenía un valor inválido.\n"
"~S ha sido inicializado a ~S."

#: constobj.d:992
msgid ""
"Floating point operation combines numbers of different precision.\n"
"See ANSI CL 12.1.4.4 and the CLISP impnotes for details.\n"
"The result's actual precision is controlled by\n"
"~S.\n"
"To shut off this warning, set ~S to ~S."
msgstr ""

#: constobj.d:1009
msgid "Bye."
msgstr "Adiós."

# Un poco más en español podría ser: "Entorno siguiente: " sv
#
# Hmmm, ..., aquí no estoy de acuerdo contigo. No me suena bien lo del
# "Entorno siguiente", ... cll
#
#: constobj.d:1016
msgid ""
"\n"
"  Next environment: "
msgstr ""
"\n"
"  Siguiente entorno: "

#: constobj.d:1020
msgid ""
"\n"
"APPLY frame with breakpoint for call "
msgstr ""
"\n"
"marco APPLY con punto de ruptura para invocar "

#: constobj.d:1024
msgid ""
"\n"
"APPLY frame for call "
msgstr ""
"\n"
"marco APPLY para invocar "

#: constobj.d:1028
msgid ""
"\n"
"EVAL frame with breakpoint for form "
msgstr ""
"\n"
"marco EVAL con punto de ruptura para la forma "

#: constobj.d:1032
msgid ""
"\n"
"EVAL frame for form "
msgstr ""
"\n"
"marco EVAL para la forma "

#
# A ver aquí, que hay mogollón, hay mogollón, ...
#
# Leo, tu opinas que aquí deberíamos traducir:
#
# "variables con vinculación de recintos (~ = dinámicamente):"
#
# Sin embargo, yo creo que lo más correcto es:
#
# "trama de ligadura de las variables (~ = dinámicamente):"
#
# Puesto que esto se refiere al tipo de tramas que hay en la pila,
# cuando ésta está siendo examinada. De hecho, la traducción francesa
# es:
#
# "Le «frame» de liaison de variables (~ signifiant dynamique) lie :"
#
# ..., que viene a ser algo como lo que he puesto yo. - cll
#
#: constobj.d:1036
msgid ""
"\n"
"frame binding variables (~ = dynamically):"
msgstr ""
"\n"
"marco de ligadura de las variables (~ = dinámicamente):"

#: constobj.d:1041
msgid ""
"\n"
"CALLBACK frame"
msgstr ""
"\n"
"marco CALLBACK"

#: constobj.d:1046
msgid ""
"\n"
"frame binding variables "
msgstr ""
"\n"
"marco de ligadura de las variables"

#: constobj.d:1050
msgid ""
"\n"
"frame binding functions "
msgstr ""
"\n"
"marco de ligadura de las funciones "

#: constobj.d:1054
msgid " binds (~ = dynamically):"
msgstr " vincula (~ = dinámicamente):"

#: constobj.d:1059
msgid ""
"\n"
"block frame "
msgstr ""
"\n"
"marco de bloque"

#: constobj.d:1063
msgid ""
"\n"
"nested block frame "
msgstr ""
"\n"
"marco anidado de bloque"

#: constobj.d:1067
msgid " for "
msgstr " para "

#: constobj.d:1071
msgid ""
"\n"
"compiled block frame for "
msgstr ""
"\n"
"marco de bloque compilado para "

#: constobj.d:1075
msgid ""
"\n"
"tagbody frame "
msgstr ""
"\n"
"marco de cuerpo de etiquetas de salto"

# Duda: Aquí lo de `nested' es bastante puñetero. Creo que no debe
# traducirse por `anidado' (que no tendría demasiado sentido, creo),
# sino por `encajada', haciendo referencia a la trama a la que se llega
# por el uso de las etiquetas de salto, ...
#
# Sin embargo, no estoy demasiado seguro, ... ¡¡Socorro!! - cll
#
# A propósito de esta cuestión, pregunté en la lista de correo de CLisp:
#
# > `nested' have various meanings. It can mean that one thing is `into'
# > other one or that one thing is `joined' with other one. In this
# > message, I think you are talking about the frame you arrive when using
# > a tag, as if you were `joining' a new frame, is it so?
#
# Y la respuesta de Bruno Haible fue:
#
# No. In CLISP it's yet another (maybe new?) meaning. Interpretation frames
# are normally built up in the stack. However, when a closure is created,
# some parts of the frames must be moved out to the heap, so that the
# closure points to valid data, called "environment", even after the frame
# has been deestablished. We called this process "nesting" of a frame.
# Any better vocabulary? Can you propose a good german or french translation?
#
# Asi que, la verdad, "anidado" me parece correcto. Para ello, imaginaos
# una trama (o marco), de la que se "re-elabora" una parte denominada
# "entorno" pero que solo tiene sentido dentro de esta trama (o marco),
# puesto que se ha levantado un `closure'. - cll
#
#: constobj.d:1079
msgid ""
"\n"
"nested tagbody frame "
msgstr ""
"\n"
"marco anidado del cuerpo de etiquetas de salto"

#: constobj.d:1083
msgid " for"
msgstr " para"

#: constobj.d:1088
msgid ""
"\n"
"compiled tagbody frame for "
msgstr ""
"\n"
"marco compilado del cuerpo de etiquetas de salto para "

#
# Ésta estaba claramente mal - lsg
#
#: constobj.d:1092
msgid ""
"\n"
"catch frame for tag "
msgstr ""
"\n"
"marco de captura para la etiqueta "

# Handler, otra buena.. Sugerencias? - lsg
#
# Duda: ¿cómo traducir `handler'?
#
# Pues bien, he elegido el término `manipulador' puesto que eso es,
# precisamente, lo que es un `handler' en Common Lisp. De hecho, el
# estándar Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr.,
# en la página 872 dice:
#
# "The process of signaling involves the search for an invocation of a
# handler, a piece of code that will attempt to deal appropiately with
# the situation"
#
# Y atención a la siguiente observación: (en la misma página, a
# continuación del párrafo anterior)
#
# "If a handle is found, it may either handle the situation, by
# performing some non-local transfer of control, or decline to handle
# it, by failing to perform a non-local transfer of control. If it
# declines, other handlers are sought".
#
# En fin, a la vista de esta definición y de la siguiente aclaración,
# propongo `manejador' para su traducción - cll
#
#: constobj.d:1096
msgid ""
"\n"
"handler frame for conditions"
msgstr ""
"\n"
"marco de manipulación (HANDLER) para las condiciones"

#
# Estaba mal. Yo pondria: "recinto de unwind-protect" - lsg
#
# Y yo creo que si cambiamos `recinto' por `trama' ya es la leche de
# perfecto ;) - cll
#
# Leo, como puedes ver he cambiado en todos lados `trama' por `marco' - cll
#
#: constobj.d:1100
msgid ""
"\n"
"unwind-protect frame"
msgstr ""
"\n"
"marco `unwind-protect'"

# Duda: Lo de `driver' lo dejo sin traducir, ...
#
# En la traducción francesa está sin traducir y en el estándar de Common
# Lisp no se hace ni la mas mínima referencia a algo que se llame así.
#
# "recinto de driver" - lsg
#
# Vale, ¡pero vamos!, que cambio `recinto' por `trama' - cll
#
#: constobj.d:1104
msgid ""
"\n"
"\n"
"driver frame"
msgstr ""
"\n"
"\n"
"marco `driver'"

# "Entornos con vinculación de recintos" - lsg
#
# Aquí volvemos un poco a lo del mensaje constobj.d:915 Según creo,
# estos mensajes se refieren al tipo de tramas que hay en la pila, no se
# trata de un entorno (en el sentido que en Lisp tiene esta palabra).
#
# La traducción francesa dice:
#
# "«frame» de liaison d'environnements"
#
# ¿Que os parece?
#
#: constobj.d:1108
msgid ""
"\n"
"frame binding environments"
msgstr ""
"\n"
"marco de ligadura del entorno"

# "*** - Memoria virtual agotada. REINICIALIZACION " - lsg
#
# Yo creo que el mensaje debe acabar en un imperativo: REINICIALIZAR - cll
#
#: spvw.d:920
msgid ""
"\n"
"*** - Virtual memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria virtual agotada. REINICIE"

# "*** - Memoria agotada. REINICIALIZACION " - lsg
#
# Más de lo mismo - cll
#
#: spvw.d:926
msgid ""
"\n"
"*** - Memory exhausted. RESET"
msgstr ""
"\n"
"*** - Memoria agotada. REINICIE"

#: spvw.d:1001
msgid "Attempt to modify read-only data"
msgstr "intento de modificar datos de sólo lectura"

#: spvw.d:1121 spvw.d:2067
msgid "Cannot open /dev/zero ."
msgstr "No se puede abrir /dev/zero."

# "msync(0x%x,0x%x,MS_INVALIDATE) fracasó." - lsg
#
# O "falló" en vez de "fracasó". ¿Qué te parece? - cll
#
#: spvw.d:1151
msgid "msync(0x%x,0x%x,MS_INVALIDATE) fails."
msgstr "msync(0x%x,0x%x,MS_INVALIDATE) falló."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw.d:1182 spvw.d:1785 spvw.d:1929 spvw.d:2095
msgid "Cannot map memory to address 0x%x ."
msgstr "No se puede asignar la memoria a la dirección 0x%x ."

#: spvw.d:1216
msgid "Cannot open %s ."
msgstr "No se puede abrir %s."

#: spvw.d:1230
msgid "Cannot delete %s ."
msgstr "No se puede borrar %s ."

# He seguido la propuesta de Santiago Vila. A partir de ahora, y siempre
# que sea posible, el término "warning" se traducirá por "atención". En
# aquellos casos en que esto no es posible, lo he indicado
# explícitamente con un comentario indicando el motivo. - cll
#
#: spvw.d:1247
msgid "** WARNING: ** Too few free disk space for %s .\n"
msgstr "** ATENCIÓN: ** Hay muy poco espacio libre en disco para %s .\n"

#: spvw.d:1253
msgid "Please restart LISP with fewer memory (option -m).\n"
msgstr "Por favor, vuelva a ejecutar LISP con menos memoria (opción -m).\n"

#: spvw.d:1262
msgid "Cannot make %s long enough."
msgstr "No es posible agrandar %s lo suficiente."

#: spvw.d:1282
msgid "Cannot fill %s ."
msgstr "No se puede rellenar %s ."

#: spvw.d:1301
msgid "Cannot close %s ."
msgstr "No se puede cerrar %s ."

#
# Muy buena tu sugerencia, Leo. Se queda tal y como tu propones - lsg
#
# ¿Apoyo o soporte? sv
#
# Bueno, si, tienes razón. De hecho ésta era una de esas traducciones
# "raras". El problema es que no estaba seguro de que el término
# "soporte" fuese aceptado. Pero si es así, pues perfecto - cll
#
#: spvw.d:1451
msgid "Recompile your operating system with SYSV IPC support.\n"
msgstr "Recompile su sistema operativo con soporte para SYSV IPC.\n"

#
# "no se puede asignar un segmento privado en la memoria compartida" - lsg
#
#: spvw.d:1467
msgid "Cannot allocate private shared memory segment."
msgstr "No se puede asignar un segmento privado en la memoria compartida."

#: spvw.d:1492
msgid "Cannot map shared memory to address 0x%x."
msgstr "No se puede asignar la memoria compartida a la direccion 0x%x."

#: spvw.d:1517
msgid "Cannot fill shared memory."
msgstr "No se puede rellenar la memoria compartida."

#: spvw.d:1527
msgid "Could not fill shared memory."
msgstr "No se pudo rellenar la memoria compartida."

#
# En este y en otros tantos mensajes, he seguido tu consejo, Leo. He
# traducido `remove' por `desechar' en todos los sitios. - cll
#
#: spvw.d:1545
msgid "Cannot remove shared memory segment."
msgstr "No se puede desechar el segmento de memoria compartida."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw.d:1893
msgid "Cannot reserve address range at 0x%x ."
msgstr "No se puede reservar el rango de direcciones a 0x%x ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw.d:1907
msgid "Cannot reserve address range 0x%x-0x%x ."
msgstr "No se puede reservar el rango de direcciones 0x%x-0x%x ."

#: spvw.d:1967
msgid "CreateFileMapping() failed."
msgstr "CreateFileMapping() falló."

#: spvw.d:1978
msgid "MapViewOfFileEx(addr=0x%x,off=0x%x) failed."
msgstr "MapViewOfFileEx(dirección=0x%x,segmento=0x%x) falló."

#: spvw.d:1988
msgid "MapViewOfFileEx() returned 0x%x instead of 0x%x.\n"
msgstr "MapViewOfFileEx() devolvió 0x%x en vez de 0x%x.\n"

#: spvw.d:2008
msgid "VirtualFree() failed."
msgstr "VirtualFree() falló."

#: spvw.d:2028
msgid "VirtualProtect() failed."
msgstr "VirtualProtect() falló."

# "*** - desbordamiento de la pila del programa - REINICIALIZANDO" - lsg
#
# En mi opinión, RESET debe traducirse como un imperativo - cll
#
#: spvw.d:2544
msgid ""
"\n"
"*** - Program stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila del programa. REINICIE"

# ¡ Toma puntilloso que soy! Lisp debería escribirse con mayúscula.
# "*** - desbordamiento de la pila de Lisp - REINICIALIZANDO" - lsg
#
# No, no, nada de REINICIALIZANDO. Debe ser un imperativo: REINICIE.
# Por ejemplo, si durante una sesión con CLisp haces:
#
# > (defun foo (a) (foo (1- a)))
# FOO
# > (foo 2)
#
# *** - Desbordamiento de la pila de Lisp. REINICIE
# >
#
# ..., pero el intérprete se queda esperando a que tú sigas tecleando,
# es decir, él solo no se pone a reiniciar nada, ...
#
# Por otra parte, tienes toda la razón, Lisp debe ir con mayúsculas :) - cll
#
#: spvw.d:2553
msgid ""
"\n"
"*** - Lisp stack overflow. RESET"
msgstr ""
"\n"
"*** - Desbordamiento de la pila de Lisp. REINICIE"

#: spvw.d:3464
msgid "mprotect() fails."
msgstr "mprotect() falló."

#: spvw.d:6904
msgid "munmap() fails."
msgstr "munmap() falló."

#: spvw.d:7453
msgid "No more room for LISP objects"
msgstr "No queda espacio para almacenar más objetos LISP"

#
# "*** - no queda espacio para almacenar objetos LISP - REINICIALIZANDO" - lsg
#
# Yo sigo en mis trece, ... Debe ser un imperativo: REINICIE - cll
#
#: spvw.d:7476
msgid ""
"\n"
"*** - No more room for LISP objects: RESET"
msgstr ""
"\n"
"*** - No queda espacio para almacenar más objetos LISP: REINICIE"

#: spvw.d:7683 spvw.d:7746 spvw.d:7825
msgid "Trying to make room through a GC...\n"
msgstr ""

#
# Muy bueno el apunte sobre ese acento en "cómo". Gracias, Santiago - cll
#
#: spvw.d:9835
msgid ""
"internal error: statement in file ~, line ~ has been reached!!\n"
"Please send the authors of the program a description how you produced this error!"
msgstr ""
"error interno: ¡¡en la sentencia del fichero ~, línea ~!!\n"
"¡Por favor, envíe a los autores del programa una descripción de cómo\n"
"se produjo este error!"

#: spvw.d:10442 spvw.d:10893
msgid "Ctrl-C: User break"
msgstr "Ctrl-C: Interrupción del usuario"

# "SIGSEGV no puede ser subsanado. Dirección del error =3D 0x%x.\n" - lsg
#
# Si, me gusta más tu traducción. Yo había puesto:
#
# "No se puede evitar SIGSEGV. Dirección de fallo = 0x%x.\n"
#
# Pero el caso es que un SIGSEGV no tiene porque evitarse puesto que es
# una señal que, para cuando sale este mensaje, ya se ha recibido. El
# problema ---realmente--- es que no fue posible "subsanar" la
# señal. Muy bien - cll
#
# De todas formas, prefiero ponerlo al revés ("No se puede subsanar" en
# vez de "... no puede ser subsanado"). Por otra parte, en vez de
# "error" prefiero "fallo" puesto que eso es exactamente de lo que se
# trata. No de un error por algo que alguien hizo mal, sino de un fallo
# del sistema, ... - cll
#
#: spvw.d:10572
msgid ""
"\n"
"SIGSEGV cannot be cured. Fault address = 0x%x.\n"
msgstr ""
"\n"
"No se puede subsanar SIGSEGV. Dirección de fallo = 0x%x.\n"

#: spvw.d:10799
msgid "Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!\n"
msgstr "Escenario Apollo 13: Falló la manipulación del desbordamiento de pila. ¡¡¡ Nos estrellaremos en el siguiente desbordamiento de pila !!!\n"

#
# Por qué traduces signature asi?
# "Signatura desconocida de una FSUBR\n" - lsg
#
# Bueno, pues porque la traducción francesa dice:
#
# "Type d'argument inconnu pour FSUBR"
#
# Y mientras no sepa qué leches es eso del FSUBR (o SUBR, ver mensaje
# siguiente), pues para no pillarme los dedos lo dejaré tal y como lo
# puso Joerg Hoehle - cll
#
#: spvw.d:10939
msgid "Unknown signature of an FSUBR\n"
msgstr "Tipo de argumento desconocido para FSUBR\n"

# ¿¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:11050
msgid "Unknown signature of a SUBR\n"
msgstr "Tipo de argumento desconocido para SUBR\n"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:11639
msgid "module `%s' requires package %s.\n"
msgstr "el módulo `%s' necesita el paquete %s.\n"

#: spvw.d:11716
msgid "This version of CLISP runs only in low address memory.\n"
msgstr "Esta versión de CLISP sólo se ejecuta en las direcciones inferiores de memoria.\n"

#: spvw.d:11965
msgid "Syntax for %s: nnnnnnn or nnnnKB or nMB\n"
msgstr "Sintaxis de %s: nnnnnnn or nnnnKB or nMB\n"

#
# "%s fuera de intervalo\n"
# No me gusta del todo. A lo mejor:
# "%s fuera de limites\n" - lsg
#
# Al final me he decidido por:
#
# "%s se ha salido del rango\n"
#
# ¿No te mola más? - cll
#
#: spvw.d:11972
msgid "%s out of range\n"
msgstr "%s se ha salido del rango\n"

#: spvw.d:11987
msgid "memory size"
msgstr "tamaño de memoria"

#: spvw.d:12000
msgid "stack size"
msgstr "tamaño de la pila"

#: spvw.d:12329
msgid "Return value of malloc() = %x is not compatible with type code distribution.\n"
msgstr "El valor devuelto por malloc() = %x no es compatible con la distribución del código de tipo.\n"

# solo es con acento.
# "sólo %d bytes disponibles\n" - lsg
#
# ¡¡Madre mía!! Tienes toda la razón del mundo - cll :)
#
#: spvw.d:12339
msgid "Only %d bytes available.\n"
msgstr "Sólo quedan %d bytes disponibles.\n"

#: spvw.d:12406
msgid "Cannot close /dev/zero ."
msgstr "No se puede cerrar /dev/zero ."

#: spvw.d:12624
msgid "Couldn't determine the end of the SP stack!\n"
msgstr ""

# Antes de entrar en el debate sobre la traducción de port:
# ¿Es tan fundamentalmente distinto version y port en este contexto como
# para que no se pueda utilizar también versión para "port"? sv
#
# ¡¡Madre mía!! Eso de "antes de entrar" me ha dado muchísimo miedo,
# ... :) Asi que no se hable más, pongo "versión" :) No, ahora fuera
# cachondeo, en el contexto de estos mensajes la expresión "versión" es
# perfecta, ... - cll
#
#: spvw.d:12890
msgid "                    Amiga version: Jörg Höhle                     \n"
msgstr "                    Versión para Amiga: Jörg Höhle\n"

#: spvw.d:12900
msgid "                    RISCOS port: Peter Burwood, Bruno Haible      \n"
msgstr "                    Versión para RISCOS: Peter Burwood, Bruno Haible\n"

#: spvw.d:12910
msgid "                    DOS port: Jürgen Weber, Bruno Haible          \n"
msgstr "                    Versión para DOS: Jürgen Weber, Bruno Haible\n"

# "AVISO: No se ha especificado un fichero de inicializacion.\n" - lsg
#
# El mensaje inglés está en pretérito (specified) por eso yo he
# preferido poner "especificó" en vez de "ha especificado" - cll
#
# Pero Carlos, se ha especificado, es también pretérito,
# pretérito perfecto (compuesto), pero pretérito a fin de cuentas.
# No se ha especificado está más en la línea los demás
# mensajes de los otros ficheros .po. sv
#
# Vale, vale, ... La verdad es que a mí las dos me suenan igual de bien,
# de modo que, a tenor de la voluntad popular (dos votos contra uno),
# pues se pone como propuso Leo - cll
#
# Otra nota de interés es la siguiente: he cambiado "aviso" por
# "atención". Creo que así suena mejor. Sugerencia de Santiago - cll
#
#: spvw.d:12937
msgid ""
"\n"
"WARNING: No initialisation file specified.\n"
msgstr ""
"\n"
"ATENCIÓN: No se ha especificado ningún fichero de inicialización.\n"

#: spvw.d:12943
msgid "Please try: "
msgstr "Por favor, intente:"

#: spvw.d:13096
msgid "Not enough memory for Lisp.\n"
msgstr "No hay memoria suficiente para Lisp.\n"

#: spvw.d:13370
msgid "disk full"
msgstr "el disco está lleno"

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#: spvw.d:13874
msgid "operating system error during load of initialisation file `%s'\n"
msgstr "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"

#: spvw.d:14322
msgid "Cannot map the initialisation file into memory."
msgstr "No puedo escribir el fichero de inicialización en memoria."

#: spvw.d:14586
msgid "operating system error during load of initialisation file\n"
msgstr "error del sistema operativo durante la carga del fichero de inicialización\n"

#: spvw.d:14597
msgid "initialisation file was not created by this version of LISP\n"
msgstr "el fichero de inicialización no fue creado con esta versión de LISP\n"

#: spvw.d:14606
msgid "not enough memory for initialisation\n"
msgstr "no hay memoria suficiente para la inicialización\n"

# "~: ~ es una constante, no se puede asignar dinámicamente" - lsg
#
# ¡Bingo! - cll
#
#: eval.d:591
msgid "~: ~ is a constant, cannot be bound dynamically"
msgstr "~: ~ es una constante, no se puede asignar dinámicamente"

#: control.d:2333 eval.d:1510
msgid "Too many documentation strings in ~"
msgstr "Demasiadas cadenas de documentación en ~"

# Quito el guión, ya que en el mensaje siguiente lo tienes sin él. sv
# Otra posibilidad es: falta la lista lambda para ~. sv
#
# Es que de hecho, debe ir sin guión, ... evidentemente. cll
#
# Por otra parte, mejor pensado, me gusta la alternativa que das - cll
#
#: eval.d:1707
msgid "FUNCTION: lambda-list for ~ is missing"
msgstr "FUNCTION: falta la lista lambda de ~"

#
# "FUNCTION: la lista lambda de ~ debe ser una lista, no un(a) ~" - lsg
#
# Lo de "un(a)" no me mola, aunque sin esa palabra el mensaje queda más
# "telegráfico", me parece más apropiado para tratarse del "diálogo con
# un ordenador" :) - cll
#
#: eval.d:1719
msgid "FUNCTION: lambda-list for ~ should be a list, not ~"
msgstr "FUNCTION: la lista lambda de ~ debe ser una lista, no ~"

#: eval.d:1829
msgid "FUNCTION: illegal declaration ~"
msgstr "FUNCTION: declaración inválida ~"

# Duda: Nótese cómo la traducción dice `declararse SPECIAL'. Esto es
# así, porque en Common Lisp existe SPECIAL para declarar variables
# especiales. Por eso, si digo `declararse SPECIAL' estoy diciendo
# `declararse especial con SPECIAL', pero esto último me parece muy
# rebuscado, ¿o es lo correcto?
#
# La traducción es perfectamente fiel. Déjala así. sv
#
# Además, he quitado el "por ello". cll
#: eval.d:1843
msgid "FUNCTION: ~ is not a symbol, cannot be declared SPECIAL"
msgstr "FUNCTION: ~ no es un símbolo, no puede declararse SPECIAL"

#: eval.d:1921
msgid "FUNCTION: too long variable specification after &OPTIONAL: ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &OPTIONAL: ~"

#
# Creo que en espanol es mas correcto esto:
# "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX
# o del final de lista: ~" - lsg
#
# Pues si, a mi también me parece mucho más correcto - cll
#
#: eval.d:1960
msgid "FUNCTION: &REST var must be followed by &KEY or &AUX or end of list: ~"
msgstr "FUNCTION: la variable &REST debe ir seguida de &KEY o de &AUX o del final de lista: ~"

#
# Igualmente: "FUNCTION: &REST debe ir seguido de una variable: ~" - lsg
#
# Pues si, es que cuando uno está mucho tiempo traduciendo del inglés,
# llega un momento en que empieza coger los hábitos de ese lenguaje y
# empieza a expresarse de una manera extraña, ... - cll
#
#: eval.d:1969
msgid "FUNCTION: &REST must be followed by a variable: ~"
msgstr "FUNCTION: &REST debe ir seguido de una variable: ~"

#: eval.d:2021
msgid "FUNCTION: ~ in ~ is not a keyword"
msgstr "FUNCTION: ~ en ~ no es una palabra clave"

#: eval.d:2072
msgid "FUNCTION: incorrect variable specification after &KEY: ~"
msgstr "FUNCTION: especificación de variable incorrecta después de &KEY: ~"

#
# Y de nuevo "FUNCTION: &ALLOW-OTHER-KEYS debe ir seguido de &AUX o del
# final de lista: ~" - lsg
#
# Pues si, :) - cll
#
#: eval.d:2082
msgid "FUNCTION: &ALLOW-OTHER-KEYS must be followed by &AUX or end of list: ~"
msgstr "FUNCTION: &ALLOW-OTHER-KEYS debe ir seguido por &AUX o el fin de lista: ~"

#: eval.d:2118
msgid "FUNCTION: too long variable specification after &AUX: ~"
msgstr "FUNCTION: especificacion de variable demasiado larga despues de &AUX: ~"

#: eval.d:2142
msgid "FUNCTION: badly placed lambda-list keyword ~: ~"
msgstr "La palabra clave ~ de la lista lambda está mal situada: ~"

# Sugerencia: may not -> no puede. sv
# Sugerencia: comerse el "y por ello". sv
#: eval.d:2150
msgid "FUNCTION: ~ is not a symbol, may not be used as a variable"
msgstr "FUNCTION: ~ no es un símbolo, no puede usarse como una variable"

# me comería el "y por ello", todo el mundo lo entenderá, y además no
# está en el original. sv
#
# No sólo eso, sino que además el mensaje queda demasiado largo. Será
# mucho más cómodo, para quien esté trabajando, ver mensajes cortos,
# ... sugerencia aceptada. cll
#
#: eval.d:2158
msgid "FUNCTION: ~ is a constant, may not be used as a variable"
msgstr "FUNCTION: ~ es una constante, no puede usarse como una variable"

#: eval.d:2168
msgid "FUNCTION: too many parameters in the lambda-list ~"
msgstr "FUNCTION: demasiados parámetros en la lista lambda ~"

#: eval.d:2178
msgid "FUNCTION: a dot in a lambda-list is allowed only for macros, not here: ~"
msgstr "FUNCTION: sólo en las macros se permite utilizar un punto en la lista lambda, no aquí: ~"

#: eval.d:2271
msgid "~: ~ is not a function"
msgstr "~: ~ no es una función"

#: eval.d:2336
msgid "EVAL/APPLY: keyword arguments for ~ should occur pairwise"
msgstr "EVAL/APPLY: los argumentos clave de ~ deben aparecer por pares"

#
# 'Se han pasado demasiados argumentos a ~" - lsg
#
# Bueno, tu traducción es absolutamente válido. Tal vez, algo más
# informal que la mía, por aquello de "pasado" en vez de
# "entregado". Bueno, pues si te parece, esta vez lo dejo como lo tenía
# yo - cll
#
#: eval.d:2351 eval.d:2662
msgid "EVAL/APPLY: too many arguments given to ~"
msgstr "EVAL/APPLY: se han entregado demasiados argumentos a ~"

#: eval.d:2368
msgid "EVAL/APPLY: ~ is not a keyword"
msgstr "EVAL/APPLY: ~ no es una palabra clave"

#: eval.d:2395
msgid "EVAL/APPLY: keyword ~ is illegal for ~. The possible keywords are ~"
msgstr "EVAL/APPLY: el argumento clave ~ es inválido en ~. Los posibles argumentos clave son ~"

#
# "EVAL/APPLY: no se han pasado suficientes argumentos a ~" - lsg
#
# Hmmm, ... Si me gusta, es más "explicativo". Si, me gusta, si, si
# Lo único que te trastoco es lo de "pasado" por "entregado". Ya sabes,
# un toque de distinción :) - cll
#
#: eval.d:2583
msgid "EVAL/APPLY: too few arguments given to ~"
msgstr "EVAL/APPLY: no se han entregado suficientes argumentos a ~"

#
# "EVAL: la variable ~ no tiene asignado ningún valor" - lsg
#
# Bueno, he quitado lo de "asignado" porque parece de "perogrullo", pero
# lo demás se queda - cll
#
#: eval.d:3060
msgid "EVAL: variable ~ has no value"
msgstr "EVAL: la variable ~ no tiene ningún valor"

#: eval.d:3093
msgid "EVAL: illegal form ~"
msgstr "EVAL: forma ~ inválida"

#: eval.d:3162
msgid "EVAL: undefined function ~"
msgstr "EVAL: la función ~ no está definida"

#: eval.d:3176
msgid "EVAL: ~ is not a function name"
msgstr "EVAL: ~ no es el nombre de una función"

# "EVAL: no se han pasado suficientes argumentos a la forma especial ~:~" - lsg
#
# Bueno, pues te digo lo mismo que en el mensaje eval.d:2572, ... - cll
#
#: eval.d:3255
msgid "EVAL: too few parameters for special-form ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a la forma especial ~: ~"

#
# "Se han pasado demasiados parámetros a la forma especial ~: ~" - lsg
#
# O sea, que quite lo de "para" y ponga "a". Pues vale, tienes toda la
# razón del mundo - cll
#
#: eval.d:3269
msgid "EVAL: too many parameters for special-form ~: ~"
msgstr "EVAL: se han entregado demasiados parámetros a la forma especial ~: ~"

#: eval.d:3282
msgid "EVAL: dotted parameter list for special form ~: ~"
msgstr "EVAL: la lista de parámetros para la forma especial ~ está punteada: ~"

#
# "EVAL: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Una vez más, te digo lo mismo que en el mensaje eval.d:2572 - cll
#
#: eval.d:3350
msgid "EVAL: too few arguments given to ~: ~"
msgstr "EVAL: no se han entregado suficientes argumentos a ~: ~"

#
# "Se han pasado demasiados argumentos a ~: ~" - lsg
#
# Me gusta más "entregado" que "pasado" - cll
#
#: eval.d:3365
msgid "EVAL: too many arguments given to ~: ~"
msgstr "EVAL: se han entregado demasiados argumentos a ~: ~"

#
# "EVAL: la lista de argumentos pasada a ~ es punteada: ~" - lsg
#
# Me gusta más "entregada" que "pasada" - cll
#
#: eval.d:3380
msgid "EVAL: argument list given to ~ is dotted: ~"
msgstr "EVAL: la lista de argumentos entregada a ~ está punteada: ~"

#: eval.d:4136
msgid "APPLY: ~ is a special form, not a function"
msgstr "APPLY: ~ es una forma especial, no una función"

#: eval.d:4145
msgid "APPLY: ~ is a macro, not a function"
msgstr "APPLY: ~ es una macro, no una función"

#: eval.d:4158
msgid "APPLY: the function ~ is undefined"
msgstr "APPLY: la función ~ no está definida"

#: eval.d:4213
msgid "APPLY: ~ is not a function name"
msgstr "APPLY: ~ no es el nombre de una función"

#: eval.d:4228
msgid "APPLY: argument list given to ~ is dotted"
msgstr "APPLY: la lista de argumentos entregada a ~ está punteada"

#
# "Se han pasado demasiados argumentos a ~" - lsg
#
# Una vez más, me gusta más "entregar" que "pasar" - cll
#
#: eval.d:4242
msgid "APPLY: too many arguments given to ~"
msgstr "APPLY: se han entregado demasiados argumentos a ~"

#
# "APPLY: no se han pasado suficientes argumentos a ~:~" - lsg
#
# Pues eso, que me gusta más "entregar" - cll
#
#: eval.d:4256
msgid "APPLY: too few arguments given to ~"
msgstr "APPLY: se han entregado pocos argumentos a ~"

#: eval.d:5069
msgid "FUNCALL: ~ is a special form, not a function"
msgstr "FUNCALL: ~ es una forma especial, no una función"

#: eval.d:5078
msgid "FUNCALL: ~ is a macro, not a function"
msgstr "FUNCALL: ~ es una macro, no una función"

#: eval.d:5091
msgid "FUNCALL: the function ~ is undefined"
msgstr "FUNCALL: la función ~ no está definida"

#: eval.d:5144
msgid "FUNCALL: ~ is not a function name"
msgstr "FUNCALL: ~ no es el nombre de una función"

#
# "el símbolo ~ no tiene valor asignado" - lsg
#
# En algún otro sitio ha aparecido algo parecido a esto. Verás, como me
# parece evidente que si un símbolo no tiene valor, es que no tiene
# valor asignado, pues prefiero omitir lo de "asignado" y evitar que el
# usuario lea términos innecesarios - cll
#
#: eval.d:6659 eval.d:6677
msgid "symbol ~ has no value"
msgstr "el símbolo ~ no tiene valor"

#: eval.d:6694
msgid "assignment to constant symbol ~ is impossible"
msgstr "no pueden realizarse asignaciones sobre el símbolo constante ~"

#
# "~: se ha invocado ~ con demasiados argumentos" - lsg
#
# ¡¡¡ Traducción brillantísima !!! Te ha quedado perfecto. Lo que yo había puesto:
#
# "~: se han entregado demasiados argumentos a ~"
#
# queda como más "indio". Tu traducción me encanta - cll
#
#: control.d:2237 eval.d:7287
msgid "~: too many arguments given to ~"
msgstr "~: se ha invocado ~ con demasiados argumentos"

# Duda: tagbody es de muy difícil traducción.
#       Echando un ojo a la traducción en francés me he encontrado con que está
#       tal cual, ... De momento se queda así hasta que otros miembros del
#       equipo decidan cualquier otra cosa, ...
#
# No es que sepa lo que es, pero, si tag es etiqueta, tagbody podría ser
# "el cuerpo de la etiqueta" (¿tiene sentido esto?), con lo cual, una
# posibilidad sería (para simplificar) "el cuerpo de las etiquetas..." sv
#
# Otra de las propuestas a esta cuestión en la lista de correo
# es@li.org, ha sido: "el contenido de las etiquetas ~ ya ha sido
# abandonado". Esta traducción me gusta, ... cll
#
# ( Desafortunadamente, no recuerdo el nombre de la persona que lo
# sugirió, ... cll )
#
# "(~ ~): ya se ha salido del cuerpo de etiquetas ~" - lsg
#
# Debo rendirme a la evidencia, ... La propuesta de Leo, no solo para
# este término sino todos cuanto se refieren a la traducción de `tag' y
# `tagbody' es perfecta y, además, sigue los pasos de la de Santiago, de
# modo que "moción aceptada" :)
#
#: eval.d:7456 eval.d:7495
msgid "(~ ~): the tagbody of the tags ~ has already been left"
msgstr "(~ ~): ya se ha salido del cuerpo de etiquetas ~"

#: control.d:1945 eval.d:7557
msgid "~: there is no CATCHer for tag ~"
msgstr "~: No hay ningún capturador (CATCH) para la etiqueta de salto ~"

#: eval.d:7582
msgid "STACK corrupted"
msgstr "Pila (STACK) corrupta"

#: eval.d:7866
msgid "~: the function ~ is undefined"
msgstr "~: la función ~ no está definida"

#: eval.d:7910
msgid "~: ~ is not a correct index into ~"
msgstr "~: ~ no es un índice correcto en ~"

#: eval.d:8510
msgid "undefined bytecode in ~ at byte ~"
msgstr "Código de octeto ~ indefinido en el octeto ~"

#: eval.d:8523
msgid "too many return values"
msgstr "Demasiados valores devueltos"

#: eval.d:8533
msgid "Corrupted STACK in ~ at byte ~"
msgstr "Pila corrupta en ~ en el byte ~"

#: control.d:58
msgid "~: function name ~ should be a symbol"
msgstr "~: el nombre de la función ~ debe ser un símbolo"

#: control.d:85
msgid "~: undefined function ~"
msgstr "~: la función ~ no está definida"

#: control.d:105
msgid "~: ~ is not a function name"
msgstr "~: ~ no es el nombre de una función"

#: control.d:127
msgid "~: ~ has no dynamic value"
msgstr "~: ~ no tiene ningún valor dinámico"

#
# "~: ~ no tiene una definición global de función " - lsg
#
# Atención, atención ¿qué es global, la definición o la función?
#
# Yo he traducido:
#
# "~: ~ no tiene ninguna definición global de función"
#
# y la traducción francesa dice:
#
# "~ : ~ n'a pas de définition globale de fonction." - cll
#
#: control.d:168 symbol.d:22
msgid "~: ~ has no global function definition"
msgstr "~: ~ no tiene ninguna definición global de función"

#: control.d:243
msgid "~: the value of the constant ~ may not be altered"
msgstr "~: no puede alterarse el valor de la constante ~"

#: control.d:271
msgid "~ called with odd number of arguments: ~"
msgstr "~ invocado con un número impar de argumentos: ~"

#: control.d:284
msgid "dotted list given to ~ : ~"
msgstr "lista punteada entregada a ~: ~"

#: control.d:377
msgid "~: the value of the constant ~ must not be removed"
msgstr "~: no se debe desechar el valor de la constante ~"

#: control.d:402
msgid "~: the special form definition of ~ must not be removed"
msgstr "~: no se debe desechar la definición de la forma especial de ~"

#: control.d:475
msgid "~: doc-strings are not allowed here: ~"
msgstr "~: aquí no se permiten cadenas de documentación: ~"

#: control.d:545
msgid "~: ~ is not a symbol, but was declared SPECIAL"
msgstr "~: ~ no es un símbolo, pero ha sido declarado SPECIAL"

#: control.d:587 control.d:828
msgid "~: illegal variable specification ~"
msgstr "~: especificación inválida de variable ~"

#: control.d:629
msgid "~: symbol ~ must not be declared SPECIAL and a macro at the same time"
msgstr "~: el símbolo ~ no debe declararse SPECIAL, al mismo tiempo que es el de una macro"

#: control.d:646
msgid "~: too many variables and/or declarations"
msgstr "~: demasiadas variables y/o declaraciones"

#: control.d:844
msgid "~: ~ is a constant, cannot be bound"
msgstr "~: ~ es una constante, y por ello no puede ligarse"

#: control.d:913
msgid "~: ~ is not a function specification"
msgstr "~: ~ no es la especificación de una función"

#: control.d:1058
msgid "~: ~ is not a macro specification"
msgstr "~: ~ no es la especificación de una macro"

#: control.d:1069
msgid "~: macro name ~ should be a symbol"
msgstr "~: el nombre de la macro ~ debe ser un símbolo"

#: control.d:1175
msgid "~: clause ~ should be a list"
msgstr "~: la clausula ~ debe ser una lista"

#: control.d:1209
#, fuzzy
msgid "~: missing key list: ~"
msgstr "~S: falta la lista de claves"

#: control.d:1221
#, fuzzy
msgid "~: the ~ clause must be the last one"
msgstr "~S: la clausula ~S debe ser la última"

#: control.d:1281
msgid "~: the block named ~ has already been left"
msgstr "~: el bloque de nombre ~ ya ha sido abandonado"

#: control.d:1319
msgid "~: no block named ~ is currently visible"
msgstr "~: no hay ningún bloque visible con el nombre ~"

#: control.d:1568
msgid "~: ~ is neither tag nor form"
msgstr "~: ~ no es ni una etiqueta de salto ni una forma"

#: control.d:1613
msgid "~: illegal tag ~"
msgstr "~: etiqueta de salto inválida ~"

#: control.d:1655
msgid "~: tagbody for tag ~ has already been left"
msgstr "~: ya se ha salido del cuerpo de etiquetas de ~"

#: control.d:1673
msgid "~: no tag named ~ is currently visible"
msgstr "~: no hay ninguna etiqueta de salto visible con el nombre ~"

#: control.d:1694
msgid "~: too many values"
msgstr "~: demasiados valores"

#: control.d:1736
msgid "~: too many arguments to ~"
msgstr "~: se han entregado demasiados argumentos a ~"

#: control.d:1984
msgid "Argument ~ is not a macroexpansion environment"
msgstr "El argumento ~ no es un entorno para la expansión de macros"

#: control.d:2037
msgid "declarations ~ are not allowed here"
msgstr "las declaraciones ~ no están permitidas aquí"

#: control.d:2061
msgid "~: ~ evaluated to the values ~, not of type ~"
msgstr "~: La forma ~ ha producido los valores ~, ninguno de los cuales es del tipo ~"

#: control.d:2079
msgid "~: bad declaration ~"
msgstr "~: declaración incorrecta ~"

#: control.d:2185
msgid "~: ~ may not be used as an environment"
msgstr "~: ~ no puede usarse como un entorno"

#: control.d:2323
msgid "no doc-strings allowed here: ~"
msgstr "no se permite la utilización de cadenas de documentación aquí: ~"

#: control.d:2394
msgid "keyword argument list ~ has an odd length"
msgstr "la lista de argumentos clave ~ tiene longitud impar"

#: control.d:2420
msgid "illegal keyword/value pair ~, ~ in argument list. The allowed keywords are ~"
msgstr "par argumento clave/valor inválido ~, ~ en la lista de argumentos. Los parámetros clave permitidos son ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#
#: pathname.d:779 pathname.d:829
msgid "~: host should be NIL or a string, not ~"
msgstr "~: el anfitrión debe ser, o bien NIL, o una cadena, pero no ~"

#
# Duda: he traducido hostname por "nombre del `host'". ¿Qué os parece?
#
#: pathname.d:799 pathname.d:848
msgid "~: illegal hostname ~"
msgstr "~: nombre de anfitrión inválido ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:873
msgid "~: host should be NIL, not ~"
msgstr "~: el anfitrión debe ser NIL, no ~"

#: pathname.d:984
msgid "~: argument should be a string, symbol, file stream or pathname, not ~"
msgstr "~: el argumento debe ser o bien una cadena, o un símbolo, o un flujo de fichero o un PATHNAME pero no ~"

#: pathname.d:1025
#, fuzzy
msgid "~: filename for ~ is unknown"
msgstr "~: No se conoce ninguna regla de sustitución para ~."

#: pathname.d:1543 pathname.d:1893
msgid "~: there is no environment variable ~"
msgstr "~: no hay ninguna variable de entorno ~"

#: pathname.d:1833
msgid "~: there is no user named ~"
msgstr "~: no hay ningún usuario con el nombre ~"

#: pathname.d:2222
msgid "~: syntax error in filename ~ at position ~"
msgstr "~: error de sintáxis en el nombre del fichero ~, en la posición ~"

#
# Duda: dejo `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: pathname.d:2238
msgid "~: hosts ~ and ~ of ~ should coincide"
msgstr "~: los anfitriones ~ y ~ de ~ deben coincidir"

#: pathname.d:2466
msgid "~: argument ~ is not a logical pathname, string, stream or symbol"
msgstr "~: el argumento ~ no es un PATHNAME \"lógica\", una cadena de caracteres, un flujo o un símbolo"

#: pathname.d:2524
msgid "~: endless loop while resolving ~"
msgstr "~: bucle infinito para ~"

#: pathname.d:2549
msgid "~: unknown logical host ~ in ~"
msgstr "~: anfitrión ~ desconocido en ~"

#: pathname.d:2564
msgid "~: No replacement rule for ~ is known."
msgstr "~: No se conoce ninguna regla de sustitución para ~."

#: pathname.d:2938
msgid "~: :VERSION-argument should be NIL or a positive fixnum or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser NIL, un número positivo del tipo fixnum, :WILD o :NEWEST pero no ~"

#: pathname.d:2967
msgid "~: :VERSION-argument should be NIL or :WILD or :NEWEST, not ~"
msgstr "~: el argumento :VERSION debe ser o bien NIL, o :WILD o :NEWEST, pero no ~"

#: pathname.d:3980
msgid "~: illegal ~ argument ~"
msgstr "~: el argumento de ~ es inválido: ~"

# Duda: Wildcard por comodín, ..., está bien, ¿no?
#
#: pathname.d:4289
msgid "wildcards are not allowed here: ~"
msgstr "Aquí no están permitidos los comodines: ~"

#: pathname.d:4321
msgid "~: argument ~ should be ~, ~, ~, ~, ~, ~ or ~"
msgstr "~: el argumento ~ debe ser ~, ~, ~, ~, ~, ~ o ~"

#: pathname.d:5330
msgid "~: replacement pieces ~ do not fit into ~"
msgstr "~: las piezas de intercambio ~ no caben en ~"

#: pathname.d:5399
msgid "~: ~ is not a specialization of ~"
msgstr "~: ~ no es una especialización de ~"

#: pathname.d:5451
msgid "(~ ~ ~ ~) is ambiguous: ~"
msgstr "(~ ~ ~ ~) es ambiguo: ~"

#: pathname.d:5479
msgid "nonexistent directory: ~"
msgstr "directorio inexistente: ~"

#: pathname.d:5497
msgid "~: File ~ already exists"
msgstr "~: El fichero ~ ya existe"

#: pathname.d:5838 pathname.d:6645
msgid "no directory ~ above ~"
msgstr "no existe el directorio ~ bajo ~"

#: pathname.d:5849
msgid "\"..\\\\\" after \"...\\\\\" is invalid: ~"
msgstr "\"..\\\\\" después de \"...\\\\\" es inválido: ~"

#: pathname.d:6036
msgid "Couldn't access current directory"
msgstr "No se pudo acceder al directorio actual"

#: pathname.d:6181
msgid "~: ~ names a file, not a directory"
msgstr "~: ~ es el nombre de un fichero, no de un directorio"

#: pathname.d:6228 pathname.d:6420 pathname.d:6762
msgid "~: ~ names a directory, not a file"
msgstr "~: ~ es el nombre de un directorio, no de un fichero"

# Casi lo mismo. Bueno, al menos aquí hay dos puntos. sv
#
# Tienes razón. Ahora que veo este mensaje me lío a poner dos puntos en
# los mensajes anteriores. cll
#
#: pathname.d:6275
msgid "UNIX error while GETWD: ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Si la tildecilla se sustituye por aquello que devolvió la orden GETWD,
# la frase resultante no tiene mucho sentido.
# Sugerencia: "La ejecución de GETWD en Unix devolvió ~" sv
#
# Hmmm, ..., podría ser, pero verás: en primer lugar, el texto que está
# asociado con la etiqueta "UNIX GETWD returned ~" es "UNIX error while
# GETWD" (fichero pathname.d, línea 6176); segundo, en CLisp se sigue la
# convención de colocar primero un mensaje y después, al final, aquello
# que originó el mensaje y, francamente, no quiero cambiar esta
# convención. Es decir, no quiero faltar al estilo original de los
# autores del programa. cll
#
# Por este motivo, creo que lo más conveniente es dejarlo como está. cll
#
#: pathname.d:6287
msgid "UNIX GETWD returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de GETWD: ~"

# Lo mismo. sv
#
# Lo mismo también ;) cll
#
#: pathname.d:6375
msgid "UNIX REALPATH returned ~"
msgstr "Se produjo un error UNIX durante la ejecución de REALPATH: ~"

#: pathname.d:6575
msgid "~: If a device is specified, the directory must begin with ~: ~"
msgstr "~: Si se especifica un dispositivo, el directorio debe comenzar con ~: ~"

#: pathname.d:6967
msgid "no file name given: ~"
msgstr "no se ha entregado ningún nombre de fichero: ~"

#: pathname.d:6983
msgid "not a directory: ~"
msgstr "no es un directorio: ~"

#: pathname.d:7041
msgid "~: file ~ does not exist"
msgstr "~: el fichero ~ no existe"

#: pathname.d:7073
msgid "~: pathname with type but without name makes no sense: ~"
msgstr "~: un PATHNAME con tipo, pero sin nombre, no tiene ningún sentido: ~"

#: pathname.d:7300
msgid "cannot delete file ~ since there is file stream open to it"
msgstr "no se puede borrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:7366
msgid "cannot rename file ~ since there is file stream open to it"
msgstr "no se puede renombrar el fichero ~ puesto que hay un flujo abierto sobre el"

#: pathname.d:7936
msgid "file ~ does not exist"
msgstr "el fichero ~ no existe"

#: pathname.d:7945
msgid "a file named ~ already exists"
msgstr "ya existe un fichero con el nombre ~"

#: pathname.d:7989
msgid "~: illegal :DIRECTION argument ~"
msgstr "~: argumento :DIRECTION inválido ~"

#: pathname.d:8079
msgid "~: illegal :ELEMENT-TYPE argument ~"
msgstr "~: argumento :ELEMENT-TYPE inválido ~"

#: pathname.d:8109
msgid "~: illegal :IF-EXISTS argument ~"
msgstr "~: argumento :IF-EXISTS inválido ~"

#: pathname.d:8126
msgid "~: illegal :IF-DOES-NOT-EXIST argument ~"
msgstr "~: argumento :IF-DOES-NOT-EXIST inválido ~"

#: pathname.d:9499
msgid "root directory not allowed here: ~"
msgstr "el directorio raíz no está permitido aquí: ~"

# En la lista de "spanglish" pone:
#
# command                 orden, mandato (NO "comando")
#
# Asi que, muchas gracias Santiago por la indicación, ... - cll
#
#: pathname.d:10235 pathname.d:10269 pathname.d:10332
msgid "~: the command should be a string, not ~"
msgstr "~: la orden debe ser una cadena y no ~"

# Duda: En este mensaje, el primer "~" se sustituye por el nombre de una
# función y el segundo "~" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: stream.d:213
msgid "~ on ~ is illegal"
msgstr "~ no es posible sobre el flujo ~"

#: stream.d:378
msgid "~: the last character read from ~ was not ~"
msgstr "~: el último carácter leído de ~ no era ~"

# Duda: A continuación vienen muchos mensajes que empiezan por "~ from
# ~". Para ayudar en su trabajo a quienes estén revisando este trabajo
# (no me canso de darte las gracias, Santiago, ..., y a quienes se
# animen) aclaro que el primer "~" se sustituye por el nombre de una
# función cuya evaluación (o ejecución, pero esto no es correcto en
# Lisp, ... se prefiere el término evaluación porque se está a nivel de
# intérprete) produce el error; el segundo "~" se refiere al nombre del
# flujo desde el cual se leyó dicha función. Luego, a continuación,
# viene el mensaje de error propiamente dicho.
#
# Por ejemplo, la siguiente instrucción en CLisp:
#
# > (read)
#
# ..., si se teclea:
#
# #<...>
#
# ..., produce el siguiente error: (en español, ya traducido)
#
# *** - READ en #<TERMINAL-STREAM>: los objetos escritos de la manera
# #<...> no pueden volverse a leer
#
# ¿De acuerdo?
#
# A continuación reproduzco un par de mails donde se explica el
# mecanismo general de estos mensajes, a propósito de la pregunta que
# puse en la lista de correo de CLisp:
#
# Mi pregunta fue:
#
# > 21. There are a few messages which begin with "~ from ~". They are
# > very easy to translate but they use a lot of prepositions, and words
# > that could be translated in masculine or feminine. So, I need some
# > real examples of their use.
#
# Las respuestas fueron:
#
#
# ---------------------------------------------------------------------------
# Look in io.d:
#     { pushSTACK(*stream_); # Wert fu:r Slot STREAM von STREAM-ERROR
#       pushSTACK(ch); # Character
#       pushSTACK(*stream_); # Stream
#       pushSTACK(S(read));
#       //: DEUTSCH "~ von ~: Gelesenes Zeichen ist kein String-Char: ~"
#       //: ENGLISH "~ from ~: character read should be a string-char: ~"
#       //: FRANCAIS "~ de ~ : le caracte!re lu n'est pas de type STRING-CHAR."
# The first ~ is the function name, the second the stream that was being
# read from or written to and the third is the character that was read/written.
#
# So it says something like "READ from #<STREAM ...>: illegal character"
#
# 						(Joerg Hoehle)
#
# ---------------------------------------------------------------------------
# A general question here: I thought gettext was coming with an Emacs
# mode called "po-mode", which helps you in translating the messages.
# In particular, there are keystroke commands for showing the C/Lisp source
# surrounding the original reference to a message. From this context,
# you should at least be able to guess the meaning of the objects which
# are substituted for the ~. Note, however, that the first ~ corresponds
# the last pushSTACK command before the string, the second ~ to the
# second-to-last pushSTACK command etc.
#
# 						(Bruno Haible)
#
# ---------------------------------------------------------------------------
#
#: stream.d:390
msgid "~ from ~ without ~ before it"
msgstr "~ en ~ sin ~ antes de él"

#: stream.d:537
msgid "~: cannot output to ~"
msgstr "~: no se puede escribir en ~"

#: stream.d:556
msgid "~ is not a character, cannot be output onto ~"
msgstr "~ no es un carácter, no puede escribirse en ~"

#: stream.d:574
msgid "character ~ is not a string-char, cannot be output onto ~"
msgstr "el carácter ~ no es del tipo STRING-CHAR, y por ello no puede escribirse en ~"

#: stream.d:592
msgid "~ is not an integer, cannot be output onto ~"
msgstr "~ no es un entero, no puede escribirse en ~"

#: stream.d:608
msgid "integer ~ is out of range, cannot be output onto ~"
msgstr "el entero ~ está fuera del dominio, no puede imprimirse en ~"

#: stream.d:3043
msgid "character ~ contains bits, cannot be output onto ~"
msgstr "el carácter ~ contiene bits, que no pueden imprimirse en ~"

# Duda: Aunque RAW significa `crudo', y `modo crudo' es una expresión
# muy conocida en español, lo dejo como RAW (y en mayúsuculas), para que
# quede claro que me refiero a la palabra reservada RAW (igual que
# ocurre en la versión original)
#
#: stream.d:3704
msgid "RAW mode not supported on ~"
msgstr "Modo RAW no soportado en ~"

#: stream.d:4081
msgid "~: argument ~ should be a window stream"
msgstr "~: el argumento ~ debe ser un WINDOW-STREAM"

#: stream.d:4888
msgid "cannot output to standard output"
msgstr "no se puede escribir en la salida estándar"

#: stream.d:6142
msgid "environment has no TERM variable"
msgstr "no existe ninguna variable de entorno TERM"

#: stream.d:6151
msgid "terminal type ~ unknown to termcap"
msgstr "No existe ninguna entrada para el tipo de terminal ~ en termcap"

# Duda: Juan Jordana (de la lista de CLisp) propone usar la expresión:
#
# 	Terminal incompleta (o errónea): Terminal de impresora.
#
# 	y me gusta, salvo que prefiero decir a continuación algo del
# 	tipo "usando el modo de impresora" o algo así, ¿no os parece
# 	mejor?
#
#: stream.d:6175
msgid "insufficient terminal: hardcopy terminal"
msgstr "terminal insuficiente: usando el modo de impresora"

# Duda: ¿Pues qué voy a decir? La traducción siguiente es una auténtica
# traducción libre. De todos modos, tanto la versión francesa como la
# alemana (aunque no sé ni alemán ni francés) hacen ---por lo visto---,
# lo que yo: una traducción libre.
#
#: stream.d:6183
msgid "insufficient terminal: overstrikes, cannot clear output"
msgstr "teminal insuficiente: no se puede inicializar la salida"

#: stream.d:6191
msgid "insufficient terminal: cannot scroll"
msgstr "terminal insuficiente: no se puede desplazar la pantalla"

#: stream.d:6200
msgid "insufficient terminal: cannot clear screen"
msgstr "terminal insuficiente: no se puede borrar la pantalla"

#: stream.d:6208
msgid "insufficient terminal: cannot position cursor randomly"
msgstr "terminal insuficiente: no se puede situar el cursor aleatoriamente"

#: stream.d:6666
msgid "~: package SCREEN is not implemented"
msgstr "~: el paquete SCREEN no está implementado"

#: stream.d:7222
msgid "Closed ~ because disk is full."
msgstr "Se ha cerrado ~ porque el disco está lleno."

#: stream.d:7401
msgid "cannot position ~ beyond EOF"
msgstr "no es posible colocarse en ~ más allá de EOF"

# Duda: lo del fichero `regular' por `normal'. De hecho, yo juraría que
# en la asignatura de Sistemas Operativos, en mi Facultad, los
# llamábamos "ficheros normales". ¿Qué tal os suena?.
#
#: stream.d:8706
msgid "~: ~ is not a regular file."
msgstr "~: ~ no es un fichero normal."

# Duda: aqui he traducido de la version francesa (no se frances, pero
# por lo que parece que pone, ...)
#
#: stream.d:8880
msgid "file ~ is not an integer file"
msgstr "el fichero ~ no tiene el formato de un fichero de enteros"

#: stream.d:9288
msgid "~: argument should be a symbol, not ~"
msgstr "~: el argumento debe ser un símbolo, no ~"

#: stream.d:9997 stream.d:10443
msgid "~ is beyond the end because the string ~ has been adjusted"
msgstr "~ está más allá del final porque la cadena ~ ha sido ajustada"

#: stream.d:10088
msgid "~: ~ is not a string input stream"
msgstr "~: ~ no es un flujo de entrada de cadenas de caracteres"

#: stream.d:10208
msgid "~: ~ is not a string output stream"
msgstr "~: ~ no es un flujo de salida de cadenas de caracteres"

# Duda: He traducido `fill pointer' por "puntero de relleno". En
# realidad, los `fill-pointer' son exactamente, eso:
#
# "The fill pointer constitutes the "active length" of the vector; all
# vector elements whose index is less than the fill pointer are active,
# and the others are inactive." (Guy L. Steele, Jr; Common Lisp, The
# Language - 2nd Edition; pag. 454).
#
#: stream.d:10248
msgid "~: argument ~ should be a string with fill pointer"
msgstr "~: El argumento ~ debe ser una cadena con un puntero de relleno"

#
# Duda: de acuerdo con la lista de spanglish, `buffer' se traduce
# ---entre otros términos--- por "buffer".
#
#: stream.d:10545
msgid "~: ~ is not a buffered input stream"
msgstr "~: ~ no es un flujo de entrada con buffer"

# Duda: he dejado `host' sin traducir
#
# En la lista de spanglish, se propone traducir `host' por
# `anfitrión'. Además, ¿cuál no fue mi sorpresa al ver que en el manual
# de vuelo del juego "X-Wing vs. Tie-fighter" se había utilizado esta
# traducción?. De modo que yo también voy a hacer lo mismo, ... cll
#
# (A propósito, el juego ese de LucasArts es ¡¡¡GENIAL!!!
# 					Telepromoción - cll) :)
#
#: stream.d:11579
msgid "host should be string, not ~"
msgstr "el anfitrión debe ser una cadena de caracteres y no ~"

# Duda: Pues otra vez como siempre, ..., he dejado `display' tal
# cual. Pienso que todo el mundo sabe lo que es un `display' ¿no?
#
# Por otra parte (como ya sucedió en un mensaje anterior), ..., `fixnum'
# por ser el nombre de un subtipo (o tipo, si se quiere) en Lisp, está
# sin traducir, ...
#
#: stream.d:11590
msgid "display should be a nonnegative fixnum, not ~"
msgstr "el `display' debe ser un entero del tipo FIXNUM >=0, y no ~"

#: stream.d:11664
msgid "~: stream must be a socket-stream, not ~"
msgstr "~: el flujo debe ser un `socket-stream' y no ~"

#: stream.d:11679
msgid "~: argument ~ should be a vector of type (ARRAY (UNSIGNED-BYTE 8) (*))"
msgstr "~: el argumento ~ debe ser un vector del tipo (ARRAY (UNSIGNED-BYTE 8) (*)) "

#: stream.d:11788
msgid "~: ~ is not a SOCKET-SERVER"
msgstr "~: ~ no es un SOCKET-SERVER"

#: stream.d:11963
msgid "~: argument ~ is not a SOCKET-STREAM"
msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#: stream.d:12190
msgid "~: stream must be a generic-stream, not ~"
msgstr "~: el flujo debe ser un `generic-stream', no ~"

#: stream.d:12368
msgid "The value of ~ is not a stream: ~"
msgstr "El valor de ~ no es un flujo: ~"

#: stream.d:12376
msgid "The value of ~ is not an appropriate stream: ~"
msgstr "El valor de ~ no es un flujo apropiado: ~"

#: stream.d:12392
msgid "The value of ~ was not a stream: ~. It has been changed to ~."
msgstr "El valor de ~ no era un flujo: ~. Ha sido cambiado por ~."

#: stream.d:12413
msgid "readline library: out of memory."
msgstr "biblioteca readline: la memoria ha sido agotada."

#: stream.d:13209 stream.d:13390 stream.d:13429
msgid "~: Ctrl-C: User break"
msgstr "~: Ctrl-C: Interrupción del usuario"

#: io.d:846 stream.d:13556
msgid "~: input stream ~ has reached its end"
msgstr "~: el flujo de entrada ~ ha alcanzado su final"

#: stream.d:13602
msgid "~: argument ~ is not an open file stream"
msgstr "~: el argumento ~ no es el flujo de un fichero abierto"

#: stream.d:13634
msgid "~: position argument should be ~ or ~ or a nonnegative fixnum, not ~"
msgstr "~: el argumento de posición debe ser ~, ~ o un número no negativo del tipo FIXNUM, pero no ~"

#: io.d:297
msgid "The value of ~ was not a readtable. It has been reset."
msgstr "El valor de ~ no es una tabla de lectura. Ha sido inicializado/a."

#: io.d:381
msgid "~: argument ~ is not a readtable"
msgstr "~: el argumento ~ no es una tabla de lectura"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
# Al final, por iniciativa de Leo, he cambiado `# macro carácter', que
# no me gustaba demasiado por `macro carácter secundario', que me parece
# mucho mejor. - cll
#
#: io.d:565
msgid "~: ~ is a dispatch macro character"
msgstr "~: ~ es un macro carácter secundario"

#
# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:634
msgid "~: ~ is not a dispatch macro character"
msgstr "~: ~ no es un macro carácter secundario"

#: io.d:665
msgid "~: digit $ not allowed as sub-char"
msgstr "~: el dígito $ no está permitido como un sub-carácter"

#: io.d:712
msgid "~: new value ~ should be ~, ~, ~ or ~."
msgstr "~: el nuevo valor ~ debe ser ~, ~, ~ o ~."

#: io.d:751
msgid ""
"The value of ~ should be an integer between 2 and 36, not ~.\n"
"It has been reset to 10."
msgstr ""
"El valor de ~ debe ser un entero entre 2 y 36, no ~.\n"
"Ha sido inicializado a 10."

#: io.d:806
msgid "~ from ~: character read should be a string-char: ~"
msgstr "~ en ~: el carácter leído debe ser un STRING-CHAR: ~"

#: io.d:865
msgid "~: input stream ~ ends within an object. Last opening parenthesis probably in line ~."
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto. El último paréntesis abierto es, probablemente, el de la línea ~."

#: io.d:875
msgid "~: input stream ~ ends within an object"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba un objeto"

#: io.d:1167
msgid "~ from ~: illegal character ~"
msgstr "~ en ~: carácter inválido ~"

#
# Duda: Lo mismo de antes, he dejado `token' sin traducir
#
#: io.d:1183
msgid "~: input stream ~ ends within a token after single escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape simple"

#
# Duda: A ver, ¿la palabra `token'?
#       Mientras no se os ocurra algo mejor, lo he dejado en inglés, ...
#
#: io.d:1233
msgid "~: input stream ~ ends within a token after multiple escape character"
msgstr "~: el flujo de entrada ~ termina con un `token' después de un carácter de escape múltiple"

#: io.d:1754
msgid "~ from ~: ~ has no macro character definition"
msgstr "~ en ~: ~ no tiene ninguna definición de macro carácter"

#: io.d:1771
msgid "~ from ~: macro character definition for ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter para ~ no puede devolver ~ valores, sólo puede ser uno."

#: io.d:1798
msgid "~: input stream ~ ends within read macro beginning to ~"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba una macro de lectura en ~"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: io.d:1830
msgid "~ from ~: After ~ is ~ an undefined dispatch macro character"
msgstr "~ en ~: Después de ~ está ~, que no es un macro carácter secundario"

#: io.d:1847
msgid "~ from ~: dispatch macro character definition for ~ after ~ may not return ~ values, only one value."
msgstr "~ en ~: la definición del macro carácter secundario de ~ después de ~ sólo puede devolver un valor, no ~"

# Duda: He traducido `token' tal cual, ... Santiago, imagino que la
# palabra token se queda tal cual. Quiero decir, ¿es necesario lo de las
# comillas? - cll
#
#: io.d:1925
msgid "~ from ~: a token consisting only of dots cannot be meaningfully read in"
msgstr "~ en ~: no puede leerse correctamente un `token' que consiste únicamente en puntos"

# Duda: Todo el mundo sabe que `colon' es el signo de dos puntos
# `:'. Bueno, pues la traducción del siguiente mensaje podría ser algo
# del estilo: "demasiados signos de dos puntos en el token ...", sin
# embargo, me ha parecido mejor poner los dos puntos directamente, ...
#
#: io.d:2016
msgid "~ from ~: too many colons in token ~"
msgstr "~ en ~: demasiados `:' en el `token' ~"

#: io.d:2068
msgid "~ from ~: there is no package with name ~"
msgstr "~ en ~: no existe ningún paquete con el nombre ~"

#: io.d:2101
msgid "~ from ~: ~ has no external symbol with name ~"
msgstr "~ en ~: ~ no tiene ningún símbolo externo con el nombre ~"

#: io.d:2148
msgid "~ from ~: token \".\" not allowed here"
msgstr "~ en ~: el `token' \".\" no está permitido aquí"

#: io.d:2200 io.d:6195
msgid "~: the value of ~ has been arbitrarily altered"
msgstr "~: el valor de ~ ha sido arbitrariamente alterado"

#: io.d:2218
msgid "~: no entry for ~ from ~ in ~ = ~"
msgstr "~: no existe ninguna entrada para ~ de ~ en ~ = ~"

#: io.d:2429
msgid "~ from ~: illegal end of dotted list"
msgstr "~ en ~: fin de lista punteada inválido"

#: io.d:2503
msgid "~ from ~: an object cannot start with ~"
msgstr "~ en ~: un objeto no puede comenzar por ~"

#: io.d:2587
msgid "~: input stream ~ ends within a string"
msgstr "~: el flujo de entrada ~ termina con una cadena"

#: io.d:2659
msgid "~ from ~: no number allowed between # and $"
msgstr "~ en ~: no debe haber ningún número entre # y $"

#: io.d:2754
msgid "~: input stream ~ ends within a comment #$ ... $#"
msgstr "~: el flujo de entrada ~ termina dentro un comentario #$ ... $#"

#: io.d:2842
msgid "~ from ~: font number ~ for character is too large, should be < ~"
msgstr "~ en ~: el número ~ para la fuente de caracteres es demasiado grande, debe ser < ~"

# Duda: Vamos a ver, ... porque esto es muy curioso, ... En Common Lisp,
# los caracteres tienen tres atributos (Common Lisp, The Language, 2nd
# Edition - Guy L. Steel, página 374): código, bits y fuente. El
# atributo "bits" se refiere a otras señales que se pueden activar por
# la pulsación simultánea de varias teclas (o sea, el Control, Mays,
# etc.) Para identificar convenientemente las pulsaciones simultáneas de
# teclas con las que se conocen como teclas de control, existen
# "nombres" (he aquí el quiz de la cuestión, ...) para referirse a
# dichas combinaciones.
#
# Bueno, pues este es, entonces, el problema para traducir "character
# bit with name". La verdad, no me extraña que los indios hablasen como
# hablaban, ... esto no puede ser más críptico :)
#
# Yo he optado por "nombre para los bits de carácter", ... ¿qué os
# parece? - cll
#
#: io.d:2902
msgid "~ from ~: there is no character bit with name ~"
msgstr "~ en ~: no hay ningún nombre para los bits de carácter que sea ~"

#: io.d:2967
msgid "~ from ~: there is no character with name ~"
msgstr "~ en ~: no hay ningún carácter con el nombre ~"

#: io.d:3032
msgid "~ from ~: token ~ after #$ is not a rational number in base ~"
msgstr "~ en ~: el `token' ~ después de #$ no es un número racional en base ~"

#: io.d:3101
msgid "~ from ~: the number base must be given between # and R"
msgstr "~ en ~: el número de la base debe estar entre # y R"

#: io.d:3119
msgid "~ from ~: The base ~ given between # and R should lie between 2 and 36"
msgstr "~ en ~: La base ~ entre # y R debe estar entre 2 y 36"

#: io.d:3166
msgid "~ from ~: bad syntax for complex number: #C~"
msgstr "~ en ~: sintaxis incorrecta del número complejo: #C~"

#: io.d:3201
msgid "~ from ~: token expected after #:"
msgstr "~ en : ~: se esperaba un `token' después de #:"

#: io.d:3229
msgid "~ from ~: token ~ after #: should contain no colon"
msgstr "~ en ~: el `token' ~ después de #: no debe contener dos puntos"

#: io.d:3282
msgid "~ from ~: only zeroes and ones are allowed after #*"
msgstr "~ en ~: sólo se permiten ceros y unos después de #*"

#: io.d:3313
msgid "~ from ~: bit vector is longer than the explicitly given length ~"
msgstr "~ en ~: la longitud del vector de bits es mayor que la longitud explícitamente indicada ~"

#: io.d:3325
msgid "~ from ~: must specify element of bit vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de bits de longitud ~"

#: io.d:3406
msgid "~ from ~: vector is longer than the explicitly given length ~"
msgstr "~ en ~: el vector tiene una longitud mayor que la explícitamente indicada ~"

#: io.d:3418
msgid "~ from ~: must specify element of vector of length ~"
msgstr "~ en ~: debe especificar un elemento para el vector de longitud ~"

#: io.d:3509
msgid "~ from ~: bad syntax for array: #A~"
msgstr "~ en ~: sintaxis incorrecta en la matriz: #A~"

#: io.d:3587
#, fuzzy
msgid "~ from ~: ~ = ~ doesn't allow the evaluation of ~"
msgstr "~: ~ no es una especialización de ~"

#: io.d:3713
msgid "~ from ~: a number must be given between # and $"
msgstr "~ en ~: debe indicarse un número entre # y $"

#: io.d:3728
msgid "~ from ~: label #~? too large"
msgstr "~ en ~: la etiqueta #~? es demasiado grande"

# Duda: En Common Lisp existe lo que se denominan "Listas de asociación"
# (Common Lisp, The Language, 2nd Edition - Guy L. Steel, página 431) o,
# en inglés, "Association Lists" que abreviadamente se conocen como
# "alist" o "a-list". En realidad, aunque en español, mucha gente dice
# "alistas", esto no me parece correcto y me parece mucho más formal
# decir "listas de asociación".
#
# De hecho, el término "listas de asociación" será facílisimamente
# reconocible por el programador, mientras que "alista" exige estar un
# poquito más experimentado con el Lisp.
#
# Más aún, los traductores del libro "Lisp" (3ra edición) de Winston y
# Horn, utilizan la expresión "lista de asociación" en la presentación
# de la función ASSOC en la página 34, aunque luego también se refieran
# a ellas como "listas-a".
#
#: io.d:3753
msgid "~ from ~: the value of ~ has been altered arbitrarily, it is not an alist: ~"
msgstr "~ en ~: el valor de ~ ha sido modificado arbitrariamente, no es una lista de asociación: ~"

#: io.d:3773
msgid "~ from ~: label #~= may not be defined twice"
msgstr "~ en ~: la etiqueta #~= no puede definirse dos veces"

#: io.d:3802
msgid "~ from ~: #~= #~# is illegal"
msgstr "~ en ~: #~= #~# no está permitido"

#: io.d:3830
msgid "~ from ~: undefined label #~#"
msgstr "~ en ~: la etiqueta #~# no está definida"

#: io.d:3849
msgid "~ from ~: objects printed as #<...> cannot be read back in"
msgstr "~ en ~: los objetos escritos de la manera #<...> no pueden volverse a leer"

#: io.d:3869
msgid "~ from ~: objects printed as # in view of ~ cannot be read back in"
msgstr "~ en ~: los objetos escritos como # a causa de ~ no pueden volverse a leer"

# Duda: `feature' puede ser característica, propiedad, ... Yo me he
# decidido por la última. Sin embargo, ¿hay algún término oficial para
# esta palabra (muy común, por cierto)?
#
#: io.d:3956
msgid "~ from ~: illegal feature ~"
msgstr "~ en ~: propiedad inválida ~"

#: io.d:4088
msgid "~ from ~: #S must be followed by the type and the contents of the structure, not ~"
msgstr "~ en ~: #S debe estar seguido del tipo y contenidos de la estructura, no ~"

#: io.d:4103
msgid "~ from ~: the type of a structure should be a symbol, not ~"
msgstr "~ en ~: el tipo de una estructura debe ser un símbolo, no ~"

#: io.d:4120
msgid "~ from ~: bad HASH-TABLE"
msgstr "~ en ~: HASH-TABLE incorrecta"

#: io.d:4150
msgid "~ from ~: bad ~"
msgstr "~ en ~: ~ es incorrecto"

#: io.d:4182
msgid "~ from ~: no structure of type ~ has been defined"
msgstr "~ en ~: no se ha definido ninguna estructura del tipo ~"

#: io.d:4196
msgid "~ from ~: bad ~ for ~"
msgstr "~ en ~: ~ es incorrecto en ~"

#: io.d:4211
msgid "~ from ~: structures of type ~ cannot be read in, missing constructor function"
msgstr "~ en ~: las estructuras del tipo ~ no pueden leerse, no se conoce la función de construcción"

#: io.d:4233
msgid "~ from ~: a structure ~ may not contain a component \".\""
msgstr "~ en ~: una estructura ~ no debe contener un componente \".\""

#: io.d:4247
msgid "~ from ~: ~ is not a symbol, not a slot name of structure ~"
msgstr "~ en ~: ~ no es un símbolo, ni el nombre de una ranura ni una estructura ~"

#: io.d:4260
msgid "~ from ~: missing value of slot ~ in structure ~"
msgstr "~ en ~: falta el valor de la ranura ~ en la estructura ~"

#
# Duda: slots se queda tal cual, ...
#
# De acuerdo con la lista spanglish, `slot' se traducirá, en todo el
# CLisp, como "ranura".
#
#: io.d:4283
msgid "~ from ~: too many slots for structure ~"
msgstr "~ en ~: hay demasiadas ranuras en la estructura ~"

#
# "~ en ~: sintaxis inválida del vector de código de recinto tras #~Y" - lsg
#
# Hmmm, no me acaba de gustar, ... - cll
#
#: io.d:4322
msgid "~ from ~: illegal syntax of closure code vector after #~Y"
msgstr "~ en ~: sintaxis inválida del vector de código de la cerradura después de #~Y"

#: io.d:4363
msgid "~ from ~: object #Y~ has not the syntax of a compiled closure"
msgstr "~ en ~: el objeto #Y~ no tiene la sintaxis de una cerradura compilada"

#
# pathname NO es array!
# "~ en ~: sintaxis incorrecta en nombre de path: #A~" - lsg
#
# Si, es verdad, aquí se me había ido la mano, ...
#
# Además, PATHNAME no se traduce puesto que, o bien se refiere al tipo
# de datos PATHNAME o a la función PATHNAME (en este caso, al tipo de
# datos). Como ambos términos están definidos en el estándar de Common
# Lisp: Common Lisp - The Language; 2nd Edition; Guy L. Steele Jr., pues
# no se traduce y se pone en mayúsculas para distinguirlo de otros
# términos. - cll
#
#: io.d:4500
msgid "~ from ~: bad syntax for pathname: #P~"
msgstr "~ en ~: la sintaxis del PATHNAME: #P~ es incorrecta"

#: io.d:4706 io.d:9483
msgid "~: ~ is not a character"
msgstr "~: ~ no es un carácter"

# Nota: El siguiente mensaje se debe a la función PEEK-CHAR (Common
# Lisp, The Language - 2nd Edition; Guy L. Steele, Jr; pag. 574), que
# realiza la lectura del siguiente objeto de un flujo de caracteres
# según el valor de su primer argumento opcional `peek-type' que solo
# puede valer, como reza el mensaje, NIL, T o un carácter.
#
#: io.d:4753
msgid "~: peek type should be NIL or T or a character, not ~"
msgstr "~: el tipo del PEEK solo puede ser NIL, T o un carácter, y no ~"

# "~:argumento de ~ debe ser un entero comprendido entre 2 y 36, no ~" - lsg
#
# Algo parecido he puesto yo - cll
#
#: io.d:4905
msgid "~: ~ argument should be an integer between 2 and 36, not ~"
msgstr "~: el argumento ~ debe ser un entero comprendido entre 2 y 36, y no ~"

# "~: la cadena ~ no tiene sintaxis de entero" - lsg
#
# He cambiado lo "de entero" por "de un número entero", que parece más
# inteligible - cll
#
#: io.d:4998
#, fuzzy
msgid "~: string ~ does not have integer syntax"
msgstr "~: la cadena ~ no tiene la sintaxis de un número entero"

#: io.d:5164
msgid "~: Despite of ~, ~ cannot be printed readably."
msgstr "~: A pesar de ~, ~ no puede imprimirse de manera legible."

#: io.d:5192
msgid ""
"~: the value ~ of ~ is neither ~ nor ~ nor ~.\n"
"It is reset to ~."
msgstr ""
"~: el valor ~ de ~ no es ~ ni ~ ni ~.\n"
"Ha sido inicializado a ~."

#: io.d:5554
#, fuzzy
msgid "~: must be a positive integer or NIL, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo INTEGER o FLOAT, no ~"

# "~: espacio insuficiente en la pila para realizar un análisis de circularidad" - lsg
#
# Vale - cll
#
#: io.d:6402
msgid "~: not enough stack space for carrying out circularity analysis"
msgstr "~: no hay espacio suficiente en la pila para realizar un análisis de circularidad"

#: io.d:7960
msgid "~: bad ~"
msgstr "~: incorrecto ~"

#: io.d:8077 record.d:230
msgid "~: ~ is not a structure"
msgstr "~: ~ no es una estructura"

#: io.d:8814
msgid "~: an unknown record type has been generated!"
msgstr "~: se ha generado un tipo de registro desconocido!"

#
# ¡¡Large no es largo, sino grande!! - lsg
#
# Tienes toda la razón, ya lo he cambiado en todos los mensajes - cll
#
#: array.d:218
msgid "index too large"
msgstr "índice demasiado grande"

# FIXME. Esto no cabe en 80 columnas. Comunicar al autor (?) sv
#
# "Una formación ha sido acortada mediante un ajuste al trasladar otra formación hacia ella"
# O bien, para que quepa en 80 columnas:
# "Una formación ha sido acortada al trasladar otra formación hacia ella" - lsg
#
# Yo había puesto:
#
# "Una matriz ha sido acortada debido a un ajuste cuando otra se ha desplazado "
# "hacia ella"
#
# Y ciertamente me gusta más tu traducción, salvo que en vez de
# formaciones hay que hablar de matrices, ¿no crees? - cll
#
#: array.d:229
msgid "An array has been shortened by adjusting it while another array was displaced to it."
msgstr "Una matriz ha sido acortada al trasladar otra matriz ella"

# "~: ~ no es una formación" - lsg
#
# Aunque en la lista de spanglish.txt pone "formación", en este caso
# creo que será mucho más conveniente poner "matriz" porque de hecho,
# los mensajes se refieren a matrices, ... - cll
#
#: array.d:331
msgid "~: ~ is not an array"
msgstr "~: ~ no es una matriz"

#: array.d:368 foreign.d:2234
msgid "~: got ~ subscripts, but ~ has rank ~"
msgstr "~: se encontraron ~ subíndices, pero ~ tiene rango ~"

#: array.d:386 foreign.d:2253
msgid "~: subscripts ~ for ~ are not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: los subíndices ~ de ~ no son del tipo '(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:404 foreign.d:2267
msgid "~: subscripts ~ for ~ are out of range"
msgstr "~: los subíndices ~ de ~ han excedido el rango"

#: array.d:467
msgid "~: index ~ for ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: el índice ~ de ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:482
msgid "~: index ~ for ~ is out of range"
msgstr "~: el índice ~ de ~ ha excedido el rango"

#: array.d:641
msgid "~: ~ does not fit into ~, bad type"
msgstr "~: ~ no cabe en ~, tipo incorrecto"

#: array.d:829
msgid "~: ~ is not an nonnegative integer less than the rank of ~"
msgstr "~: ~ no es un entero no negativo menor que el rango de ~"

#: array.d:1021
msgid "~: ~ is not an array of bits"
msgstr "~: ~ no es una matriz de bits"

#: array.d:1532
msgid "~: The arguments ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:1545
msgid "~: The arguments ~, ~ and ~ should be arrays of bits with the same dimensions"
msgstr "~: Los argumentos ~, ~ y ~ deben ser matrices de bits de la misma dimensión"

#: array.d:1682
msgid "~: vector ~ has no fill pointer"
msgstr "~: el vector ~ no tiene ningún puntero de relleno"

#: array.d:1731
msgid "~: ~ has length zero"
msgstr "~: ~ tiene longitud nula"

#: array.d:1763
msgid "~ works only on adjustable arrays, not on ~"
msgstr "~ funciona sólo con matrices ajustables, no con ~"

#: array.d:1784
msgid "~: extension ~ should be a positive fixnum"
msgstr "~: la extensión ~ debe ser un número positivo del tipo FIXNUM"

#: array.d:1810
msgid "~: extending the vector by ~ elements makes it too long"
msgstr "~: ampliar el vector en ~ elementos, lo hace muy grande"

#: array.d:1903
msgid "~: cannot push ~ into array ~ (bad type)"
msgstr "~: no se puede introducir ~ en la matriz ~ (tipo incorrecto)"

#: array.d:2097
msgid "~: dimension ~ is not of type `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"
msgstr "~: la dimensión ~ no es del tipo `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))"

#: array.d:2141
msgid "~: dimensions ~ produce too large total-size"
msgstr "~: las dimensiones ~ producen un tamaño total demasiado grande"

#: array.d:2178
msgid "~: ambiguous, more than one initialisation specified"
msgstr "~: ambiguo, se ha especificado más de una inicialización"

#: array.d:2192
msgid "~: ~ must not be specified without ~"
msgstr "~: ~ no debe especificarse sin ~"

#: array.d:2310
msgid "~: the initial-element ~ is not of type ~"
msgstr "~: el INITIAL-ELEMENT ~ no es del tipo ~"

#: array.d:2397
#, fuzzy
msgid "~: ~ is of incorrect length"
msgstr "~: ~ no tiene la longitud correcta"

#: array.d:2430
msgid "~: ~-argument ~ is not an array"
msgstr "~: El ~ argumento ~ no es una matriz"

#: array.d:2460
#, fuzzy
msgid "~: ~-argument ~ does not have element type ~"
msgstr "~: El ~ argumento ~ no tiene como tipo de elemento ~"

#: array.d:2478
msgid "~: ~-argument ~ is not of type `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"
msgstr "~: El ~ argumento ~ no es del tipo `(INTEGER 0 (,ARRAY-TOTAL-SIZE-LIMIT))"

#: array.d:2492
msgid "~: array-total-size + displaced-offset (= ~) exceeds total size ~ of ~-argument"
msgstr "~: array-total-size + displaced-offset (= ~) excede el tamaño total ~ del ~ argumento"

#: array.d:2519
msgid "~: fill-pointer ~ should be a nonnegative fixnum"
msgstr "~: El puntero de relleno ~ debe ser un número no negativo del tipo FIXNUM"

#: array.d:2532
msgid "~: fill-pointer argument ~ is larger than the length ~"
msgstr "~: El argumento FILL-POINTER ~ es mayor que la longitud ~"

#
# "~: el rango intentado ~ es demasiado grande" - lsg
#
# De acuerdo - cll
#
#: array.d:2605
msgid "~: attempted rank ~ is too large"
msgstr "~: el rango intentado ~ es demasiado grande"

#: array.d:2622
msgid "~: ~ may not be specified for an array of rank ~"
msgstr "~: ~ no debe especificarse para una matriz de rango ~"

#: array.d:2807
msgid "~: array ~ is not adjustable"
msgstr "~: la matriz ~ no es ajustable"

#: array.d:2832
msgid "~: rank ~ of array ~ cannot be altered: ~"
msgstr "~: no es posible cambiar el rango ~ de la matriz ~: ~"

#
# "~: los elementos de la formación ~ no son de tipo ~" - lsg
#
# Una excelente traducción. Lo único que hago es cambiar "formación" por
# "matriz" y listo - cll
#
#: array.d:2850
#, fuzzy
msgid "~: array ~ does not have element-type ~"
msgstr "~: los elementos de la matriz ~ no son del tipo ~"

#: array.d:2908
msgid "~: cannot displace array ~ to itself"
msgstr "~: no se puede desplazar la matriz ~ hacia ella misma"

#: array.d:2931
msgid "~: array ~ has no fill-pointer"
msgstr "~: la matriz ~ no tiene ningún puntero de relleno"

#: array.d:2950
msgid "~: the fill-pointer of array ~ is ~, greater than ~"
msgstr "~: el puntero de relleno de la matriz ~ es ~ que es mayor que ~"

# ... de la misma forma que uno no pone "START Índice" sv
#
# Si, si, ..., tienes toda la razón, ... cll
#
#: array.d:3076
msgid "Illegal START index ~ for ~"
msgstr "Índice START ~ inválido en ~"

#: array.d:3106
msgid "Illegal END index ~ for ~"
msgstr "Índice END ~ inválido en ~"

#: array.d:3122
msgid "~: invalid bit-vector length ~"
msgstr "~: la longitud de BIT-VECTOR ~ es inválida"

# Duda: hash lo he traducido por hash. ¿Alguna sugerencia? ¿Tablas de
# acceso rápido, o algo así?. Tened en cuenta que en Common Lisp, las
# tablas hash son una estructura bien definida que cuenta con sus
# propias instrucciones. A mí me gusta tal cual, ...
# Sugerencia: tabla de `hash'. sv
#
# No, no, no, no, ... :) `hash table' es `tabla hash'. Si se quiere,
# podríamos traducir la palabra `hash' pero si se deja es `tabla
# hash'. Todos los informáticos las llamamos así. Jamás he oído `Tabla
# *de* hash' cll
#
#: hashtabl.d:886
msgid "Hash table size ~ too large"
msgstr "La tabla hash ~ es demasiado grande"

#
# "error interno al redimensionar ~" - lsg
#
# Me gusta, salvo que el error ocurre "durante" - cll
#
#: hashtabl.d:934
msgid "internal error occured while resizing ~"
msgstr "error interno durante el redimensionamiento de ~"

#: hashtabl.d:1042
msgid "~: illegal :TEST argument ~"
msgstr "~: argumento :TEST inválido ~"

#: hashtabl.d:1060
msgid "~: :SIZE argument should be a fixnum >=0, not ~"
msgstr "~: el argumento :SIZE debe ser del tipo FIXNUM >= 0, no ~"

#: hashtabl.d:1083
msgid "~: :REHASH-SIZE argument should be a float > 1, not ~"
msgstr "~: el argumento :REHASH-SIZE debe ser del tipo FLOAT > 1, no ~"

#: hashtabl.d:1129
msgid "~: :REHASH-THRESHOLD argument should be a float between 0 and 1, not ~"
msgstr "~: el argumento :REHASH-THRESHOLD debe ser un número del tipo FLOAT entre 0 y 1, no ~"

#: hashtabl.d:1203
msgid "~: internal error while building ~"
msgstr "~: error interno durante la construcción de ~"

#: hashtabl.d:1247
msgid "~: argument ~ is not a hash-table"
msgstr "~: el argumento ~ no es una tabla hash"

#: list.d:455
msgid "~: A true list must not end with ~"
msgstr "~: Una auténtica lista no debe finalizar con ~"

#: list.d:505
msgid "~: ~ is not a nonnegative fixnum and therefore not a valid index"
msgstr "~: ~ no es un FIXNUM no negativo y por ello, no es un índice válido"

#: list.d:581
msgid "~: ~ is not a nonnegative integer and therefore not a valid argument"
msgstr "~: ~ no es un entero no negativo y por ello, no es un argumento válido"

#: list.d:701
msgid "~: ~ is not a nonnegative fixnum and therefore not a valid list length"
msgstr "~: ~ no es un FIXNUM no negativo y por ello, no es una longitud de lista válida"

#: list.d:970
msgid "~: ~ is not a pair"
msgstr "~: ~ no es un par"

#: list.d:1617
msgid "~: lists ~ and ~ are not of same length"
msgstr "~: las listas ~ y ~ no son de la misma longitud"

#: list.d:1805
msgid "~: index ~ too large for ~"
msgstr "~: el índice ~ es demasiado grande para ~"

#: list.d:1856
msgid "~: start index ~ too large for ~"
msgstr "~: el índice :START ~ es demasiado grande para ~"

#: list.d:1896
msgid "~: end index ~ too large for ~"
msgstr "~: el índice :END ~ es demasiado grande para ~"

#: package.d:341
msgid "symbol ~ cannot be deleted from symbol table"
msgstr "el símbolo ~ no puede ser borrado de la tabla de símbolos"

#: package.d:715
msgid "~ inconsistent: symbol ~ is a shadowing symbol but not present"
msgstr "inconsistencia en ~: el símbolo ~ es un símbolo que eclipsa a otro/s, sin embargo no está presente."

#: package.d:1172
msgid "UNEXPORT in ~ is illegal"
msgstr "UNEXPORT en ~ es inválido"

#
# "UNEXPORT sólo funciona con símbolos accesibles, no con ~ en ~" - lsg
#
# Ya, o sea, que cambie "sobre" por "con". Vale, me gusta mucho más tu
# mensaje que el mío - cll
#
#: package.d:1199
msgid "UNEXPORT works only on accessible symbols, not on ~ in ~"
msgstr "UNEXPORT sólo funciona sobre símbolos accesibles, no con ~ en ~"

#: package.d:1796
msgid "The value of *PACKAGE* was not a package. Old value ~. New value ~."
msgstr "El valor de *PACKAGE* no era un paquete. Valor anterior ~. Nuevo valor ~."

#: package.d:1818
msgid "Package ~ has been deleted."
msgstr "El paquete ~ ha sido borrado."

#: package.d:1831
msgid "There is no package with name ~"
msgstr "No hay ningún paquete con el nombre ~"

#: package.d:1843
msgid "~: argument should be a package or a package name, not ~"
msgstr "~: el argumento debe ser un paquete o el nombre de un paquete, no ~"

#: package.d:1857
msgid "~: argument should be a string, not ~"
msgstr "~: el argumento debe ser una cadena de caracteres, no ~"

#: package.d:1880
msgid "~: argument ~ should be a string or a symbol"
msgstr "~: el argumento ~ debe ser una cadena o un símbolo"

#: package.d:1981
msgid "~: there is already a package named ~"
msgstr "~: ya hay un paquete llamado ~"

#: package.d:2105 predtype.d:1157
msgid "~: argument ~ is not a symbol"
msgstr "~: el argumento ~ no es un símbolo"

#
# "~: el argumento debe ser un símbolo o una lista de símbolos, no ~" - lsg
#
# Si, ya he cambiado `debería' por `debe' en todos los mensajes - cll
#
#: package.d:2157
msgid "~: argument should be a symbol or a list of symbols, not ~"
msgstr "~: el argumento debe ser un símbolo o una lista de símbolos, no ~"

#: package.d:2369
msgid "Cannot change the case sensitiveness of ~."
msgstr ""

#: record.d:23
msgid "~: ~ is not a valid index into ~"
msgstr "~: ~ no es un índice válido en ~"

#: record.d:37
msgid "~: ~ is not a record"
msgstr "~: ~ no es un registro"

#: record.d:110
msgid "~: length ~ is illegal, should be of type (INTEGER (0) (65536))"
msgstr "~: la longitud ~ es inválida, debe ser del tipo (INTEGER (0) (65536))"

#: record.d:150
msgid "~: ~ is not a structure of type ~"
msgstr "~: ~ no es una estructura del tipo ~"

#: record.d:190
msgid "~: A slot of ~ has no value"
msgstr "~: Una ranura de ~ no tiene valor"

#: record.d:293
msgid "~: ~ is not a closure"
msgstr "~: ~ no es una cerradura"

#: record.d:309
msgid "~: This is not a compiled closure: ~"
msgstr "~: No se trata de una cerradura compilada: ~"

#: record.d:383
msgid "~ is not a valid code-vector byte"
msgstr "~ no es un byte CODE-VECTOR válido"

#: record.d:402
msgid "~: invalid code-vector ~"
msgstr "~: CODE-VECTOR inválido ~"

#: record.d:415
msgid "~: function ~ is too big: ~"
msgstr "~: la función ~ es demasiado grande: ~"

#: record.d:446
#, fuzzy
msgid "~: This is not a generic function: ~"
msgstr "~S: ~S no es una especificación de función genérica"

#: record.d:575
msgid "~: ~ is not a class"
msgstr "~: ~ no es una clase"

#
# Yo pondría un guión entre argumento y clave. - lsg
#
# Hmm, o sea `argumento-clave'. No, no me gusta y de hecho, en el
# "Vocabulario bilingüe de términos técnicos" de "Lisp" (3ra edición) de
# Winston y Horn, los traductores al español ponen en la página 649:
#
# keyword arguments - argumentos clave
#
# sin guión por medio - cll
#
#: record.d:778
msgid ""
"~: illegal keyword/value pair ~, ~ in argument list.\n"
"The allowed keywords are ~"
msgstr ""
"~: par argumento clave/valor inválido ~, ~ en la lista de argumentos.\n"
"Los parámetros clave permitidos son ~"

#: record.d:815
msgid "SHARED-INITIALIZE: keyword argument list ~ has an odd length"
msgstr "SHARED-INITIALIZE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:931
msgid "REINITIALIZE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "REINITIALIZE-INSTANCE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1030
msgid "INITIALIZE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "INITIALIZE-INSTANCE: la lista de argumentos clave ~ tiene longitud impar"

#: record.d:1157
msgid "MAKE-INSTANCE: keyword argument list ~ has an odd length"
msgstr "MAKE-INSTANCE: la lista de argumentos clave ~S tiene longitud impar"

#: sequence.d:199
msgid "There are no sequences of type ~"
msgstr "No hay secuencias del tipo ~"

#: sequence.d:249
msgid "~ is not a sequence"
msgstr "~ no es una secuencia"

#: sequence.d:268
msgid "~: ~ should be an integer >=0, not ~"
msgstr "~: ~ debe ser un entero >=0, no ~"

#: sequence.d:322 sequence.d:356
msgid "~: ~ = ~ should not be greater than ~ = ~"
msgstr "~: ~ = ~ no debe ser mayor que ~ = ~"

#: sequence.d:472
msgid "~: the index should be a fixnum >=0, not ~"
msgstr "~: el índice debe ser un número >=0 del tipo FIXNUM, no ~"

#: sequence.d:492
msgid "~ ~: the index should be a fixnum >=0, not ~"
msgstr "~ ~: el índice debe ser del tipo fixnum >=0, no ~"

#: sequence.d:634
msgid "~: ~ is not a sequence"
msgstr "~: ~ no es una secuencia"

#: sequence.d:740 sequence.d:970
msgid "~: bad length ~"
msgstr "~: longitud incorrecta ~"

#: sequence.d:843
msgid "~: size should be an integer >=0, not ~"
msgstr "~: el tamaño debe ser un entero >=0, no ~"

#: sequence.d:854
msgid "~: :update must not be specified without :initial-element"
msgstr "~: no debe especificarse :update sin :initial-element"

#: sequence.d:1785
msgid "~: Must not specify both arguments to :TEST and :TEST-NOT"
msgstr "~: Los argumentos :TEST y :TEST-NOT no deben tener valor simultáneamente"

#: sequence.d:1917
msgid "~: sequence ~ is too long"
msgstr "~: la secuencia ~ es demasiado larga"

#: sequence.d:2382
msgid "too long sequence ~"
msgstr "secuencia demasiado larga ~"

#: charstrg.d:484
msgid "This is not a string: ~"
msgstr "Esto no es una cadena: ~"

#: charstrg.d:742
msgid "~: the radix must be an integer between 2 and 36, not ~"
msgstr "~: la base debe ser un entero entre 2 y 36, no ~"

#: charstrg.d:1055
msgid "~: the font argument should be an integer, not ~"
msgstr "~: el argumento de la fuente debe ser un número y no ~"

#: charstrg.d:1077
msgid "~: the bits argument should be an integer, not ~"
msgstr "~: el argumento de los bits debe ser un entero y no ~"

#: charstrg.d:1095
msgid "~: the code argument should be an integer, not ~"
msgstr "~: el argumento del código debe ser un entero y no ~"

# "~: no se puede convertir ~ al tipo character"
#
# No sé si traducir la palabra character, puesto que es una palabra
# clave en Lisp. - lsg
#
# Yo ya había traducido este mensaje como:
#
# "~: ~ no puede convertirse a un carácter"
#
# Pero el tuyo me gusta mucho más, salvo que `character', puesto que es
# un término definido en el estándar Common Lisp, debe ir en mayúsculas
# - cll
#
#: charstrg.d:1151
msgid "~: cannot coerce ~ to a character"
msgstr "~: no se puede convertir ~ al tipo CHARACTER"

#: charstrg.d:1201
msgid "~: the weight argument should be an integer, not ~"
msgstr "~: el argumento de ponderación debe ser un entero, y no ~"

#: charstrg.d:1245
msgid "~: argument should be an integer, not ~"
msgstr "~: el argumento debe ser un entero, no ~"

# Ya, ya se que eso de "los nombres de bit" puede sonar muy raro, pero
# es que realmente es así en Common Lisp.  Consúltese el Cltl2, 13.5
# Character Control-Bit Functions, página 385
#
#: charstrg.d:1297
msgid "~: the only bit names are :CONTROL, :META, :SUPER, :HYPER, not ~"
msgstr "~: los únicos nombres de bit son :CONTROL, :META, :SUPER y :HYPER, y no ~"

#: charstrg.d:1338
msgid "~: index should be an integer, not ~"
msgstr "~: el índice debe ser un entero, no ~"

#: charstrg.d:1347
msgid "~: ~-index should be an integer, not ~"
msgstr "~: el índice ~ debe ser un entero, no ~"

#: charstrg.d:1365
msgid "~: index should be NIL or an integer, not ~"
msgstr "~: el índice debe ser NIL o un entero, no ~"

#: charstrg.d:1374
msgid "~: ~-index should be NIL or an integer, not ~"
msgstr "~: el índice ~ debe ser NIL o un entero, no ~"

#: charstrg.d:1392
msgid "~: index should not be negative: ~"
msgstr "~: el índice no debe ser negativo: ~"

#: charstrg.d:1401
msgid "~: ~-index should not be negative: ~"
msgstr "~: el índice ~ no debe ser negativo: ~"

#: charstrg.d:1417
msgid "~: index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:1426
msgid "~: ~-index ~ should not be greater than the length of the string"
msgstr "~: el índice ~ = ~ no debe ser mayor que la longitud de la cadena"

#: charstrg.d:1442
msgid "~: index ~ should be less than the length of the string"
msgstr "~: el índice ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:1451
msgid "~: ~-index ~ should be less than the length of the string"
msgstr "~: el índice ~ = ~ debe ser menor que la longitud de la cadena"

#: charstrg.d:1544
msgid "~: argument should be a string-char, not ~"
msgstr "~: el argumento debe ser del tipo STRING-CHAR, no ~"

#: charstrg.d:1618 charstrg.d:1692 charstrg.d:2419
msgid "~: :start-index ~ must not be greater than :end-index ~"
msgstr "~: El índice :start ~ no debe ser mayor que el índice :end ~"

#: charstrg.d:1648
msgid "~: argument ~ should be a string, a symbol or a string-char"
msgstr "~: el argumento ~ debe ser del tipo string o string-char, o un símbolo"

#: charstrg.d:1756
msgid "~: :start1-index ~ must not be greater than :end1-index ~"
msgstr "~: El índice start1 ~ no debe ser mayor que el índice :end1 ~"

#: charstrg.d:1782
msgid "~: :start2-index ~ must not be greater than :end2-index ~"
msgstr "~: El índice :start2 ~ no debe ser mayor que el índice :end2 ~"

#: charstrg.d:2156
msgid "~: the string length ~ should be nonnegative fixnum"
msgstr ""
"~: la longitud de la cadena de caracteres ~ debe ser un número no negativo\n"
"del tipo FIXNUM"

#: charstrg.d:2174
msgid "~: :initial-element ~ should be of type string-char"
msgstr "~: El :INITIAL-ELEMENT ~ debe ser del tipo STRING-CHAR"

#
# Duda: esta traducción ha sido muy difícil, y está basada en la
# traducción francesa que dice: "~: Mauvais mode de saut d'environnement
# ~."
#
#: debug.d:686
msgid "~: bad frame climbing mode ~"
msgstr "~: modo de salto de marco incorrecto"

#: debug.d:708
msgid "~: ~ is not a stack pointer"
msgstr "~: ~ no es un puntero de pila"

#: debug.d:889
msgid "~: ~ is not a pointer to an EVAL/APPLY frame"
msgstr "~: ~ no es un puntero a un marco de tipo EVAL/APPLY"

#: debug.d:1143
msgid "~: environment is not an alist"
msgstr "~: el entorno no es una a-lista"

#: debug.d:1239
msgid "~: unknown frame type"
msgstr "~: tipo de marco desconocido"

#: error.d:42 user1.lsp:343
msgid "Unprintable error message"
msgstr "Mensaje de error no imprimible"

#: error.d:497
msgid "~: User break"
msgstr "~: Interrupción del usuario"

#: error.d:549
msgid "~: ~ is not a list"
msgstr "~: ~ no es una lista"

#: error.d:569
msgid "~: ~ is not a symbol"
msgstr "~: ~ no es un símbolo"

#: error.d:601
msgid "~: ~ is not a simple-vector"
msgstr "~: ~ no es un SIMPLE-VECTOR"

#: error.d:619
msgid "~: ~ is not a vector"
msgstr "~: ~ no es un vector"

#: error.d:637
msgid "~: argument ~ should be a nonnegative fixnum"
msgstr "~: el argumento ~ debe ser un número no negativo del tipo fixnum"

#: error.d:655
msgid "~: argument ~ is not a character"
msgstr "~: el argumento ~ no es un carácter"

#: error.d:673
msgid "~: ~ is not a string-char"
msgstr "~: ~ no es un STRING-CHAR"

#: error.d:690
msgid "~: argument ~ is not a string"
msgstr "~: el argumento ~ no es un string"

#: error.d:707
msgid "~: argument ~ is not a simple string"
msgstr "~: el argumento ~ no es una cadena simple"

#: error.d:725
msgid "~: argument ~ should be a stream"
msgstr "~: el argumento ~ debe ser un flujo"

#: error.d:745
msgid "~: argument ~ should be a stream of type ~"
msgstr "~: el argumento ~ debe ser un flujo del tipo ~"

#: error.d:765 error.d:783
msgid "~: ~ is not an 8-bit number"
msgstr "~: ~ no es un número de 8 bits"

#: error.d:801 error.d:819
msgid "~: ~ is not a 16-bit number"
msgstr "~: ~ no es un número de 16 bits"

#: error.d:837 error.d:855
msgid "~: ~ is not an 32-bit number"
msgstr "~: ~ no es un número de 32 bits"

#: error.d:873 error.d:891
msgid "~: ~ is not an 64-bit number"
msgstr "~: ~ no es un número de 64 bits"

#: error.d:913
msgid "~: ~ is not an `unsigned int' number"
msgstr "~: ~ no es un número del tipo `unsigned int'"

#: error.d:935
msgid "~: ~ is not an `int' number"
msgstr "~: ~ no es un número del tipo `int'"

#: error.d:957
msgid "~: ~ is not a `unsigned long' number"
msgstr "~: ~ no es un número del tipo `unsigned long'"

#: error.d:979
msgid "~: ~ is not a `long' number"
msgstr "~: ~ no es un número del tipo `long'"

#: error.d:997
msgid "~: ~ is not a single-float"
msgstr "~: ~ no es un SINGLE-FLOAT"

#: error.d:1015
msgid "~: ~ is not a double-float"
msgstr "~: ~ no es un DOUBLE-FLOAT"

# Sugerencia: "Error del Sistema Operativo Amiga " sv
#
# ¡Ajá! me parece muchísimo mejor que lo que había puesto, ...
#
#: erramiga.d:14
msgid "Amiga OS error "
msgstr "Error del Sistema Operativo Amiga "

#: erramiga.d:47
msgid "not enough memory available"
msgstr "no hay suficiente memoria disponible"

#: erramiga.d:52
msgid "process table full"
msgstr "tabla de procesos llena"

#: erramiga.d:64
msgid "bad template"
msgstr "plantilla incorrecta"

#: erramiga.d:68
msgid "bad number"
msgstr "número incorrecto"

#: erramiga.d:72
msgid "required argument missing"
msgstr "argumentos obligatorios ausentes"

#: erramiga.d:76
msgid "value after keyword missing"
msgstr "falta el valor después de la palabra clave"

#: erramiga.d:80
msgid "wrong number of arguments"
msgstr "~: número incorrecto de argumentos"

# Duda: Uuufff! Por favor, que alguien le eche un ojo a esto, ...
#
# Bueno, he encontrado un mensaje parecido a este en el glibc donde pone
# "desemparejados". Me suena bien. cll
#
#: erramiga.d:84
msgid "unmatched quotes"
msgstr "comillas desemparejadas"

#: erramiga.d:88
msgid "argument line invalid or too long"
msgstr "línea de argumentos inválida o demasiado larga"

#: erramiga.d:92
msgid "file is not executable"
msgstr "el fichero no es un ejecutable"

#: erramiga.d:96
msgid "invalid resident library"
msgstr "librería residente inválida"

#: erramiga.d:107
msgid "object is in use"
msgstr "el objeto está siendo usado"

#: erramiga.d:111
msgid "object already exists"
msgstr "el objeto ya existe"

#: erramiga.d:115
msgid "directory not found"
msgstr "directorio no encontrado"

#: erramiga.d:119
msgid "object not found"
msgstr "objeto no encontrado"

#: erramiga.d:123
msgid "invalid window description"
msgstr "descripción de ventana inválida"

#: erramiga.d:127
msgid "object too large"
msgstr "el objeto es demasiado grande"

#: erramiga.d:132
msgid "packet request type unknown"
msgstr "tipo de paquete de petición desconocido"

#: erramiga.d:136
msgid "object name invalid"
msgstr "nombre de objeto inválido"

#: erramiga.d:140
msgid "invalid object lock"
msgstr "bloqueo de objeto inválido"

#: erramiga.d:144
msgid "object is not of required type"
msgstr "el objeto no es del tipo requerido"

#: erramiga.d:148
msgid "disk not validated"
msgstr "disco no validado"

#: erramiga.d:152
msgid "disk is write-protected"
msgstr "el disco es de solo lectura"

#: erramiga.d:156
msgid "rename across devices attempted"
msgstr "se intentó un renombramiento entre unidades"

#: erramiga.d:160
msgid "directory not empty"
msgstr "directorio no vacío"

#: erramiga.d:164
msgid "too many levels"
msgstr "demasiados niveles"

#: erramiga.d:168
msgid "device (or volume) is not mounted"
msgstr "el dispositivo (o volumen) no está montado"

#: erramiga.d:172
msgid "seek failure"
msgstr "error durante un acceso directo (seek)"

#: erramiga.d:176
msgid "comment is too long"
msgstr "el comentario es demasiado largo"

#: erramiga.d:180
msgid "disk is full"
msgstr "el disco está lleno"

#: erramiga.d:184
msgid "object is protected from deletion"
msgstr "el objeto está protegido contra el borrado"

#: erramiga.d:188
msgid "file is write protected"
msgstr "el archivo está protegido contra escritura"

#: erramiga.d:192
msgid "file is read protected"
msgstr "el fichero está protegido contra escritura"

#: erramiga.d:196
msgid "not a valid DOS disk"
msgstr "no es un disquete DOS válido"

#: erramiga.d:200
msgid "no disk in drive"
msgstr "no hay ningún disquete en la unidad"

#: erramiga.d:209
msgid "no more entries in directory"
msgstr "no hay más entradas en el directorio"

#: erramiga.d:213
msgid "object is soft link"
msgstr "el objeto es un enlace blando"

#: erramiga.d:217
msgid "object is linked"
msgstr "el objeto está enlazado"

#: erramiga.d:221
msgid "bad loadfile hunk"
msgstr "trozo incorrecto del fichero de carga"

#: erramiga.d:225
msgid "function not implemented"
msgstr "función no implementada"

#: erramiga.d:232
msgid "record not locked"
msgstr "registro no bloqueado"

#: erramiga.d:236
msgid "record lock collision"
msgstr "colisión de bloqueo de registro"

#: erramiga.d:240
msgid "record lock timeout"
msgstr "tiempo de espera excedido del bloqueo del registro"

#: erramiga.d:244
msgid "record unlock error"
msgstr "error de desbloqueo de registro"

#: erramiga.d:253
msgid "buffer overflow"
msgstr "desbordamiento del buffer"

#: erramiga.d:257
msgid "break"
msgstr "interrupción"

#: erramiga.d:261
msgid "file not executable"
msgstr "fichero no ejecutable"

# Duda: ¿Ok por `vale'? Hmmm, no sé, no sé, ...
# Depende del caso, ¿qué te parece "correcto"? sv
#
# No, no me gusta demasiado, ..., me parece que es demasiado en plan
# "computadora". Prefiero "vale" antes que "correcto". cll
#
#: erramiga.d:271
msgid "Ok, No error"
msgstr "Vale, sin errores"

# Sugerencia: Error de DJDOS. sv
#: errdjgpp.d:14
msgid "DJDOS error "
msgstr "Error de DJDOS "

#: errdjgpp.d:47 errunix.d:965
msgid "Function not implemented"
msgstr "Función no implementada"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
# "No existe ese archivo o directorio" - lsg
#
# Pues si, me gusta más la traducción de Leo, que la de Enrique, salvo
# que, tal y como tu mismo apuntas, Leo, se debe decir "fichero" y no
# "archivo" - cll
#
#: errdjgpp.d:51 errunix.d:57
msgid "No such file or directory"
msgstr "No existe ese fichero o directorio"

#: errdjgpp.d:55 errunix.d:237
msgid "Not a directory"
msgstr "No es un directorio"

#: errdjgpp.d:59 errunix.d:277
msgid "Too many open files"
msgstr "Demasiados ficheros abiertos"

#: errdjgpp.d:63 errunix.d:167
msgid "Permission denied"
msgstr "Permiso denegado"

#: errdjgpp.d:67 errunix.d:127
msgid "Bad file number"
msgstr "Número de fichero incorrecto"

#: errdjgpp.d:71
msgid "Memory control blocks destroyed"
msgstr "Bloques de control de memoria destruídos"

#: errdjgpp.d:75 errunix.d:157
msgid "Not enough memory"
msgstr "No hay memoria suficiente"

#: errdjgpp.d:79
msgid "Invalid memory address"
msgstr "Dirección de memoria inválida"

#: errdjgpp.d:83
msgid "Invalid environment"
msgstr "Entorno inválido"

#: errdjgpp.d:88
msgid "Invalid access code"
msgstr "Código de acceso inválido"

#: errdjgpp.d:93 errunix.d:227
msgid "No such device"
msgstr "No existe tal dispositivo"

#: errdjgpp.d:97
msgid "Attempt to remove the current directory"
msgstr "Intento de borrar el directorio actual"

#: errdjgpp.d:101
msgid "Can't move to other than the same device"
msgstr "No se puede cambiar de dispositivo"

#: errdjgpp.d:105
msgid "No more files"
msgstr "No más ficheros"

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# ¡¡¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#: errdjgpp.d:109 errunix.d:257
msgid "Invalid argument"
msgstr "Argumento inválido"

#: errdjgpp.d:113 errunix.d:107
msgid "Arg list too long"
msgstr "Lista de argumentos demasiado larga"

#: errdjgpp.d:117 errunix.d:117
msgid "Exec format error"
msgstr "Formato de programa no ejecutable"

#: errdjgpp.d:121 errunix.d:217
msgid "Cross-device link"
msgstr "Enlace cruzado entre dispositivos"

#: errdjgpp.d:127 errunix.d:368
msgid "Argument out of domain"
msgstr "Argumento fuera del dominio"

#
# "El resultado es demasiado grande" - lsg
#
# Si, ya he cambiado `largo' por `grande' en todos los mensajes. Un
# fallo realmente infantil :( - cll
#
#: errdjgpp.d:131 errunix.d:378
msgid "Result too large"
msgstr "El resultado es demasiado grande"

#: errdjgpp.d:135 errunix.d:207
msgid "File exists"
msgstr "El fichero ya existe"

#: errunix.d:47
msgid "Operation not permitted"
msgstr "Operación no permitida"

#: errunix.d:67
msgid "No such process"
msgstr "No existe tal proceso"

#: errunix.d:77
msgid "Interrupted system call"
msgstr "Llamada al sistema interrumpida"

# Sugerencia: E/S. sv
#
# Vaya, tu sugerencia es tan informática que me impresiona que se me
# haya escapado. cll
#
#: errunix.d:87
msgid "I/O error"
msgstr "Error de E/S"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:97
msgid "No such device or address"
msgstr "Dispositivo no configurado"

# Sugerencia: No hay ningún proceso hijo. sv
#
# Bueno, Enrique tradujo este mensaje como "Ningún proceso hijo" en libc
# asi que, si te parece bien, lo pondré como él puesto que lo suyo es
# una traducción ya aceptada y que además, resulta de mezclar lo que yo
# he puesto y de tu sugerencia. cll
#
#: errunix.d:137
msgid "No child processes"
msgstr "Ningún proceso hijo"

#: errunix.d:147
msgid "No more processes"
msgstr "No hay más procesos"

#: errunix.d:177
msgid "Bad address"
msgstr "Dirección incorrecta"

# Pongo esto un poco más en español.
# Antes decía "Dispositivo de bloque requerido".
# Por cierto, en otros sitios hemos puesto "dispositivo de bloques".
# ¿cómo es? sv
#: errunix.d:187
msgid "Block device required"
msgstr "Se requiere un dispositivo de bloque"

#: errunix.d:197
msgid "Device busy"
msgstr "Dispositivo ocupado"

#: errunix.d:247
msgid "Is a directory"
msgstr "Es un directorio"

#: errunix.d:267
msgid "File table overflow"
msgstr "Desbordamiento de la tabla de ficheros"

#: errunix.d:287
msgid "Inappropriate ioctl for device"
msgstr "El dispositivo no acepta la llamada `ioctl'"

#: errunix.d:297
msgid "Text file busy"
msgstr "Fichero de texto en uso"

#: errunix.d:307
msgid "File too large"
msgstr "Fichero demasiado grande"

#: errunix.d:317
msgid "No space left on device"
msgstr "No queda espacio en el dispositivo"

#: errunix.d:327
msgid "Illegal seek"
msgstr "Desplazamiento inválido"

#: errunix.d:337
msgid "Read-only file system"
msgstr "Sistema de ficheros de sólo lectura"

#: errunix.d:347
msgid "Too many links"
msgstr "Demasiados enlaces"

# Duda: pipe, todo el mundo sabe lo que es un pipe. Más aún, todo el mundo
#       conoce el mensaje `broken pipe'. Para no guiar a confusiones considero
#       que, excepcionalmente, se debe añadir la palabra pipe entre paréntesis,
#       con la intención de recordar al usuario lo que se quiere decir con
#       Tubería, ...
#
# Si en los cursillos de Unix se enseñara a los niños que esto | 
# es una tubería, no tendríamos que andar haciendo estas tonterías.
# Voto por eliminarlas de una vez por todas.
# "Tubería rota". sv
#
# Precisamente en estos días se discute esto mismo en la lista es@li.org
# (todavía no he enviado mi mensaje con mi opinión, pero lo haré,
# ...). La verdad es que creo que tienes razón. Sin ser exagerados y
# "eliminar de una vez por todas", creo que, en este caso, hay que
# arriesgarse y tirar p'alante, ¿no? ¡¡pues eso!! ¡¡¡"Tuberías rotas" al
# poder!!! - cll
#
#: errunix.d:357
msgid "Broken pipe"
msgstr "Tubería rota"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:389
msgid "Operation would block"
msgstr "La operación se bloquearía"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:399
msgid "Operation now in progress"
msgstr "Operación en curso"

# Already sería "ya". aún sería still.
# Sugerencia: La operación ya se está realizando. sv
#
# Más aún, echando un ojo a la traducción de Enrique Melero en el glibc,
# me he encontrado con el mismo mensaje y el dice: "La operación ya se
# está llevando a cabo". Me gusta bastante. cll
#
#: errunix.d:409
msgid "Operation already in progress"
msgstr "La operación ya se está llevando a cabo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:420
msgid "Too many levels of symbolic links"
msgstr "Demasiados niveles de enlaces simbólicos"

#: errunix.d:430
msgid "File name too long"
msgstr "Nombre de fichero demasiado largo"

#: errunix.d:440
msgid "Directory not empty"
msgstr "El directorio no está vacío"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:451
msgid "Stale NFS file handle"
msgstr "Fichero NFS bloqueado"

# Duda: Aquí he seguido el consejo de Enrique Melero.
#
# En la versión 1.5 he decidido cambiar el término `camino' por
# `trayectoria', tal y como recomiendan los traductores del libro Lisp,
# (3ra edición) de Winston y Horn en el "Vocabulario bilingüe de
# términos técnicos", en la página 650.
#
#: errunix.d:461
msgid "Too many levels of remote in path"
msgstr "Demasiados niveles de profundidad en la trayectoria"

#: errunix.d:472
msgid "Socket operation on non-socket"
msgstr "Operación de `sockets' sobre un \"no-socket\""

#: errunix.d:482
msgid "Destination address required"
msgstr "Se necesita la dirección del destino"

#: errunix.d:492
msgid "Message too long"
msgstr "Mensaje demasiado largo"

#: errunix.d:502
msgid "Protocol wrong type for socket"
msgstr "Tipo de protocolo incorrecto para el `socket'"

#: errunix.d:512
msgid "Option not supported by protocol"
msgstr "Opción no soportada por el protocolo"

#: errunix.d:522
msgid "Protocol not supported"
msgstr "Protocolo no soportado"

#: errunix.d:532
msgid "Socket type not supported"
msgstr "Tipo de `socket' no soportado"

# Pongo `socket' en vez de socket. sv
#: errunix.d:542
msgid "Operation not supported on socket"
msgstr "Acción no permitida en un `socket'"

#: errunix.d:552
msgid "Protocol family not supported"
msgstr "Familia de protocolos no soportada"

#: errunix.d:562
msgid "Address family not supported by protocol family"
msgstr "Familia de direcciones no soportada por el protocolo"

#: errunix.d:572
msgid "Address already in use"
msgstr "Dirección en uso"

# Sugerencia: No se puede asignar. sv
#
# ¡Vale!, "No puede asignarse ..." es demasiado, ..., ¿impersonal? cll
#: errunix.d:582
msgid "Can't assign requested address"
msgstr "No se puede asignar la dirección requerida"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#: errunix.d:592
msgid "Network is down"
msgstr "La red no está operativa"

#: errunix.d:602
msgid "Network is unreachable"
msgstr "No es posible conectarse con la red"

#: errunix.d:612
msgid "Network dropped connection on reset"
msgstr "Se ha perdido la conexión con la red debido a una reinicialización"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#: errunix.d:622
msgid "Software caused connection abort"
msgstr "El software ha provocado la interrupción de la conexión"

#: errunix.d:632
msgid "Connection reset by peer"
msgstr "Conexión reinicializada por el otro extremo"

#
# Duda: ¿Y buffer? ¿Como traduzco buffer?
#
# Yo he visto a menudo 'memoria tampón', que es el término usado por los
# franceses. - lsg
#
# Tienes toda la razón, ... Sin embargo, en este caso, la traducción
# francesa es:
#
# "Pas d'espace disponible pour un buffer"
#
# Además, como en spanglish.txt pone:
#
# "buffer - memoria intermedia, tampón, buffer"
#
# pues he utilizado `buffer' tal cual, ... - cll
#
#: errunix.d:642
msgid "No buffer space available"
msgstr "No queda espacio en el buffer"

# Lo de socket, si te parece. sv
#
# Te digo lo mismo que te dije antes. Cuando hay finalizado con la
# traducción me pondré a cambiar todas estas cosas con macros. cll
#
#: errunix.d:652
msgid "Socket is already connected"
msgstr "El `socket' ya está conectado"

#: errunix.d:662
msgid "Socket is not connected"
msgstr "El `socket' no está conectado"

# Añado comitas a `socket'. Es una especie de convenio que seguimos
# cuando no nos queda más remedio que poner la palabra inglesa.
# Así al menos reconocemos que es una palabra extraña. sv
#: errunix.d:672
msgid "Can't send after socket shutdown"
msgstr "No se puede enviar después de la ruptura del `socket'"

# Duda: ¿ Se excedió el tiempo para la conexión ?
#: errunix.d:690
msgid "Connection timed out"
msgstr "Se excedió el tiempo para la conexión"

#: errunix.d:700
msgid "Connection refused"
msgstr "Conexión rechazada"

# Estas dos darán que hablar, pero otro día las discutiremos... sv
#
# Al decir tú eso, he leído la traducción de este término en libc
# (traducido por Enrique Melero) y, madre mía, me he quedado
# "flipao". Aquello fue una discusión encarnizada, ...
#
# Para mas inri, yo no estoy de acuerdo con ninguno de los dos :) Verás,
# un host puede estar "caído" (que así es como se suele decir aunque es,
# evidentemente, incorrecto) y por ello no tiene por qué no estar
# operativo (en libc lo habeis traducido como "el `host' no está
# operativo"). De hecho, puede estar operando pero, por algún problema
# de la red o de tu propia transmisión, resultar inalcanzable, ... En
# fin, por este motivo prefiero "El `host' no está disponible"
#
# Por otra parte, no estoy muy de acuerdo con Enrique, ..., a mí lo de
# poner host no me gusta. Ciertamente, un `host' no tiene por qué ser un
# servidor, necesariamente, pero es el caso más común. En cualquier
# caso, todo el mundo comprende perfectamente que el `host' es un
# servidor. cll
#
#: errunix.d:716
msgid "Host is down"
msgstr "El servidor no está disponible"

# Aquí, pues idem de idem, ... :) cll
#
#: errunix.d:726
msgid "Host is unreachable"
msgstr "No se puede conectar con el servidor"

#: errunix.d:743
msgid "Too many processes"
msgstr "Demasiados procesos"

#: errunix.d:753
msgid "Too many users"
msgstr "Demasiados usuarios"

#: errunix.d:763
msgid "Disk quota exceeded"
msgstr "Cuota de disco excedida"

#: errunix.d:774
msgid "Not a stream device"
msgstr "No es un dispositivo de flujo"

#: errunix.d:784
msgid "Timer expired"
msgstr "El temporizador expiró"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:794
msgid "Out of stream resources"
msgstr "Alcanzado el límite de recursos de `streams'"

#: errunix.d:804
msgid "No message of desired type"
msgstr "No hay mensajes del tipo deseado"

#: errunix.d:814
msgid "Not a data message"
msgstr "No es un mensaje de datos"

#: errunix.d:825
msgid "Identifier removed"
msgstr "Identificador desechado"

# Duda: Eso del `inter-bloqueo' ¿estará bien?
#
#: errunix.d:836
msgid "Resource deadlock would occur"
msgstr "Podría ocurrir un interbloqueo entre recursos"

# Duda: Aunque Bruno Haible me ha asegurado que la etiqueta
# sys_errlist[ENOLCK] del glibc.po en español contiene la traduccion que
# yo debiera usar, me he decidido por las indicaciones de Santiago Vila
# en su respuesta a mi mail y he puesto, simplemente: "No quedan
# registros de bloqueo disponibles"
#
#: errunix.d:846
msgid "No record locks available"
msgstr "No quedan registros de bloqueo disponibles"

#: errunix.d:857
msgid "Machine is not on the network"
msgstr "La máquina no está en la red"

#: errunix.d:867 errunix.d:877
msgid "Object is remote"
msgstr "El objeto es remoto"

#: errunix.d:887
msgid "Link has been severed"
msgstr "El enlace ha sido destruído"

#: errunix.d:897
msgid "Advertise error"
msgstr "Error de anuncio"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:907
msgid "Srmount error"
msgstr "Error de `srmount'"

#: errunix.d:917
msgid "Communication error on send"
msgstr "Error de comunicaciones en el envío"

#: errunix.d:927
msgid "Protocol error"
msgstr "Error de protocolo"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:937
msgid "Multihop attempted"
msgstr "Se ha intentado un multihop"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#: errunix.d:954
msgid "Remote address changed"
msgstr "La dirección remota ha cambiado"

#: errunix.d:976
msgid "Not supported under MS-DOS"
msgstr "No soportado en MS-DOS"

#: errunix.d:1004
msgid "UNIX error "
msgstr "Error de Unix "

# Cambio librería por el término oficial. sv
#
# Uuuffffff, ..., aquí sí que podríamos discutir hasta la muerte. Pero
# bueno, se queda como tú lo has puesto. cll
#
#: errunix.d:1010
msgid "UNIX library error "
msgstr "Error de biblioteca Unix "

#: errwin32.d:3865
msgid "Win32 error "
msgstr "Error de Win32 "

#: errwin32.d:3897
msgid "Winsock error "
msgstr "Error de `winsock'"

#: misc.d:40
msgid "This file was produced by another lisp version, must be recompiled."
msgstr "Este fichero fue producido por otra versión de lisp. Debe recompilarse."

#: misc.d:295
msgid "~: type of attribute ~ is unsupported"
msgstr "~: el tipo de atributo ~ no está soportado"

#: predtype.d:935 predtype.d:1107
msgid "~: unidentifiable type!!!"
msgstr "~: ¡¡¡tipo irreconocible!!!"

#: predtype.d:1117
msgid "~: type ~ does not correspond to a class"
msgstr "~: el tipo ~ no se corresponde con una clase"

#: predtype.d:1169
msgid "~: ~ does not name a class"
msgstr "~: ~ no es el nombre de una clase"

#: predtype.d:1436
msgid "~: bad type specification ~"
msgstr "~: especificación de tipo incorrecta ~"

#: predtype.d:1446
msgid "~: ~ cannot be coerced to type ~"
msgstr "~: ~ no puede convertirse al tipo ~"

#: symbol.d:32
msgid "~: ~ is a macro, not a function"
msgstr "~: ~ es una macro, no una función"

#: symbol.d:51
msgid "~: the property list of ~ has an odd length"
msgstr "~: la lista de propiedades de ~ tiene longitud impar"

#: symbol.d:108
msgid "SETF SYMBOL-FUNCTION: ~ is not a function"
msgstr "SETF SYMBOL-FUNCTION: ~ no es una función"

#: symbol.d:133
msgid "~: ~ is not a system function"
msgstr "~: ~ no es una función del sistema"

#: symbol.d:186 symbol.d:226
msgid "~: the property list ~ has an odd length"
msgstr "~: la lista de propiedades ~ tiene longitud impar"

#: intlog.d:526 symbol.d:398
msgid "~: index ~ is negative"
msgstr "~: el índice ~ es negativo"

#: symbol.d:413
msgid "~: invalid argument ~"
msgstr "~: el argumento ~ es inválido"

#: symbol.d:429
msgid "The value of *GENSYM-COUNTER* was not a nonnegative integer. Old value ~. New value ~."
msgstr "El valor de *GENSYM-COUNTER* no era un entero no negativo. Valor anterior ~. Nuevo valor ~."

#: lisparit.d:334
msgid "argument to ~ should be a number: ~"
msgstr "el argumento de ~ debe ser un número: ~"

#: lisparit.d:352
msgid "argument to ~ should be a real number: ~"
msgstr "el argumento de ~ debe ser un número real: ~"

#: lisparit.d:370
msgid "argument to ~ should be a floating point number: ~"
msgstr "el argumento de ~ debe ser un número en coma flotante: ~"

#: lisparit.d:388
msgid "argument to ~ should be a rational number: ~"
msgstr "el argumento de ~ debe ser un número racional: ~"

#: lisparit.d:406
msgid "argument to ~ should be an integer: ~"
msgstr "el argumento de ~ debe ser un entero: ~"

#: lisparit.d:424
msgid "~: argument should be a positive fixnum, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo FIXNUM, no ~"

#: lisparit.d:1668
msgid "~: argument should be a random-state, not ~"
msgstr "~: el argumento debe ser un estado aleatorio, no ~"

#: lisparit.d:1686
msgid "~: the value of ~ should be a random-state, not ~"
msgstr "~: el valor de ~ debe ser un RANDOM-STATE, no ~"

#: lisparit.d:1708
msgid "~: argument should be positive and an integer or float, not ~"
msgstr "~: el argumento debe ser un número positivo del tipo INTEGER o FLOAT, no ~"

#: lisparit.d:1791
msgid "~ : argument should be a fixnum >=0, not ~"
msgstr "~ : El argumento debe ser del tipo FIXNUM >=0 y no ~"

#: aridecl.d:356
msgid "stack overflow during bignum arithmetic"
msgstr "desbordamiento de la pila durante la realización de operaciones aritméticas con números grandes"

#: aridecl.d:421
msgid "division by zero"
msgstr "división entre cero"

#: aridecl.d:433
msgid "floating point overflow"
msgstr "desbordamiento de coma flotante"

# Duda: Lo del desbordamiento inferior de coma flotante ha sido
# traducción super libre mía ;) Este mensaje ocurre cuando el resultado
# (expresado en coma flotante) ocurre mucho más cerca del cero de lo que
# permite la representación de números en coma flotante. Por ejemplo:
# 2.3e-30 * 2.3e-30 sería 5.29e-60 que excedió el límite inferior.
#
#: aridecl.d:445
msgid "floating point underflow"
msgstr "desbordamiento inferior de coma flotante"

#: intelem.d:205 intelem.d:293
msgid "not a 32-bit integer: ~"
msgstr "no es un entero de 32 bits: ~"

#: intelem.d:380 intelem.d:518
msgid "not a 64-bit integer: ~"
msgstr "no es un entero de 64 bits: ~"

#: intelem.d:1420
msgid "bignum overflow"
msgstr "desbordamiento de números grandes"

#: intlog.d:406
msgid "~: ~ is not a valid boolean operation"
msgstr "~: ~ no es una operación lógica válida"

#: intlog.d:651
msgid "~: too large shift amount ~"
msgstr "~: el tamaño del desplazamiento es muy grande ~"

# Duda: En Lisp existe un tipo predeterminado: `fixnum'. Por ese motivo,
# dejo sin traducir este término.
#
#: intbyte.d:15
msgid "The arguments to BYTE must be fixnums >=0: ~, ~"
msgstr "Los argumentos de BYTE deben ser números enteros del tipo FIXNUM >=0: ~, ~"

#: intbyte.d:42
msgid "~ is not a BYTE specifier"
msgstr "~ no es un especificador de BYTE"

#: intmal.d:7
msgid "overflow during multiplication of large numbers"
msgstr "desbordamiento durante la multiplicación de números grandes"

#: intdiv.d:342
msgid "quotient ~ / ~ is not an integer"
msgstr "el cociente ~ / ~ no es un entero"

#: intsqrt.d:390
msgid "~ applied to negative number ~"
msgstr "~ aplicado al número negativo ~"

# Duda: long-float es un tipo, así que lo dejo como `LONG-FLOAT'. Aunque
# Bruno Haible y Marcus Daniels lo han puesto como `long float' se
# refieren al tipo `long-float'
# Sugerencia: `long float'. sv
#
# No estoy de acuerdo con la sugerencia. No se trata de que `long' sea
# un adjetivo de `float', sino que en CLisp existe el tipo "long-float"
# (Common Lisp The Language, 2nd edition, Guy L. Steele, pag. 39). De
# hecho, en muchos otros sitios de CLisp se pone "long-float". Más aún,
# la traducción francesa de este mensaje es: "LONG-FLOAT trop long".
#
# De hecho, en mi opinion, Bruno Haible y Marcus Daniels se equivocaron
# aquí y debían haber puesto el guión. cll
#
#: lfloat.d:7
msgid "long float too long"
msgstr "LONG-FLOAT demasiado largo"

#: flo_konv.d:448
msgid "floating point NaN occurred"
msgstr "aparición de NaN en coma flotante"

# Duda: ¿alguien sabe qué es eso de ARexx?
#
#: rexx.d:33
msgid "Communication with ARexx isn't possible."
msgstr "La comunicación con ARexx no es posible."

#
# Siguiendo con las recomendaciones de Santiago y de "spanglish",
# `command' será `orden' - cll
#
#: rexx.d:113
msgid "~ must be a string for commands or a vector of strings for a function"
msgstr "~ debe ser una cadena para órdenes o un vector de cadenas para una función"

#: rexx.d:125
msgid "~: an ARexx function must have 0 to ~ arguments: ~"
msgstr "~: Una función ARexx debe tener entre 0 y ~ argumentos: ~"

#: rexx.d:142
msgid "~: must be a string for ARexx: ~"
msgstr "~: debe ser una cadena para ARexx: ~"

#: rexx.d:166
msgid "Only NIL, T and strings are accepted for ~S : ~"
msgstr "~S sólo acepta NIL, T y cadenas de caracteres: ~"

#: rexx.d:458
msgid "~: Not a Fixnum: ~"
msgstr "~: No es del tipo Fixnum: ~"

#: rexx.d:473
msgid "~: Not an incoming Rexx message: ~"
msgstr "~: No es un nuevo mensaje Rexx: ~"

#: affi.d:82
msgid "~: Unsupported call mechanism: ~"
msgstr "~: mecanismo de llamado no soportado: ~"

#: affi.d:95
msgid "~: Bad function prototype: ~"
msgstr "~: Prototipo de función incorrecto: ~"

#: affi.d:108
msgid "~: Wrong number of arguments for prototype ~"
msgstr "~: número incorrecto de argumentos para el prototipo ~"

#: affi.d:124
msgid "~: Bad argument for prototype ~: ~"
msgstr "~: Argumento incorrecto para el prototipo ~: ~"

#: affi.d:137
msgid "~: Bad argument: ~"
msgstr "~: El argumento ~ es inválido"

#: affi.d:159
msgid "~: ~ is not a valid address"
msgstr "~: ~ no es una dirección válida"

#: graph.d:445 graph.d:2762
msgid "graphics not initialized"
msgstr "los gráficos no han sido inicializados"

#: graph.d:3692
msgid "~: cannot switch to graphics mode"
msgstr "~: no es posible conmutar al modo gráfico"

#: foreign.d:26
msgid "~ comes from a previous Lisp session and is invalid"
msgstr "~ proviene de una sesion anterior de Lisp y es inválido"

#: foreign.d:98
msgid "A foreign variable ~ already exists"
msgstr "La variable extranjera ~ ya existe"

# Duda: he traducido `foreign' por `ajeno/a'.
#
# Lo he pensado mejor y `extranjera' me gusta mucho más, ..., ¿qué os
# parece? cll
#
#: foreign.d:140
msgid "A foreign function ~ already exists"
msgstr "La función extranjera ~ ya existe"

#: foreign.d:184
msgid "illegal foreign data type ~"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign.d:200
msgid "~ cannot be converted to the foreign type ~"
msgstr "~ no puede ser compartido al tipo extranjero ~"

#: foreign.d:215
msgid "64 bit integers are not supported on this platform and with this C compiler: ~"
msgstr "los enteros de 64 bits no están soportados en esta arquitectura, para este compilador de C:"

#: foreign.d:357 foreign.d:509
msgid "~ cannot be converted to a foreign function with another calling convention."
msgstr "~ no puede ser convertido a una función extranjera con otra convención de llamada."

#: foreign.d:556
msgid "No more room for foreign language interface"
msgstr "No queda espacio para el interfaz con otros lenguajes"

#: foreign.d:567
msgid ":MALLOC-FREE is not available under AMIGAOS."
msgstr ":MALLOC-FREE no está disponible en AMIGAOS."

#: foreign.d:1089 foreign.d:1151 foreign.d:1297 foreign.d:1336
msgid "element type has size 0: ~"
msgstr "el tipo del elemento tiene tamaño 0: ~"

#: foreign.d:2059
msgid "~: argument is not a foreign variable: ~"
msgstr "~: el argumento no es una variable extranjera: ~"

#: foreign.d:2071
msgid "~: foreign variable with unknown type, missing DEF-C-VAR: ~"
msgstr "~: variable externa de tipo desconocido, se ha omitido DEF-C-VAR: ~"

#: foreign.d:2087
msgid "A foreign variable ~ does not exist"
msgstr "La variable extranjera ~ no existe"

#: foreign.d:2102
msgid "~: foreign variable ~ does not have the required size or alignment"
msgstr "~: la variable externa ~ no tiene el tamaño o alineamiento requerido"

#: foreign.d:2119
msgid "~: type specifications for foreign variable ~ conflict: ~ and ~"
msgstr "~: conflicto de especificación de tipo de la variable extranjera ~: ~ y ~"

#: foreign.d:2165
msgid "~: foreign variable ~ may not be modified"
msgstr "~: no se puede modificar la variable externa ~"

#: foreign.d:2221
msgid "~: foreign variable ~ of type ~ is not an array"
msgstr "~: la variable externa ~ del tipo ~ no es una matriz"

#: foreign.d:2316
msgid "~: foreign variable ~ of type ~ is not a pointer"
msgstr "~: la variable externa ~ del tipo ~ no es un puntero"

#: foreign.d:2419
msgid "~: foreign variable ~ of type ~ is not a struct or union"
msgstr "~: la variable externa ~ del tipo ~ no es, ni una estructura, ni una unión"

#: foreign.d:2431
msgid "~: foreign variable ~ of type ~ has no component with name ~"
msgstr "~: la variable externa ~ del tipo ~ no tiene ningún componente con el nombre ~"

#: foreign.d:2496 foreign.d:3579
msgid "~: foreign variable ~ does not have the required alignment"
msgstr "~: la variable externa ~ no tiene el alineamiento requerido"

#: foreign.d:2514
msgid "~: argument is not a foreign function: ~"
msgstr "~: el argumento no es una función extranjera: ~"

#: foreign.d:2527
msgid "~: foreign function with unknown calling convention, missing DEF-CALL-OUT: ~"
msgstr "~: función externa con convención de llamada desconocida, se ha omitido DEF-CALL-OUT: ~"

#: foreign.d:2547 foreign.d:3605
msgid "~: illegal foreign function type ~"
msgstr "~: tipo de función externa inválido ~"

#: foreign.d:2558
msgid "~: A foreign function ~ does not exist"
msgstr "~: La función extranjera ~ no existe"

#: foreign.d:2568
msgid "~: calling conventions for foreign function ~ conflict"
msgstr "~: conflicto en la convención de llamada de la función externa ~"

#: foreign.d:2841
msgid "~: Too few arguments (~ instead of at least ~) to ~"
msgstr "~: Muy pocos argumentos (~ en vez de, al menos, ~) para ~"

#: foreign.d:2855
msgid "~: :OUT argument is not a pointer: ~"
msgstr "~: el argumento :OUT no es un puntero: ~"

#: foreign.d:2901
msgid "~: Too many arguments (~ instead of ~) to ~"
msgstr "~: Demasiados argumentos (~ en vez de ~) para ~"

#: foreign.d:3463
msgid "~: Cannot open library ~"
msgstr "~: No se puede abrir la biblioteca ~"

#: foreign.d:3552
msgid "~: ~ is not a library"
msgstr "~: ~ no es una biblioteca"

#: init.lsp:335
msgid "~S is a special form and may not be redefined."
msgstr "~S es una forma especial y por ello, no puede ser redefinida"

#: clos.lsp:215 init.lsp:343
msgid "The old definition will be lost"
msgstr "Se perderá la definición anterior."

#: init.lsp:346
msgid "Redefining the COMMON LISP ~A ~S"
msgstr "La ~A de COMMON LISP ~S será redefinida"

# Junto las ¡! sv
# Sugerencia "¡Se estaba trazando!" (es como más "en español") sv
#
# Sí, tu sugerencia me gusta. Como se nota que tienes experiencia, ...,
# ¿eh? cll
#
#: init.lsp:364
msgid "DEFUN/DEFMACRO: redefining ~S; it was traced!"
msgstr "DEFUN/DEFMACRO: redefiniendo ~S; ¡se estaba rastreando!"

#: init.lsp:386
msgid "~S is impossible in compiled code"
msgstr "~S es imposible en código compilado"

#: init.lsp:470
msgid "~S is an invalid function environment"
msgstr "~S es un entorno de función inválido"

#: init.lsp:519
msgid "~S is an invalid variable environment"
msgstr "~S es un entorno de variable inválido"

#: init.lsp:586
msgid "~S: ~S is illegal since ~S is a local macro"
msgstr "~S: ~S es inválido, puesto que ~S es una macro local"

#: init.lsp:592
msgid "~S: invalid function environment ~S"
msgstr "~S: ~S es un entorno de función inválido"

#: init.lsp:600
msgid "~S: ~S is invalid since ~S is not a symbol"
msgstr "~S: ~S es incorrecto, puesto que ~S no es un símbolo"

#: init.lsp:776
msgid "code after MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de MACROLET contiene una lista punteada que termina con ~S"

#: init.lsp:794
msgid "illegal syntax in MACROLET: ~S"
msgstr "sintaxis inválida en MACROLET: ~S"

#: init.lsp:805
msgid "code after SYMBOL-MACROLET contains a dotted list, ending with ~S"
msgstr "el código después de SYMBOL-MACROLET contiene una lista punteada que termina con ~S"

#: init.lsp:823
msgid "illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "sintaxis inválida en SYMBOL-MACROLET: ~S"

#: init.lsp:863
msgid "bad function environment occurred in ~S: ~S"
msgstr "se encontró un entorno de función incorrecto en ~S: ~S"

#: init.lsp:874
msgid "~S: invalid form ~S"
msgstr "~S: forma inválida ~S"

#: init.lsp:887
msgid "code contains a dotted list, ending with ~S"
msgstr "el código contiene una lista punteada que termina con ~S"

#: init.lsp:930
msgid "~S: ~S should be a lambda expression"
msgstr "~S: ~S debe ser una expresión lambda"

#: init.lsp:973
msgid "lambda list must not end with the atom ~S"
msgstr "la lista lambda no debe terminar con el átomo ~S"

#: init.lsp:1007 init.lsp:1026
msgid "~S: variable list ends with the atom ~S"
msgstr "~S: la lista de variables termina con el átomo ~S"

#: init.lsp:1141
msgid "FLET/LABELS: code contains a dotted list, ending with ~S"
msgstr "FLET/LABELS: el código contiene una lista punteada que termina con ~S"

#: init.lsp:1152
msgid "illegal syntax in FLET/LABELS: ~S"
msgstr "sintaxis inválida en FLET/LABELS: ~S"

#: init.lsp:1282
msgid ";; Loading file "
msgstr ";; Cargando el fichero \""

#: init.lsp:1287
msgid " ..."
msgstr " ..."

#: init.lsp:1313
msgid ";; Loading of file "
msgstr ";; La carga del fichero "

# Nota: `is finished' debería traducirse por `está finalizado' o `está
#       finalizada'. Sin embargo, esta parte se compondrá con otras
#       donde la traducción `ha finalizado' sigue siendo igualmente válida y,
#       además, nos evitamos la utilización de una forma eminentemente
#       masculina o fememina.
#
#: init.lsp:1318
msgid " is finished."
msgstr " ha finalizado."

#: init.lsp:1327
msgid "A file with name ~A does not exist"
msgstr "No existe ningún fichero con el nombre ~A"

#: init.lsp:1343
msgid "~S: missing function name and/or parameter list"
msgstr "~S: no se ha indicado el nombre de la función y/o la lista de parámetros"

#: init.lsp:1353
msgid "~S: ~S is not a symbol."
msgstr "~S: ~S no es un símbolo."

#: init.lsp:1360
msgid "~S: special form ~S cannot be redefined."
msgstr "~S: la forma especial ~S no puede ser redefinida."

#: init.lsp:1407 macros1.lsp:160
msgid "exit clause in ~S must be a list"
msgstr "la cláusula exit en ~S debe ser una lista"

#: init.lsp:1560
msgid "~S: cannot define a function from that: ~S"
msgstr "~: no es posible definir una función a partir de ~S"

#: clos.lsp:3073 clos.lsp:3134 init.lsp:1567
msgid "~S: the name of a function must be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: init.lsp:1574
msgid "~S: function ~S is missing a lambda list"
msgstr "~S: la función ~S debe tener una lista lambda"

# Duda: Aquí, igual que en el caso de la traducción francesa, he
# preferido preservar el término `backquote' y ---porque así se ha
# decidido en Spanish GNU Translation Team---, el término está con
# comillas simples.
#
# He tomado esta decisión porque el `backquote' (que es la tilde
# invertida `) es un término muy familiar para todos los programadores
# de Lisp que, con toda seguridad, conocerán.
#
#: backquot.lsp:39
msgid "~S: comma is illegal outside of backquote"
msgstr "~S: la coma es inválida fuera del `backquote'"

#: backquot.lsp:46
msgid "~S: more commas out than backquotes in, is illegal"
msgstr "~S: no se pueden emplear más comas fuera que apóstrofes invertidos dentro"

#: backquot.lsp:209
msgid "The syntax ,@form is valid only in lists"
msgstr "La sintaxis ,@forma es válida únicamente en las listas"

#: backquot.lsp:216
msgid "The syntax ,.form is valid only in lists"
msgstr "La sintaxis ,.forma es válida únicamente en las listas"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# A partir de la versión 1997-05-03, este mensaje ha cambiado y se
# refiere a elementos que serán ignorados. Como no puede anticiparse
# cual será el género del objeto que se ignora, he preferido poner lo de
# os/as. ¿Qué os parece?
#
#: defmacro.lsp:44
msgid "Both will be ignored."
msgstr "Ambos/as serán ignorados/as."

#: defmacro.lsp:47
msgid "Invalid keyword-value-pair: ~S ~S"
msgstr "Par argumento clave y valor inválido: ~S ~S"

#: defmacro.lsp:58
msgid "The macro ~S may not be called with ~S arguments"
msgstr "La macro ~S no puede ser invocada con ~S argumentos"

#: defmacro.lsp:131 defmacro.lsp:162 defmacro.lsp:327
msgid "The rest of the lambda list will be ignored."
msgstr "El resto de la lista lambda será ignorado."

#: defmacro.lsp:134
msgid "The lambda list of macro ~S contains a dot after &AUX."
msgstr "La lista lambda de la macro ~S contiene un punto después de &AUX"

#: defmacro.lsp:142
msgid "in macro ~S: ~S may not be used as &AUX variable."
msgstr "en la macro ~S: ~S no debe usarse como una variable &AUX."

#: defmacro.lsp:165
msgid "The lambda list of macro ~S contains a dot after &KEY."
msgstr "La lista lambda de la macro ~S contiene un punto después de &KEY"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
#: defmacro.lsp:176 defmacro.lsp:198 defmacro.lsp:418 defmacro.lsp:438 defmacro.lsp:447
msgid "It will be ignored."
msgstr "Será ignorado."

#: defmacro.lsp:179
msgid "The lambda list of macro ~S contains a badly placed ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S mal situado."

#: defmacro.lsp:201
msgid "The lambda list of macro ~S contains the invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene el elemento inválido ~S"

# Ojo con ignorar. sv
#
# Je, je, je, ... pareces un psicópata con lo de ignorar. A mí me parece
# muy razonable, ... ignorar es como olvidar que algo ocurre :) cll
#
# No tengo ni idea de qué significa ese "0*"
#: defmacro.lsp:233
msgid "~0*It will be ignored."
msgstr "Será ignorado."

#: defmacro.lsp:236
msgid "The lambda list of macro ~S contains an invalid keyword specification ~S"
msgstr "La lista lambda de la macro ~S contiene una especificación de argumento clave inválida: ~S"

#: defmacro.lsp:309
msgid "The lambda list of macro ~S is missing a variable after &REST/&BODY."
msgstr "La lista lambda de la macro ~S necesita una variable después de &REST/&BODY."

#: defmacro.lsp:316
msgid "The lambda list of macro ~S contains an illegal variable after &REST/&BODY: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable inválida después de &REST/&BODY: ~S"

#: defmacro.lsp:330
msgid "The lambda list of macro ~S contains a misplaced dot."
msgstr "La lista lambda de la macro ~S contiene un punto mal situado."

# Ojo. sv
#
# :) Vale :) cll
#
#: defmacro.lsp:337
msgid "They will be ignored."
msgstr "Serán ignorados."

#: defmacro.lsp:340
msgid "The lambda list of macro ~S contains superfluous elements: ~S"
msgstr "La lista lambda de la macro ~S contiene elementos innecesarios: ~S"

#: defmacro.lsp:395
msgid "The lambda list of macro ~S contains an illegal &REST variable: ~S"
msgstr "La lista lambda de la macro ~S contiene una variable &REST inválida: ~S"

#: defmacro.lsp:411
msgid "The lambda list of macro ~S contains an invalid &WHOLE: ~S"
msgstr "La lista lambda de la macro ~S contiene un &WHOLE inválido: ~S"

#: defmacro.lsp:421
msgid "The lambda list of macro ~S contains a superfluous ~S."
msgstr "La lista lambda de la macro ~S contiene un ~S innecesario."

#: defmacro.lsp:441
msgid "The lambda list of macro ~S contains ~S before &KEY."
msgstr "La lista lambda de la macro ~S contiene ~S antes de &KEY."

#: defmacro.lsp:450
msgid "The lambda list of macro ~S contains ~S which is illegal here."
msgstr "La lista lambda de la macro ~S contiene ~S, lo cual es incorrecto aquí."

#: defmacro.lsp:471
msgid "The lambda list of macro ~S contains an invalid element ~S"
msgstr "La lista lambda de la macro ~S contiene un elemento inválido: ~S"

#: defmacro.lsp:487
msgid "The lambda list of macro ~S contains an invalid supplied-variable ~S"
msgstr "La lista lambda de la macro ~S contiene una \"variable-proporcionada\" inválida ~S"

#: defmacro.lsp:551
msgid "In the lambda list of macro ~S, &ENVIRONMENT must be followed by a non-NIL symbol: ~S"
msgstr "En la lista lambda de la macro ~S, &ENVIRONMENT debe estar seguido de un símbolo no nulo: ~S"

#: defmacro.lsp:575
msgid "Cannot define a macro from that: ~S"
msgstr "No se puede definir una macro a partir de: ~S"

#: defmacro.lsp:582
msgid "The name of a macro must be a symbol, not ~S"
msgstr "El nombre de una macro debe ser un símbolo, no ~S"

#: defmacro.lsp:589
msgid "Macro ~S is missing a lambda list."
msgstr "La macro ~S necesita una lista lambda."

#: macros1.lsp:11 macros1.lsp:38
msgid "~S: non-symbol ~S can't be a variable"
msgstr "~S: sólo los símbolos pueden ser variables, y no ~S"

#: macros1.lsp:18 macros1.lsp:45
msgid "~S: the constant ~S must not be redefined to be a variable"
msgstr "~S: la constante ~S no debe redefinirse como una variable"

#: macros1.lsp:61
msgid "~S: non-symbol ~S can't be a defined constant"
msgstr "~S: ~S no es un símbolo, y por lo tanto no puede definirse como una constante"

#: macros1.lsp:96
msgid "~S redefines the constant ~S. Its old value was ~S."
msgstr "~S redefine la constante ~S. Su valor anterior era ~S."

#: macros1.lsp:167
#, fuzzy
msgid "Invalid syntax in ~S form: ~S."
msgstr "Sintaxis inválida en LET/LET*: ~S"

#: macros1.lsp:285 places.lsp:401 places.lsp:668
msgid "~S called with an odd number of arguments: ~S"
msgstr "~S ha sido invocado con un número impar de argumentos: ~S"

#: macros1.lsp:339
msgid "~S: missing key list"
msgstr "~S: falta la lista de claves"

#: macros1.lsp:348
msgid "~S: the ~S clause must be the last one"
msgstr "~S: la clausula ~S debe ser la última"

#: macros1.lsp:403 macros1.lsp:484
msgid "Not a list of COND clauses: ~S"
msgstr "No es una lista de cláusulas COND: ~S"

#: macros1.lsp:410 macros1.lsp:491
msgid "The atom ~S must not be used as a COND clause."
msgstr "El átomo ~S no debe usarse como una cláusula COND."

#: macros1.lsp:448
msgid "COND code contains a dotted list, ending with ~S"
msgstr "El código de COND contiene una lista punteada que termina con ~S"

#: compiler.lsp:7752 macros1.lsp:456
msgid "COND clause without test: ~S"
msgstr "Cláusula COND sin prueba condicional: ~S"

#: macros2.lsp:40
msgid "Language ~S is not defined"
msgstr "El lenguaje ~S no está definido"

#: macros2.lsp:52
msgid "Language ~S inherits from ~S"
msgstr "El lenguaje ~S hereda de ~S"

#: macros2.lsp:106
msgid "~S: Language ~S is not defined"
msgstr "~S: El lenguaje ~S no está definido"

#: macros2.lsp:131
msgid "~S ~S: no value for default language ~S"
msgstr "~S ~S: no hay ningún valor para el lenguaje por defecto ~S"

#: macros2.lsp:148
msgid "Invalid clause in ~S: ~S"
msgstr "Cláusula inválida en ~S: ~S"

#: macros2.lsp:169
msgid "~A~%The value is: ~S"
msgstr "~A~%El valor es: ~S"

#: macros2.lsp:175
msgid "The value of ~S should be ~:[of type ~S~;~:*~A~]."
msgstr "El valor de ~S debe ser ~:[del tipo ~S~;~:*~A~]."

#: macros2.lsp:181
msgid "You may input a new value."
msgstr "Puede introducir un nuevo valor."

#: macros2.lsp:186
msgid "~%New ~S: "
msgstr "~%Nuevo ~S: "

#: macros2.lsp:209
msgid "Retry"
msgstr "Reintentar"

#: macros2.lsp:214
msgid "You may input new values."
msgstr "Puede introducir nuevos valores."

#: macros2.lsp:220
msgid "~S must evaluate to a non-NIL value."
msgstr "~S no puede evaluarse como NIL."

#: macros2.lsp:258
msgid "The value of ~S must be of one of the types ~{~S~^, ~}"
msgstr "El valor de ~S debe ser de uno de los tipos ~{~S~^, ~}"

#: macros2.lsp:265
msgid "The value of ~S must be one of ~{~S~^, ~}"
msgstr "El valor de ~S debe ser uno de los siguientes ~{~S~^, ~}"

#: conditio.lsp:1296 macros2.lsp:283
msgid "~S used as a key in ~S, it would be better to use parentheses."
msgstr ""

#: macros2.lsp:371
msgid "type name should be a symbol, not ~S"
msgstr "el nombre del tipo debe ser un símbolo, no ~S"

#: macros2.lsp:378
msgid "~S is a built-in type and may not be redefined."
msgstr "~S es un tipo predefinido y no puede ser redefinido."

#: macros2.lsp:413
msgid "The deftype expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de DEFTYPE para ~S no puede invocarse con ~S argumentos."

#: defs1.lsp:327
msgid "~S: ~S does not name a logical host"
msgstr "~S: ~S no es el nombre de un anfitrión \"lógico\""

#: defs1.lsp:463
msgid "~S: argument ~S should be a nonnegative number"
msgstr "~S: el argumento ~S debe ser un número no negativo"

#: defs1.lsp:627
msgid "incorrect date: ~S.~S.~S, ~Sh~Sm~Ss, time zone ~S"
msgstr "fecha incorrecta: ~S/~S/~S, ~Sh~Sm~Ss, zona horaria ~S"

#: places.lsp:22
msgid "The function (~S ~S) is hidden by a SETF expander."
msgstr "Una función de expansión de SETF oculta a la función (~S ~S)"

#: places.lsp:78
msgid "The argument ~S to ~S should be a keyword."
msgstr "El argumento ~S de ~S debe ser un argumento clave."

# Lo mismo de antes. A lo mejor se puede poner "modificable setf". sv
#: places.lsp:133
msgid "Argument ~S is not a SETF place."
msgstr "El argumento ~S no es un lugar `setf' modificable"

#: places.lsp:145
msgid "SETF place ~S produces more than one store variable."
msgstr "El lugar `setf' ~ genera más de una variable de almacenamiento."

#: places.lsp:171 places.lsp:181
msgid "~S: first argument ~S is illegal, not a symbol"
msgstr "~S: el primer argumento ~S es inválido, no es un símbolo"

#: places.lsp:219
msgid "The name of the access function must be a symbol, not ~S"
msgstr "El nombre de la función de acceso debe ser un símbolo, no ~S"

# Duda: En esta y otras partes de este archivo .po aparece la expresión
# `expander' (¡expansor es horrible!). Me dio muchisimos quebraderos de
# cabeza, pero muchos y francamente, estaba absolutamente atascado
# cuando lo pregunté en las listas de Spanish GNU y CLisp.
#
# Curiosamente, la única persona que respondió no tiene ni idea de
# español (Bruno Haible):
#
# "expander" or "expansion function", I would say.
#
# ¡Pues leches, eso mismo! Función de expansión me suena
# perfectísimamente, ...
#
#: places.lsp:254
msgid "The SETF expander for ~S may not be called with ~S arguments."
msgstr "La función de expansión de SETF para ~S no puede invocarse con ~S argumentos."

#: places.lsp:288
msgid "Too many arguments to DEFSETF: ~S"
msgstr "Demasiados argumentos para DEFSETF: ~S"

#: places.lsp:294
msgid "The doc string to DEFSETF must be a string: ~S"
msgstr "La cadena de documentación de DEFSETF debe ser una cadena: ~S"

#: places.lsp:307
msgid "Missing store variable in DEFSETF."
msgstr "No se encuentra ninguna variable de almacenamiento en DEFSETF."

# Las variables que sobran no se tendrán en cuenta. sv
#
# ¡Si, señor! Esta es la segunda vez que me pillas `in fraganti'. Tu
# traducción es, en este caso, magistral. cll
#
# A propósito, en este caso te sales con la tuya y cambiamos ignorar por
# `no tener en cuenta' :) cll
#
#: places.lsp:311
msgid "The excess variables will be ignored."
msgstr "Las variables que sobran no se tendrán en cuenta."

#: places.lsp:314
msgid "Only one store variable is allowed in DEFSETF."
msgstr "Sólo se permite una variable de almacenamiento en DEFSETF."

#: places.lsp:357
msgid "Illegal syntax in DEFSETF for ~S"
msgstr "Sintaxis inválida en DEFSETF: ~S"

#: places.lsp:455
msgid "REMF: property list with an odd length"
msgstr "REMF: lista de propiedades de longitud impar"

#: places.lsp:511
msgid "In the definition of ~S: &REST variable ~S should be a symbol."
msgstr "En la definición de ~S: la variable &REST ~S debe ser un símbolo."

#: places.lsp:519
msgid "Only one variable is allowed after &REST, not ~S"
msgstr "Sólo se permite una variable después de &REST, no ~S"

#: places.lsp:526
msgid "Illegal in a DEFINE-MODIFY-MACRO lambda list: ~S"
msgstr "Lista lambda inválida en DEFINE-MODIFY-MACRO: ~S"

#: places.lsp:536
msgid "lambda list may only contain symbols and lists, not ~S"
msgstr "la lista lambda sólo puede contener símbolos y listas, no ~S"

# En cristiano creo que sería "Lugar SETF incorrecto". sv
#
# Sí, tienes razón. Creo que cuando traduje este mensaje llevaba
# demasiadas horas delante del ordenador, ... tienes razón, ... cll
#
#: places.lsp:660
msgid "Illegal SETF place: ~S"
msgstr "Lugar `setf' inválido: ~S"

#: places.lsp:683
msgid "SHIFTF called with too few arguments: ~S"
msgstr "SHIFTF ha sido llamado con muy pocos argumentos: ~S"

#: places.lsp:718
msgid "(SETF (NTH ...) ...) : index ~S is too large for ~S"
msgstr "(SETF (NTH ...) ...) : el índice ~S es demasiado grande para ~S"

#: places.lsp:792
msgid "(SETF (GETF ...) ...) : property list with an odd length"
msgstr "(SETF (GETF ...) ...) : lista de propiedades de longitud impar"

#: places.lsp:829
msgid "first argument ~S is illegal, not a symbol"
msgstr "el primer argumento ~S es inválido, no es un símbolo"

#: places.lsp:931
msgid "SETF APPLY is only defined for functions of the form #'symbol."
msgstr "SETF APPLY sólo está definido para funciones de la forma #'símbolo."

# Duda: en Common Lisp existe lo que se denominan los `setf places'. En
# realidad, es una manera bastante correcta de referirse a posiciones de
# memoria (cuyos nombres pueden ser variables, funciones, etc.) que son
# modificables con la primitiva SETF de Lisp. Por ello, traducirlo como
# `modificable' es eminentemente correcto, pero en realidad me da miedo
# porque a los programadores experimentados les mosqueará lo de
# `modificable' a secas. Les resultará mucho más familiar algo como
# `setf modificables', aunque en español esto suene bastante
# regular. cll
#
# En cualquier caso, cuando uno se empeña en emplear la palabra inglesa,
# siempre queda la posibilidad de conservar la sintaxis española,
# por ejemplo: "... no es un lugar modificable `setf'" sv
#
#: places.lsp:938
msgid "APPLY on ~S is not a SETF place."
msgstr "APPLY de ~S no es un lugar `setf' modificable"

#: places.lsp:995
msgid "SETF FUNCALL is only defined for functions of the form #'symbol."
msgstr "SETF FUNCALL sólo está definido para funciones de la forma #'símbolo."

#: floatpri.lsp:341
msgid "argument is not a float: ~S"
msgstr "el argumento no es un número en coma flotante: ~S"

#: type.lsp:30
msgid "~S: invalid type specification ~S"
msgstr "~S: la especificación de tipo ~S es inválida"

#: compiler.lsp:9139 type.lsp:59
msgid "~S: argument to SATISFIES must be a symbol: ~S"
msgstr "~S: el argumento de SATISFIES debe ser un símbolo: ~S"

#: compiler.lsp:8951 compiler.lsp:8963 type.lsp:264 type.lsp:275
msgid "~S: argument to ~S must be *, ~S or a list of ~S: ~S"
msgstr "~S: el argumento de ~S debe ser *, ~S o una lista de ~S: ~S"

#: compiler.lsp:9012 type.lsp:285
msgid "~S: argument to MOD must be an integer: ~S"
msgstr "~S: el argumento de MOD debe ser un entero: ~S"

#: compiler.lsp:9026 type.lsp:298
msgid "~S: argument to SIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de SIGNED-BYTE debe ser un entero o * : ~S"

#: compiler.lsp:9042 type.lsp:311
msgid "~S: argument to UNSIGNED-BYTE must be an integer or * : ~S"
msgstr "~S: el argumento de UNSIGNED-BYTE debe ser un entero o * : ~S"

#: type.lsp:469
msgid "Invalid type specifier ~S"
msgstr "Especificador de tipo inválido: ~S"

#: defstruc.lsp:63 foreign1.lsp:442
msgid "~S: this is not a symbol: ~S"
msgstr "~S: esto no es un símbolo: ~S"

#: defstruc.lsp:403
msgid "~S: invalid syntax for name and options: ~S"
msgstr "~S: la sintáxis del nombre y las opciones es inválida: ~S"

#: defstruc.lsp:429
msgid "~S ~S: argument list should be a list: ~S"
msgstr "~S ~S: la lista de argumentos debe ser una lista: ~S"

#: defstruc.lsp:454
msgid "~S ~S: At most one :INCLUDE argument may be specified: ~S"
msgstr "~S ~S: Sólo puede especificarse un argumento :INCLUDE como mucho: ~S"

#: defstruc.lsp:464
#, fuzzy
msgid ""
"~S: Use of ~S implicitly applies FUNCTION.~@\n"
"                                     Therefore using ~S instead of ~S."
msgstr ""
"~S: :PRINT-FUNCTION aplica, implícitamente, FUNCTION.~@\n"
"                                   Por lo tanto, se utilizará ~S en vez de ~S."

#: conditio.lsp:112 defstruc.lsp:481
msgid "~S ~S: unknown option ~S"
msgstr "~S ~S: opción ~S desconocida"

#: clos.lsp:3230 conditio.lsp:118 defstruc.lsp:487
msgid "~S ~S: invalid syntax in ~S option: ~S"
msgstr "~S ~S: la sintaxis de la opción ~S es inválida: ~S"

#: clos.lsp:3149 conditio.lsp:124 defstruc.lsp:493
msgid "~S ~S: not a ~S option: ~S"
msgstr "~S ~S: no se trata de una opción ~S: ~S"

# Duda: (y además gorda) Podría parecer que el siguiente mensaje debiera
# traducirse por:
#
# ~S ~S: No hay ningún :PREDICATE sobre estructuras sin nombre.
#
# Sin embargo, el manual "Common Lisp, The Language - 2nd Edition", en
# la página 477 advierte que, en realidad, la opción :PREDICATE no debe
# usarse con estructuras sin nombre:
#
# `A predicate can be defined only if the structure is "named"'
#
# Por lo tanto, he preferido traducir este mensaje de otra manera, tal y
# como veis:
#
#: defstruc.lsp:519
msgid "~S ~S: There is no :PREDICATE on unnamed structures."
msgstr "~S ~S: No puede definirse un :PREDICATE sobre estructuras sin nombre."

#: defstruc.lsp:547
msgid "~S ~S: invalid :TYPE option ~S"
msgstr "~S ~S: opción :TYPE inválida ~S"

#: defstruc.lsp:555
msgid "~S ~S: The :INITIAL-OFFSET must be a nonnegative integer, not ~S"
msgstr "~S ~S: El :INITIAL-OFFSET debe ser un entero no negativo, y no ~S"

#: defstruc.lsp:563
msgid "~S ~S: :INITIAL-OFFSET must not be specified without :TYPE : ~S"
msgstr "~S ~S: El :INITIAL-OFFSET no debe especificarse sin :TYPE : ~S"

#: defstruc.lsp:583
msgid "~S ~S: included structure ~S has not been defined."
msgstr "~S ~S: la estructura incluida ~S no ha sido definida."

#: defstruc.lsp:597
msgid "~S ~S: included structure ~S must be of the same type ~S."
msgstr "~S ~S: la estructura incluida ~S debe ser del tipo ~S."

#: defstruc.lsp:624
msgid "~S ~S: included structure ~S has no component with name ~S."
msgstr "~S ~S: la estructura incluida ~S no tiene ninguna componente con el nombre ~S."

#: defstruc.lsp:655
msgid "~S ~S: The READ-ONLY slot ~S of the included structure ~S must remain READ-ONLY in ~S."
msgstr "~S ~S: La ranura READ-ONLY ~S de la estructura incluida ~S debe permanecer READ-ONLY en ~S."

#: defstruc.lsp:667
msgid "~S ~S: The type ~S of slot ~S should be a subtype of the type defined for the included strucure ~S, namely ~S."
msgstr "~S ~S: El tipo ~S de la ranura ~S debe ser un subtipo del que ha sido definido para la estructura incluida ~S, a saber, ~S."

#: defstruc.lsp:675 defstruc.lsp:779
msgid "~S ~S: ~S is not a slot option."
msgstr "~S ~S: ~S no es una opción de ranura."

#: defstruc.lsp:709
msgid "~S ~S: structure of type ~S can't hold the name."
msgstr "~S ~S: una estructura del tipo ~S no puede contener el nombre."

#: defstruc.lsp:763
msgid "~S ~S: There may be only one slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura con el nombre ~S."

#: format.lsp:70
msgid "The control string terminates within a directive."
msgstr "La cadena de control termina en una directiva."

#: format.lsp:139
msgid "~A must introduce a number."
msgstr "~A debe introducir un número."

#: format.lsp:151
msgid "The control string terminates in the middle of a parameter."
msgstr "La cadena de control termina en medio de un parámetro."

#: format.lsp:233
msgid "Non-existent directive"
msgstr "Directiva no existente"

#: format.lsp:253
msgid "The closing directive '~A' does not have a corresponding opening one."
msgstr "No existe una directiva de apertura para la de cierre `~A'."

#: format.lsp:260
msgid "The closing directive '~A' does not match the corresponding opening one. It should read '~A'."
msgstr "La directiva de cierre `~A' no se corresponde con la de apertura. Debe leerse `~A'."

#: format.lsp:271 format.lsp:1751 format.lsp:2564
msgid "The ~~; directive is not allowed at this point."
msgstr "La directiva ~~; no está permitida aquí."

#: format.lsp:283
msgid "The ~~newline directive cannot take both modifiers."
msgstr "La directiva ~~newline no puede tomar ambos modificadores."

# Ojo: Estos "ing" no son siempre gerundios.
# Tal vez sea simplemente "...; se esperaba '~A'." sv
#
# Bueno, ..., cuando el mensaje ha salido es que se ha producido un
# error. En tal caso, no se puede estar `esper*ando*', sino que se
# esperaba, ... Si, creo que tienes toda la razón. cll
#
#: format.lsp:306
msgid "An opening directive is never closed; expecting '~A'."
msgstr "No se ha cerrado una directiva; se esperaba `~A'."

#: format.lsp:333
msgid "~%Current point in control string:"
msgstr "~%Posición en curso en la cadena de control:"

# Duda: `fill pointer' (puntero de llenado, o de relleno) es un
# recurso que existe en Common Lisp (y por lo tanto, en CLisp) para
# determinar qué parte de un vector está en uso (la que hay desde el
# principio hasta la posición apuntada por el `fill pointer'). Se trata
# de un término que cualquier programador en Lisp debe conocer porque
# esta palabra clave se utiliza en ocasiones, incluso, como palabra
# reservada para indicar una determinada opción en algunas funciones.
#
# Por ese motivo, he decidido dejarla tal cual, sin traducir. Cuando
# pregunté a Bruno Haible sobre esto me respondió:
#
# Imagine a device attached to a bottle or tank, which shows how much full
# the bottle is, in percent. How would you call this device?
#
# ... y francamente, ¡no se me ocurre como!
#
# Bueno, con el tiempo he decidido que (tal y como señala Bruno Haible)
# lo mejor sería: "puntero de relleno".
#
#: format.lsp:385
msgid "The destination string ~S should have a fill pointer."
msgstr "La cadena de destino ~S debe tener un puntero de relleno."

#: format.lsp:394
msgid "The destination argument ~S is invalid (not NIL or T or a stream or a string)."
msgstr "El argumento destino no es NIL, ni tampoco T, un flujo o una cadena: ~S"

#: format.lsp:425
msgid "~S: The control-string must be a string, not ~S"
msgstr "~S: La cadena de control debe ser una cadena, y no ~S"

#: format.lsp:438
msgid "There are not enough arguments left for this directive."
msgstr "No hay argumentos suficientes para esta directiva."

#: format.lsp:538
msgid "The ~~:@R directive requires an integer in the range 1 - 4999, not ~S"
msgstr "La directiva ~~:@R necesita un entero en el rango 1 - 4999, no ~S"

#: format.lsp:559
msgid "The ~~@R directive requires an integer in the range 1 - 3999, not ~S"
msgstr "La directiva ~~@R necesita un entero en el rango 1 - 3999, no ~S"

#: format.lsp:625
msgid "The argument for the ~~R directive is too large."
msgstr "El argumento de la directiva ~~R es demasiado grande."

#: format.lsp:1347
msgid "The ~~R and ~~:R directives require an integer argument, not ~S"
msgstr "Las directivas ~~R y ~~:R necesitan un argumento entero, no ~S"

#: format.lsp:1371
msgid "The ~~C directive requires a character argument, not ~S"
msgstr "La directiva ~~C necesita un carácter como argumento, no ~S"

# Duda: uufff!!! Keypad, keypad, ..., ¿Teclado auxiliar?
#
# A continuacion reproduzco la pregunta que formule en la lista de CLisp:
#
# > 2. When does the message "Keypad-" appear?. The Keypad is the set of
# > numeric keys that are at the left of the keyboard. But I need to know
# > with which kind of messages does it join to know how to translate it.
#
# Y la respuesta de Bruno Haible:
#
# In phrases like "Please press Keypad-Enter when done".
#
# Francamente, me parece que la utilizacion de Keypad, a secas, será lo
# mejor.
#
#
#: format.lsp:1449
msgid "Keypad-"
msgstr "Keypad-"

#: format.lsp:1661
msgid "The control string argument for the ~~? directive is invalid: ~S"
msgstr "La cadena de control de la directiva ~~? es inválida: ~S"

#: format.lsp:1668
msgid "The argument list argument for the ~~? directive is invalid: ~S"
msgstr "El argumento de la lista de argumentos de la directiva ~~? es inválido: ~S"

#: format.lsp:1682
msgid "No closing `/' in the format string `~a'"
msgstr ""

#: format.lsp:1695
#, fuzzy
msgid "No package named `~a' found"
msgstr "el paquete ~A"

#: format.lsp:1758
msgid "The ~~[ parameter must be an integer, not ~S"
msgstr "El parámetro para ~~[ debe ser un entero, no ~S"

#: format.lsp:1779
msgid "The ~~[ directive cannot take both modifiers."
msgstr "La directiva ~~[ no puede tomar ambos modificadores."

#: format.lsp:1807
msgid "The ~~{ directive requires a list argument, not ~S"
msgstr "La directiva ~~{ requiere una lista de argumentos, no ~S"

#: format.lsp:2297
msgid "Too many arguments for this directive"
msgstr "Demasiados argumentos para esta directiva"

#: format.lsp:2839
msgid "The control-string must be a string, not ~S"
msgstr "La cadena de control debe ser una cadena, no ~S"

# paquete (?) sv
#
# Bueno, podría parecer muy conveniente. Sin embargo, verás, ..., lo de
# *package* está puesto a nivel de programa. Es decir, Bruno Haible y
# compañía lo tienen puesto así desde su propio programa. Por lo tanto,
# si lo cambio en un par de mensajes seguirá apareciendo en muchos otros
# sitios. Prefiero ser consistente y dejarlo así. cll
#
# Además, no está traducido ni en alemán ni en inglés. cll
#
#: user1.lsp:49
msgid "[*package* invalid]"
msgstr "[*package* inválido]"

#: user1.lsp:155
msgid "values: "
msgstr "valores: "

# Me suele gustar más "utilice" (porque me parece más "fino"). sv
#
# De acuerdo, ..., cambiado `use' por `utilice'. A mí también me gusta más. cll
#
# Y además, (recomendación tuya, Santiago), `command' por `orden', en
# vez de `comando' - cll
#
#: user1.lsp:165
msgid ""
"\n"
"Help = this list\n"
"Use the usual editing capabilities."
msgstr ""
"\n"
"Help = esta lista\n"
"Utilice las órdenes de edición habituales"

#
# Cambiado `comando' por `orden', que parece ser muchísimo mejor - cll
#
#: user1.lsp:179
msgid ""
"\n"
"Help   = this command list\n"
"Abort  = abort to the next recent input loop\n"
"Unwind = abort to the next recent input loop\n"
"Mode-1 = inspect all the stack elements\n"
"Mode-2 = inspect all the frames\n"
"Mode-3 = inspect only lexical frames\n"
"Mode-4 = inspect only EVAL and APPLY frames (default)\n"
"Mode-5 = inspect only APPLY frames\n"
"Where  = inspect this frame\n"
"Up     = go up one frame, inspect it\n"
"Top    = go to top frame, inspect it\n"
"Down   = go down one frame, inspect it\n"
"Bottom = go to bottom (most recent) frame, inspect it\n"
"Backtrace-1 = list all stack elements\n"
"Backtrace-2 = list all frames\n"
"Backtrace-3 = list all lexical frames\n"
"Backtrace-4 = list all EVAL and APPLY frames\n"
"Backtrace-5 = list all APPLY frames\n"
"Backtrace   = list stack in current mode\n"
"Break+ = set breakpoint in EVAL frame\n"
"Break- = disable breakpoint in EVAL frame\n"
"Redo   = re-evaluate form in EVAL frame\n"
"Return = leave EVAL frame, prescribing the return values"
msgstr ""
"\n"
"Help   = esta lista de órdenes\n"
"Abort  = volver al bucle de entrada más reciente\n"
"Unwind = volver al bucle de entrada más reciente\n"
"Mode-1 = inspeccionar todos los elementos de la pila\n"
"Mode-2 = inspeccionar todos los marcos\n"
"Mode-3 = inspeccionar únicamente los marcos léxicos\n"
"Mode-4 = inspeccionar sólo los marcos de los tipos EVAL y APPLY (por\n"
"         defecto)\n"
"Mode-5 = inspeccionar sólo los marcos de tipo APPLY\n"
"Where  = inspeccionar el marco actual\n"
"Up     = ascender un marco, e inspeccionarlo\n"
"Top    = ir al primer marco, e inspeccionarlo\n"
"Down   = descender un marco e inspeccionarlo\n"
"Bottom = ir al último marco (el más reciente) e inspeccionarlo\n"
"Backtrace-1 = mostrar todos los elementos de la pila\n"
"Backtrace-2 = mostrar todos los marcos\n"
"Backtrace-3 = mostrar todos los marcos léxicos\n"
"Backtrace-4 = mostrar todos los marcos de los tipos EVAL y APPLY\n"
"Backtrace-5 = mostrar todos los marcos del tipo APPLY\n"
"Backtrace   = mostrar la pila en el modo actual\n"
"Break+ = establecer un punto de ruptura en un marco de tipo EVAL\n"
"Break- = desactivar un punto de ruptura en un marco de tipo EVAL\n"
"Redo   = re-evaluar la forma en un marco EVAL\n"
"Return = abandonar un marco EVAL con los valores de vuelta indicados"

#: user1.lsp:282
msgid ""
"\n"
"Continue = continue evaluation"
msgstr ""
"\n"
"Continue = continuar la evaluación"

#: user1.lsp:355
msgid "You can continue (by typing 'continue')."
msgstr "Puede continuar (tecleando `continue')."

#: conditio.lsp:1459 user1.lsp:364 user1.lsp:659
msgid "If you continue (by typing 'continue'): "
msgstr "Si continúa (tecleando `continue'): "

# Duda: Los `restarts' son un mecanismo muy, muy eficiente en Common
# Lisp para la recuperación de errores.
#
# Es posible programar una sección de código de modo que cuando sucede
# algún error se invoquen determinados `restarts' (elegidos y, más aún,
# programados por el propio programador). CLisp, entonces, presenta un
# menú con todos los `restarts' disponibles; el usuario debe elegir
# entre los posibles `restarts' para continuar la evaluación o
# cualquiera de las acciones de depuración que proporciona el entorno.
#
# Pero ¿cómo traducir `restart'? ¿re-entrada, ...? Hmmm, ..., no me
# suena nada bien. Por ese motivo, he preferido sustituir la palabra por
# una expresión: `También es posible continuar en los siguientes
# puntos:", y cuando no sea posible aplicar una expresión de este tipo,
# dejaré `restart' sin traducir hasta que se me ocurra algo más
# original.
#
# ¡¡Necesito ayuda!! :)
#
#: user1.lsp:378
msgid "The following restarts are available too:"
msgstr "También es posible continuar en los siguientes puntos:"

#: user1.lsp:381
msgid "The following restarts are available:"
msgstr "Es posible continuar en los siguientes puntos:"

# ¿form no era formulario? (o a lo mejor es algo de lisp que no sé). sv
#
# En Visual Basic (y los lenguajes orientados a eventos), form es formulario.
# Sin embargo, en Lisp form es forma. Se refiere a las sentencias Lisp. cll
#
#: user1.lsp:475
msgid ""
"\n"
"Step     = step into form: evaluate this form in single step mode\n"
"Next     = step over form: evaluate this form at once\n"
"Over     = step over this level: evaluate at once up to the next return\n"
"Continue = switch off single step mode, continue evaluation\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           same as above, specify a condition when to stop"
msgstr ""
"\n"
"Step     = entrar en una forma: evaluar esta forma en el modo paso a paso\n"
"Next     = saltarse una forma: evaluar esta forma en un solo paso\n"
"Over     = saltarse este nivel: evaluar hasta el siguiente retorno\n"
"Continue = desactivar el modo paso a paso y continuar la evaluación\n"
"Step-until, Next-until, Over-until, Continue-until:\n"
"           lo mismo que antes, especifique una condición de parada"

# Duda: Francamente, no sé porqué motivo esto no fué traducido al
# FRANCÉS o al INGLÉS (compruébese en el código, ...) porque en
# realidad, queda pero que muy bien poner `paso' cuando se hace la
# depuración paso a paso, ...
#
# Este mensaje, de hecho, aparece cuando se hace algo del tipo:
#
# > (step (+ 2 3))
# step 1 --> (+ 2 3)
# Step 1>
#
# ..., donde, traduciendo el primer `step' al español, queda algo muy
# propio:
#
# > (step (+ 2 3))
# paso 1 --> (+ 2 3)
# Step 1>
#
# A mi me gusta así, ..., ¡¡A SACO!!
#
#: user1.lsp:510 user1.lsp:570
msgid "step "
msgstr "paso "

#: user1.lsp:518
msgid "no values"
msgstr "sin valores"

#: user1.lsp:523
msgid "value: "
msgstr "valor: "

#: user1.lsp:531
msgid " values: "
msgstr " valores: "

#: user1.lsp:602
msgid "condition when to stop: "
msgstr "condición de parada: "

# Y esta también. sv
#
# ¡Hey! A mí lo de aviso no me acababa de gustar. ATENCIÓN queda de
# vicio, ... cll
#
#: conditio.lsp:1493 conditio.lsp:1520 user1.lsp:676
msgid "WARNING:"
msgstr "ATENCIÓN:"

# Con un poco de suerte, aquí se podría poner directamente " (s/n) ".
# En fileutils ya se puede. sv
#
# Bueno, pues sí, ..., sí podría hacerse. Ahora bien, para eso es
# necesario modificar el código fuente del clisp (lo cual no es nada
# complicado gracias a la localizacion de codigo fuente del modo .PO
# desde Emacs :). De momento, lo dejo tal cual (aunque queda pachín,
# pachán, ... :( ) y luego lo modificaré, ..., ¿vale?. cll
#
#: user1.lsp:730
msgid " (y/n) "
msgstr " (si(y)/no(n)) "

#: user1.lsp:744
msgid "Please answer with y or n : "
msgstr "Por favor, responda con y(si) o n(no) : "

#: user1.lsp:759
msgid " (yes/no) "
msgstr " (si(yes)/no(no)) "

#: user1.lsp:772
msgid "Please answer with yes or no : "
msgstr "Por favor, responda con yes(si) o no(no) : "

#: user2.lsp:35
msgid "special form"
msgstr "forma especial"

#: user2.lsp:40
msgid "function"
msgstr "función"

#: user2.lsp:44
msgid "macro"
msgstr "macro"

#: user2.lsp:59
msgid "constant"
msgstr "constante"

#: user2.lsp:63
msgid "variable"
msgstr "variable"

#: user2.lsp:71
msgid "type"
msgstr "tipo"

#: user2.lsp:77
msgid "class"
msgstr "clase"

#: user2.lsp:92
msgid "~%Description of~%"
msgstr "~%Descripción de~%"

# Duda: ¡Atención! "This is" se debería traducir por "Este es" o "Esta
# es". Desgraciadamente, cuando se escribe este mensaje (que es el
# principio de una frase más larga) no se dispone de ninguna variable
# cuyo contenido se pueda examinar para comprobar si se debe usar el
# masculino o el femenino. Sin embargo, "Se trata de" queda al pelo.
#
# Para que lo veais, a continuación muestro dos sesiones diferentes
# donde "Se trata de" queda que ni pintado, ... (sin embargo, sustituid
# mentalmente por "Este es" o "Esta es" y vereis que el primer caso,
# necesariamente debería ser masculino y el segundo femenino):
#
# > (describe 'a)
#
# Descripción de
# A
# Se trata de el símbolo A.
# El símbolo está en el #<PACKAGE USER> y es accesible desde el paquete USER.
#
# > (describe '(a b c))
#
# Descripción de
# (A B C)
# Se trata de una lista de longitud 3.
#
#: user2.lsp:97
msgid "~%This is "
msgstr "~%Se trata de "

#: user2.lsp:119
msgid "a list of length ~S."
msgstr "una lista de longitud ~S."

#: user2.lsp:125
msgid "a dotted list of length ~S."
msgstr "una lista punteada de longitud ~S."

# Duda: En Lisp todo el mundo se refiere a un `cons' como la parte de
# construcción de listas. Tanto como instrucción (cons es una
# instrucción en Lisp), como a las celdas en memoria del mismo nombre
# (posición que contiene información y un puntero a la siguiente celda
# cons). Por este motivo, traduzco `cons' por 'cons.
#
#: user2.lsp:130
msgid "a cons."
msgstr "un cons."

#: user2.lsp:134
msgid "a cyclic list."
msgstr "una lista cíclica."

#: user2.lsp:140
msgid "the empty list, "
msgstr "la lista vacía, "

#: user2.lsp:144
msgid "the symbol ~S"
msgstr "el símbolo ~S"

#: user2.lsp:150
msgid ", a keyword"
msgstr ", una palabra clave"

#: user2.lsp:156
msgid ", a constant"
msgstr ", una constante"

#: user2.lsp:161
msgid ", a variable declared SPECIAL"
msgstr ", una variable declarada SPECIAL"

#: user2.lsp:165
msgid ", a variable"
msgstr ", una variable"

#: user2.lsp:170
msgid " (macro)"
msgstr " (macro)"

#: user2.lsp:180
msgid ", names "
msgstr ", nombra "

#: user2.lsp:185
msgid "a special form"
msgstr "una forma especial"

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: user2.lsp:190
msgid " with macro definition"
msgstr " con definición de macro"

#: user2.lsp:195
msgid "a function"
msgstr "una función"

#: user2.lsp:203
msgid "a macro"
msgstr "una macro"

#: user2.lsp:212
msgid ", names a type"
msgstr ", nombra un tipo"

#: user2.lsp:220
msgid ", names a class"
msgstr ", nombra una clase"

#: user2.lsp:231
msgid ", has the propert~@P ~{~S~^, ~}"
msgstr ", tiene ~[~;la propiedad~:;las propiedades~] ~{~S~^, ~}"

#: user2.lsp:238 user2.lsp:280 user2.lsp:350 user2.lsp:459 user2.lsp:489 user2.lsp:632
msgid "."
msgstr "."

#: user2.lsp:242
msgid "~%The symbol "
msgstr "~%El símbolo "

#: user2.lsp:248
msgid "lies in ~S"
msgstr "está en el ~S"

# Duda: He traducido al estilo del mensaje en francés: "n'appartient à
# aucun paquetage"
#
#: user2.lsp:253
msgid "is uninterned"
msgstr "no aparece en ningún paquete"

# Nota: Caso brillante de la generación de mensajes diferentes gracias a las
#       directivas condicionales del Clisp (y del Common Lisp en general).
#
#: user2.lsp:274
msgid " and is accessible in the package~:[~;s~] ~{~A~^, ~}"
msgstr " y es accesible desde ~:[el paquete~;los paquetes~] ~{~A~^, ~}"

#: user2.lsp:285
msgid "an integer, uses ~S bits, is represented as a ~(~A~)."
msgstr "un entero que usa ~S bits y se representa como un ~(~A~)."

#: user2.lsp:291
msgid "a rational, not integral number."
msgstr "un racional, no un número entero."

#: user2.lsp:296
msgid "a float with ~S bits of mantissa (~(~A~))."
msgstr "un número en coma flotante con ~S bits de mantisa (~(~A~))."

#: user2.lsp:302
msgid "a complex number "
msgstr "un número complejo "

#: user2.lsp:310
msgid "at the origin"
msgstr "en el origen"

#: user2.lsp:314
msgid "on the ~:[posi~;nega~]tive real axis"
msgstr "en el eje real ~:[posi~;nega~]tivo"

#: user2.lsp:320
msgid "on the ~:[posi~;nega~]tive imaginary axis"
msgstr "en el eje imaginario ~:[posi~;nega~]tivo"

#: user2.lsp:325
msgid "in ~:[~:[first~;fourth~]~;~:[second~;third~]~] the quadrant"
msgstr "en el ~:[~:[primer~;cuarto~]~;~:[segundo~;tercer~]~] cuadrante"

# Si es lo que me imagino, tal vez sería mejor poner "del plano complejo".
# (como matemático que soy, me suena mejor :-). sv
#
# Pues sí, es exactamente lo que te imaginas, ..., "el plano de los números
# gaussianos" era una >>horrible<< traducción, ... ¡Gracias! cll
#
#: user2.lsp:330
msgid " of the Gaussian number plane."
msgstr " del plano complejo."

#: user2.lsp:335
msgid "a character"
msgstr "un carácter"

#: user2.lsp:340
msgid " with additional bits"
msgstr " con bits adicionales"

#: user2.lsp:345
msgid " from font ~S"
msgstr " de la fuente ~S"

#: user2.lsp:354
msgid "~%It is a ~:[non-~;~]printable character."
msgstr "~% Se trata de un carácter ~:[no ~;~]imprimible."

#: user2.lsp:360
msgid "~%Its use is non-portable."
msgstr "~%Su utilización no es portable."

#: user2.lsp:367
msgid "a~:[n interpret~; compil~]ed function."
msgstr "una función ~:[interpret~;compil~]ada."

#: user2.lsp:380
msgid "~%argument list: ~S"
msgstr "~%lista de argumentos: ~S"

#: user2.lsp:387
msgid "~%documentation: ~A"
msgstr "~%documentación: ~A"

#: user2.lsp:397
msgid "a built-in system function."
msgstr "una función predefinida del sistema."

#: user2.lsp:407
msgid "a special form handler."
msgstr "un manipulador de forma especial."

#: user2.lsp:413
msgid "a foreign pointer"
msgstr "una puntero externo"

#: user2.lsp:419
msgid "a foreign address"
msgstr "una dirección externa"

#: user2.lsp:425
msgid "a foreign variable of foreign type ~S."
msgstr "una variable externa del tipo extranjero ~S."

#: user2.lsp:432
msgid "a foreign function."
msgstr "una función externa."

#: user2.lsp:439
msgid "a~:[~:[ closed ~;n output-~]~;~:[n input-~;n input/output-~]~]stream."
msgstr "un flujo ~:[~:[cerrado~;de salida~]~;~:[de entrada~;de entrada/salida~]~]."

#: user2.lsp:447
msgid "the package named ~A"
msgstr "el paquete ~A"

#: user2.lsp:454
msgid ". It has the nicknames ~{~A~^, ~}"
msgstr ". Tiene los apodos ~{~A~^, ~}"

# Duda: Debo comprobarlo en el código fuente de CLisp pero estoy casi
# seguro que esto es mucho mejor dejarlo sin traducir, ... cll
#
#: user2.lsp:465
msgid "~%It "
msgstr "~%"

#: user2.lsp:470
msgid "imports the external symbols of the package~:[~;s~] ~{~A~^, ~} and "
msgstr "importa los símbolos externos de~:[l paquete~; los paquetes~] ~{~A~^, ~} y "

#: user2.lsp:475
msgid "exports ~:[no symbols~;the symbols~:*~{~<~%~:; ~S~>~^~}~]"
msgstr "~:[no exporta ningún símbolo~;exporta los símbolos~:*~{~<~%~:; ~S~>~^~}~]"

#: user2.lsp:484
msgid " to the package~:[~;s~] ~{~A~^, ~}"
msgstr " ~:[al paquete~;a los paquetes~]: ~{~A~^, ~}"

#: user2.lsp:493
msgid "a deleted package."
msgstr "un paquete borrado."

#
# Nota: Muy, muy importante.
#
# En la `españolización' de CLisp, debe programarse de nuevo la
# directiva ~P, para que los plurales se formen añadiendo "es" si el
# argumento no es `eql' a 1.
#
# Asimismo, debieran revisarse otras directivas de `format' como, por
# ejemplo, ~@P, ~:R, etc.
#
# ¡¡Pues no!! Cuando le dije esto a Bruno Haible, él me dijo que el
# estándar Common Lisp - The Language, no contemplaba la realización de
# este tipo de directivas en otros idiomas, sino especificamente en
# inglés. Ni español, ni alemán, ni francés, ...
#
#: user2.lsp:498
msgid "a hash table with ~S entr~:@P."
msgstr "una tabla hash con ~S entrada~:*~[s~;~:;s~]."

# Este mensaje tiene una especial dificultad, porque de el deberían
# salir cosas del tipo: "una tabla de lectura" (con `tabla de lectura'
# al final del mensaje) o "la tabla de lectura de Common Lisp" (con
# `tabla de lectura' al principio).
#
# Afortunadamente, la situación puede salvarse sin ningún problema
# gracias a la directiva ~:* de format
#
#: user2.lsp:504
msgid "~:[a~;the Common Lisp~] readtable."
msgstr "~:[una~;la~] tabla de lectura~:*~:[~; de Common Lisp~]"

#: user2.lsp:510
msgid "a ~:[~;portable ~]pathname~:[.~;~:*, with the following components:~{~A~}~]"
msgstr "una trayectoria~:[~; portátil~]~:[.~;~:*, constituída por: ~{~A~}~]"

#: user2.lsp:530
msgid "a random-state."
msgstr "un estado aleatorio."

#: user2.lsp:535
msgid "a byte specifier, denoting the ~S bits starting at bit position ~S of an integer."
msgstr "un especificador de byte que denota los ~S bits que comienzan en el bit ~S de un entero"

#: user2.lsp:541
msgid "a load-time evaluation promise."
msgstr "una promesa de evaluación en tiempo de carga."

#: user2.lsp:546
msgid "a label used for resolving #~D# references during READ."
msgstr "una etiqueta para resolver #~D# referencias en READ."

#: user2.lsp:552
msgid "a pointer into the stack. It points to:"
msgstr "Un puntero a la pila. Apunta a:"

#: user2.lsp:559
msgid "a special-purpose object."
msgstr "un objeto de propósito especial."

#: user2.lsp:564
msgid "a machine address."
msgstr "una dirección de máquina."

#: user2.lsp:572
msgid "a structure of type ~S."
msgstr "una estructura del tipo ~S."

#: user2.lsp:579
msgid "~%As such, it is also a structure of type ~{~S~^, ~}."
msgstr "Como tal, también es una estructura del tipo ~{~S~^, ~}."

#: user2.lsp:588
msgid "an instance of the CLOS class ~S."
msgstr "una instancia de la clase CLOS ~S."

#: user2.lsp:599
msgid "a~:[~; simple~] ~A dimensional array"
msgstr "una matriz~:[~; simple~] de dimensión ~A"

#: user2.lsp:605
msgid " (vector)"
msgstr " (vector)"

#: user2.lsp:610
msgid " of ~(~A~)s"
msgstr " de ~(~A~)s"

#: user2.lsp:616
msgid ", adjustable"
msgstr ", ajustable"

#: user2.lsp:621
msgid ", of size ~{~S~^ x ~}"
msgstr ", de tamaño ~{~S~^ x ~}"

#: user2.lsp:627
msgid " and current length (fill-pointer) ~S"
msgstr " y longitud actual (fill-pointer) ~S"

#: user2.lsp:638
msgid "~%For more information, evaluate ~{~S~^ or ~}."
msgstr "~%Para más información, evalúe ~{~S~^ o ~}."

#: user2.lsp:680
msgid "~S: ~S is not a function."
msgstr "~S: ~S no es una función."

#: user2.lsp:688
msgid "~%argument list: "
msgstr "~%lista de argumentos: "

#: user2.lsp:779
msgid "~S: argument must be ~S, ~S or ~S, not ~S"
msgstr "~S: el argumento debe ser ~S, ~S o ~S, pero no ~S"

#: user2.lsp:815 user2.lsp:995
msgid "Total"
msgstr "Total"

#: user2.lsp:825
msgid "~%Bytes permanently allocated:   ~9D~%Bytes currently in use:        ~9D~%Bytes available until next GC: ~9D~%"
msgstr "~%Bytes permanentemente asignados:   ~9D~%Bytes actualmente en uso:        ~9D~%Bytes disponibles hasta el próximo GC: ~9D~%"

# Nota: La utilización de dribbling viene de la función dribble de Lisp.
#       Dicha función graba una sesión Lisp en el archivo que se indique en la
#       llamada a la función.
#
# La traducción no juega, de esa manera, con las palabras.
#
#: user2.lsp:1020
msgid "Already dribbling to ~S"
msgstr "Ya se está grabando la sesión en ~S"

#: user2.lsp:1108
msgid "Currently not dribbling."
msgstr "En este momento, no se está grabando la sesión."

#: user2.lsp:1137
msgid "No external editor installed."
msgstr "No hay ningún editor externo instalado"

#: editor.lsp:2952 user2.lsp:1211
msgid "~S cannot be edited."
msgstr "~S no puede ser editado."

#: user2.lsp:1232
msgid "~S: source code for ~S not available."
msgstr "~S: el código fuente de ~S no está disponible."

#: user2.lsp:1541
msgid "~S: File ~S already exists"
msgstr "~S: El fichero ~S ya existe"

#: trace.lsp:85 trace.lsp:276
msgid "~S: function name should be a symbol, not ~S"
msgstr "~S: el nombre de una función debe ser un símbolo, no ~S"

#: trace.lsp:97
msgid "~S: undefined function ~S"
msgstr "~S: la función ~S no está definida"

#: trace.lsp:105
msgid "~S: cannot trace special form ~S"
msgstr "~S: no es posible rastrear la forma especial ~S"

#: trace.lsp:118
msgid "~&;; Tracing ~:[function~;macro~] ~S."
msgstr "~&;; Rastreando la ~:[función~;macro~] ~S."

#: trace.lsp:294
msgid "~S: ~S was traced and has been redefined!"
msgstr "~S: ¡~S estaba siendo rastreada y ha sido redefinida!"

#: macros3.lsp:13
msgid ""
"The form ~S yielded ~:[no values~;~:*~{~S~^ ; ~}~] ,~@\n"
"                       that's not of type ~S."
msgstr ""
"La forma ~S ~:[no produjo ningún valor~;produjo ~:*~{~S~^ ; ~}~] ,~@\n"
"                       que no es del tipo ~S."

#: macros3.lsp:68
msgid "LETF* code contains a dotted list, ending with ~S"
msgstr "El código del LETF* contiene una lista punteada que termina con ~S"

#: macros3.lsp:89
msgid "illegal syntax in LETF* binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF*: ~S"

#: macros3.lsp:235
msgid "LETF code contains a dotted list, ending with ~S"
msgstr "El código de LETF contiene una lista punteada que termina con ~S"

#: macros3.lsp:256
msgid "illegal syntax in LETF binding: ~S"
msgstr "sintaxis inválida en la ligadura de LETF: ~S"

# Este es el formato de las fechas, ... Lo he cogido de la traducción
# alemana y de la francesa, donde es al contrario que la inglesa.
#
#: compiler.lsp:217
msgid "~1{~5@*~D/~4@*~D/~3@*~D ~2@*~2,'0D.~1@*~2,'0D.~0@*~2,'0D~:}"
msgstr "~1{~3@*~D/~4@*~D/~5@*~D ~2@*~2,'0D:~1@*~2,'0D:~0@*~2,'0D~:}"

# Duda: En Lisp, todo el mundo sabe lo que es un `closure'. Bueno, me parece
#       que la mejor traducción es `cierre'.
#
# He visto que los traductores del libro Lisp (3ra edición), de Winston
# y Horn, dicen al final de la página 234 y principio de la 235: "Los
# procedimientos objeto, producidos a partir de una combinación de #' y
# lambda se denominan cerraduras léxicas. El término es usado porque la
# palabra cerradura sugiere que se están involucrando cercas, en tanto
# que la palabra léxica sugiere que las cercas son colocadas de acuerdo
# con las reglas del alcance léxico (o visibilidad) (...) Como no existe
# una forma impresa conveniente para la información de las cercas, la
# forma impresa de una cerradura léxica, sin ser clara, aparecería como:
# #<CERRADURA LÉXICA ...>." Pues bien, propongo que cuando se hagan
# referencias al léxico se diga "cerradura léxica" y, en otro caso,
# "cerradura".
#
# Estos términos me parecen mejores que "cierre léxico" o "cierre" - cll
#
#: compiler.lsp:402
msgid "Bad length of closure vector: ~S"
msgstr "Longitud incorrecta del vector de cerradura: ~S"

# Aquí también junto las exclamaciones. sv
#: compiler.lsp:2271
msgid "Compiler bug!! Occurred in ~A~@[ at ~A~]."
msgstr "¡¡Error del compilador!! Ocurrió en ~A~@[ en ~A~]."

# Soy alérgico al verbo "ignorar". Ignorar en español significa no saber.
# Y eso en inglés se dice "not to know".
# Posibilidades: Descartar, no tener en cuenta. sv
#
# :) Bueno, ... :) Lo cierto es que en el diccionario pone:
#
# "No saber una cosa o muchas cosas, o, de lo contrario, no tener
# noticia de ellas."
#
# O sea, que algo se ignora si no se tienen noticias de ello, ... Creo
# que la traducción está, por lo tanto, correcta. Ahora bien, "no tener
# en cuenta" o "descartar" también me parece muy correcto así que, ¿por
# qué no iba a cambiarlo? :) cll
#
#: compiler.lsp:2945
msgid "Bad declaration syntax: ~S~%Will be ignored."
msgstr "Sintaxis de la declaración incorrecta:~S~%No se tendrá en cuenta."

#: compiler.lsp:2967
msgid "Non-symbol ~S may not be declared SPECIAL."
msgstr "El \"no-símbolo\" ~S no debe declararse SPECIAL."

#: compiler.lsp:2976
msgid "Non-symbol ~S may not be declared IGNORE."
msgstr "El \"no símbolo\" ~S no debe declararse IGNORE."

#: compiler.lsp:2985
msgid "Non-symbol ~S may not be declared IGNORABLE."
msgstr "El \"no-símbolo\" ~S no debe declararse IGNORABLE."

#: compiler.lsp:2992
msgid "Unknown declaration ~S.~%The whole declaration will be ignored."
msgstr "Declaración desconocida ~S.~%La declaración completa será ignorada."

#: compiler.lsp:3326
msgid " in line ~D"
msgstr " en la línea ~D"

#: compiler.lsp:3329
msgid " in lines ~D..~D"
msgstr " en las líneas ~D..~D"

#
# Duda: He querido traducir la palabra `warning' por `aviso' que es como
# debería decirse en español, ¿no?. ¿Hay algún término adoptado en
# es@li.org, para esta palabra?.
#
# Sí, atención. sv
#
# Si, si, ya lo he hecho, ... En todas partes he puesto "WARNING" por
# "ATENCIÓN". No es exactamente lo mismo, pero me parece una sugerencia
# genial, de hecho me gusta muchísimo más que aquello de "AVISO:". De
# esta manera, parecía que te estaban hablando los "super-tacañones" :) - cll
#
# Sin embargo, Santiago, este caso es bastante peculiar. Verás, si dejo
# "ATENCIÓN" aquí, entonces, durante la compilación de un proyecto con
# varios ficheros en Lisp, podría salir, por ejemplo, un mensaje como el
# siguiente (tomado de un ejemplo real, que conste, ...):
#
# --------------
# ATENCIÓN en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
# Y yo pregunto, en este caso ¿no es mejor poner "ADVERTENCIA"? La
# verdad es que "ADVERTENCIA" me suena mucho mejor que "ATENCIÓN" y que
# "AVISO". En este caso, lo que se tendría es:
#
# --------------
# ADVERTENCIA en la función PROBLEMA$$ESCALAMIENTO en las líneas 382..427 :
# La variable NODO-INICIAL no está siendo usada.
# ¿Está mal escrita o es que falta la declaración IGNORE?
# --------------
#
#
#: compiler.lsp:3343
msgid "~%WARNING~@[ in function ~S~]~A :~%"
msgstr "~%ADVERTENCIA~@[ en la función ~S~]~A :~%"

#: compiler.lsp:3369
msgid "~%ERROR~@[ in function ~S~]~A :~%~?"
msgstr "~% ERROR~@[ en la función ~S~]~A : ~%~?"

#: compiler.lsp:3513
msgid "Code contains dotted list ~S"
msgstr "El código contiene la lista punteada ~S"

# En ocasiones como esta hemos puesto a veces:
# "insuficiente número de argumentos" sv
#
# ¡Pues no me gusta nada!, todavía si dijeses "número insuficiente de
# argumentos". No se, ..., la verdad es que a mí me gusta mucho más "muy
# pocos argumentos" o, si quieres, "pocos argumentos" pero eso de la
# "insuficiencia", ... (me trae otros recuerdos). cll
#
#: compiler.lsp:3519
msgid "Form too short, too few arguments: ~S"
msgstr "Forma demasiado corta, muy pocos argumentos: ~S"

#: compiler.lsp:3526
msgid "Form too long, too many arguments: ~S"
msgstr "Forma demasiado larga, demasiados argumentos: ~S"

#: compiler.lsp:3662
msgid "Invalid form: ~S"
msgstr "La forma ~S es inválida"

# Añado lo que faltaba. sv
#
# Hmmm, ¿se me olvidó algo?. Atención, jóvenes traductores: recordad que
# hay un momento en el que es necesario parar de trabajar, ..., la
# cabeza puede llegar a dar muchas vueltas :) cll
#
#: compiler.lsp:3716
msgid "Not the name of a function: ~S"
msgstr "No es el nombre de una función: ~S"

#: compiler.lsp:3793 compiler.lsp:3877
msgid ""
"~S is neither declared nor bound,~@\n"
"                        it will be treated as if it were declared SPECIAL."
msgstr ""
"~S no está ni declarado ni ligado,~@\n"
"                        será tratado como si hubiese sido declarado SPECIAL."

#: compiler.lsp:3898
msgid ""
"The constant ~S may not be assigned to.~@\n"
"                                                  The assignment will be ignored."
msgstr ""
"La constante ~S no puede asignarse. ~@\n"
"                                                  La asignación será ignorada."

#: compiler.lsp:4043
msgid "argument list to function ~S is dotted: ~S"
msgstr "el argumento de la función ~S es una lista punteada: ~S"

#: compiler.lsp:4051
msgid ""
"~S called with ~S~:[~; or more~] arguments, but it requires ~\n"
"                        ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] arguments."
msgstr ""
"~S fue invocado con ~S~:[~; o más~] argumentos, pero requiere ~\n"
"                        ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lsp:4068
msgid "keyword arguments to function ~S should occur pairwise: ~S"
msgstr "los argumentos clave de la función ~S deben aparecer por pares: ~S"

#
# Afortunadamente, la convención ~#[, para imprimir los términos de una
# lista (en inglés, como dice el estándar) sirve perfectamente para el
# español
#
#: compiler.lsp:4081
msgid ""
"keyword ~S is not allowed for function ~S.~\n"
"                              ~%The only allowed keyword~:[s are ~{~S~#[~; and ~S~:;, ~]~}~; is ~{~S~}~]."
msgstr ""
"la palabra clave ~S no está permitida en la función ~S.~\n"
"                              ~%La~:[s~;~] única~:*~:[s~;~] palabra~:*~:[s~;~] clave permitida~:*~:[s son ~{~S~#[~; y ~S~:;, ~]~}~; es ~{~S~}~]."

#: compiler.lsp:4097
msgid "argument ~S to function ~S is not a keyword"
msgstr "el argumento ~S para la función ~S no es un argumento clave"

#: compiler.lsp:4755
msgid ""
"~S called with ~S arguments, but it requires ~\n"
"                                   ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] arguments."
msgstr ""
"~S ha sido invocado con ~S argumentos, pero requiere ~\n"
"                                   ~:[~:[de ~S a ~S~;~S~]~;al menos ~*~S~] argumentos."

#: compiler.lsp:4936
msgid "Illegal syntax in LET/LET*: ~S"
msgstr "Sintaxis inválida en LET/LET*: ~S"

#: compiler.lsp:4975
msgid "Lambda list marker ~S not allowed here."
msgstr "El marcador de la lista lambda ~S no está permitido aquí."

#: compiler.lsp:4983
msgid "Missing &REST parameter in lambda list ~S"
msgstr "La lista lambda ~S necesita un parámetro &REST"

#: compiler.lsp:4991
msgid "Lambda list element ~S is superfluous."
msgstr "El elemento ~S de la lista lambda es innecesario."

#: compiler.lsp:5168
msgid "Lambda lists with dots are only allowed in macros, not here: ~S"
msgstr "Sólo se permiten las listas lambda con puntos en la macros, no aquí: ~S"

#: compiler.lsp:5186
msgid "Illegal lambda list element ~S"
msgstr "Elemento inválido en lista lambda ~S"

#: compiler.lsp:5283
msgid "Binding variable ~S can cause side effects despite of IGNORE declaration~%since it is declared SPECIAL."
msgstr "Asociar la variable ~S puede causar otros efectos, a pesar de la declaración~%IGNORE puesto que está declarada como SPECIAL."

#: compiler.lsp:5289
msgid "variable ~S is used despite of IGNORE declaration."
msgstr "La variable ~S está siendo usada a pesar de la declaración IGNORE."

#: compiler.lsp:5302
msgid "variable ~S is not used.~%Misspelled or missing IGNORE declaration?"
msgstr "La variable ~S no está siendo usada.~%¿Está mal escrita o es que falta la declaración IGNORE?"

#: compiler.lsp:5349 compiler.lsp:5487
msgid "Constant ~S cannot be bound."
msgstr "La constante ~S no puede ligarse."

#: compiler.lsp:6228
msgid "Misplaced declaration: ~S"
msgstr "Declaración situada incorrectamente: ~S"

#: compiler.lsp:6442
msgid "Odd number of arguments to SETQ: ~S"
msgstr "Número impar de argumentos de SETQ: ~S"

#: compiler.lsp:6481 compiler.lsp:6522 compiler.lsp:6622
msgid "Cannot assign to non-symbol ~S."
msgstr "No se puede asignar a un \"no-símbolo\" ~S."

#: compiler.lsp:6495
msgid "Odd number of arguments to PSETQ: ~S"
msgstr "Número impar de argumentos de PSETQ: ~S"

#: compiler.lsp:6762
msgid "Only symbols may be used as variables, not ~S"
msgstr "Sólo pueden usarse los símbolos como variables, no ~S"

#: compiler.lsp:6869
msgid "Illegal syntax in COMPILER-LET: ~S"
msgstr "Sintaxis inválida en COMPILER-LET: ~S"

#: compiler.lsp:6879
msgid "Block name must be a symbol, not ~S"
msgstr "El nombre de un bloque debe ser un símbolo, no ~S"

#: compiler.lsp:6930
msgid "RETURN-FROM block ~S is impossible from here."
msgstr "No es posible hacer RETURN-FROM del bloque ~S desde aquí."

#: compiler.lsp:7002
msgid "Only numbers and symbols are valid tags, not ~S"
msgstr "Sólo son etiquetas de salto válidas los números y los símbolos, no ~S"

#: compiler.lsp:7075
msgid "Tag must be a symbol or a number, not ~S"
msgstr "Una etiqueta de salto debe ser un símbolo o un número, no ~S"

#: compiler.lsp:7082
msgid "GO to tag ~S is impossible from here."
msgstr "No es posible ir (GO) a la etiqueta de salto ~S desde aquí."

#: compiler.lsp:7159
msgid "~S is not a function. It is a locally defined macro."
msgstr "~S no es una función. Se trata de una macro definida localmente."

#: compiler.lsp:7197
msgid "Only symbols and lambda expressions are function names, not ~S"
msgstr "Sólo los símbolos y las expresiones lambda son nombres de funciones válidos, no ~S"

#: compiler.lsp:7250
msgid "Illegal function definition syntax in ~S: ~S"
msgstr "La sintaxis para la definición de la función en ~S es inválida: ~S"

#: compiler.lsp:7692
msgid "Illegal syntax in SYMBOL-MACROLET: ~S"
msgstr "Sintaxis inválida en SYMBOL-MACROLET: ~S"

#: compiler.lsp:7699
msgid "~S: symbol ~S must not be declared SPECIAL and a macro at the same time"
msgstr "~S: el símbolo ~S no debe ser declarado SPECIAL y una macro al mismo tiempo"

# Duda: He traducido `EVAL-WHEN situation' por `instante de EVAL-WHEN',
# puesto que el primer argumento de EVAL-WHEN es el *instante* en el que
# debe evaluarse la expresión que viene a continuación y, que de hecho,
# puede ser ---como dice el mensaje--- EVAL, LOAD o COMPILE.
#
#: compiler.lsp:7729
msgid "EVAL-WHEN situation must be EVAL or LOAD or COMPILE, but not ~S"
msgstr "El instante de EVAL-WHEN debe ser EVAL, LOAD o COMPILE, pero no ~S"

#: compiler.lsp:7776
msgid "CASE clause without objects: ~S"
msgstr "Cláusula CASE sin objetos: ~S"

#: compiler.lsp:7788
msgid "~S: the ~S clause must be the last one: ~S"
msgstr "~S: la clausula ~S debe ser la última: ~S"

#: compiler.lsp:7800
msgid "Duplicate ~S label ~S : ~S"
msgstr "~S : La etiqueta ~S se repite: ~S"

#: compiler.lsp:8064
msgid "Too many arguments to ~S"
msgstr "Demasiados argumentos para ~S"

#: compiler.lsp:8081
msgid "Too few arguments to ~S"
msgstr "Muy pocos argumentos para ~S"

# eso de función "a compilar" siempre
# me pareció un vicio moderno.
# Sugerencia: El nombre de la función que hay que compilar ... sv
#
# Perfecto, ... cll
#
#: compiler.lsp:12564
msgid "Name of function to be compiled must be a symbol, not ~S"
msgstr "El nombre de una función que hay que compilar debe ser un símbolo, no ~S"

#: compiler.lsp:12577
msgid "~S: redefining ~S; it was traced!"
msgstr "~S: redefiniendo ~S; ¡estaba siendo rastreada!"

#: compiler.lsp:12587 compiler.lsp:12624
msgid "~S is already compiled."
msgstr "~S ya está compilada."

#: compiler.lsp:12610 compiler.lsp:13207
msgid "Undefined function ~S"
msgstr "La función ~S no está definida"

# Sugerencia: No es blabla ni bla bla. sv
# El ni se ponía la segunda pero no la primera vez, ¿no?
#
# ¡No, hombre, no! Creo que estas equivocado, ..., en el diccionario
# Larousse de Inglés-Español pone:
#
# "nor conj. Ni: he is neither big nor small, no es ni grande ni
# pequeño; neither you nor I, ni tú ni yo || ..."
#
# O sea, que es " ... ni ... ni ..." cll
#
#: compiler.lsp:12635
msgid "Not a lambda expression nor a function: ~S"
msgstr "Ni es una expresión lambda ni es una función: ~S"

#: compiler.lsp:12856
msgid "~&Listing of compilation of file ~A~%on ~@? by ~A, version ~A"
msgstr "~&Listado de la compilación del fichero ~A~%el ~@? por ~A, versión ~A"

#: compiler.lsp:12901
msgid "~%Compiling file ~A ..."
msgstr "~%Compilando el fichero ~A ..."

#: compiler.lsp:12925
msgid "~&~%Compilation of file ~A is finished."
msgstr "~&~%La compilación del fichero ~A ha finalizado."

#
# Duda: ¡atención a la utilización de la directiva ~P!
#
# La siguiente traducción funcionará si, para el caso del español (como
# para el alemán), se pasa el parámetro (eql *error-count* 1), en
# segundo lugar.
#
# Ya no hace falta. Tal y como está hecho no es necesario pasar ningún
# parámetro extra. Así funciona correctamente.
#
# Aquí dudo porque atención no es tan "pluralizable" como aviso. sv
#
# Claro, de hecho, a mí también me pasa lo mismo. He preferido cambiar
# la traducción de "aviso" por "advertencia", en este mensaje y en aquél
# en el que se sacan los mensajes del compilador. ¿No os suena muchísimo
# mejor esta segunda alternativa? - cll
#
#: compiler.lsp:12930
msgid "~%~D error~:P, ~D warning~:P"
msgstr "~%~D error~:*~[es~;~:;es~], ~D advertencia~:P"

#: compiler.lsp:12937
msgid "~%There were errors in the following functions:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Ha habido errores en las siguientes funciones:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12946
msgid "~%The following functions were used but not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12954
msgid "~%The following special variables were not defined:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales no han sido definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12960
msgid "~%The following special variables were defined too late:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes variables especiales fueron definidas demasiado tarde:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:12966
#, fuzzy
msgid "~%The following functions were used but are deprecated:~%~{~<~%~:; ~S~>~^~}"
msgstr "~%Las siguientes funciones han sido utilizadas pero no definidas:~%~{~<~%~:; ~S~>~^~}"

#: compiler.lsp:13025
msgid "~%~%Disassembly of function ~S"
msgstr "Desensamblado de la función ~S"

#: compiler.lsp:13038
msgid "~%~S required arguments"
msgstr "~%~S argumentos obligatorios"

#: compiler.lsp:13043
msgid "~%~S optional arguments"
msgstr "~%~S argumentos opcionales"

#: compiler.lsp:13048
msgid "~%~:[No rest parameter~;Rest parameter~]"
msgstr "~%~:[Sin parámetro resto~;Parámetro resto~]"

#: compiler.lsp:13055
msgid "~%~S keyword parameter~:P: ~{~S~^, ~}."
msgstr "~%~S parámetro~:P clave: ~{~S~^, ~}."

#: compiler.lsp:13061
msgid "~%Other keywords are allowed."
msgstr "~%Se permiten otros parámetros clave."

#: compiler.lsp:13065
msgid "~%No keyword parameters"
msgstr "~%Sin parámetros clave"

#: compiler.lsp:13084
msgid "Disassembly of function "
msgstr "Desensamblado de la función "

#: compiler.lsp:13104
msgid " required arguments"
msgstr " argumentos obligatorios"

#: compiler.lsp:13111
msgid " optional arguments"
msgstr " argumentos opcionales"

#: compiler.lsp:13118
msgid "Rest parameter"
msgstr "Parámetro resto"

#: compiler.lsp:13123
msgid "No rest parameter"
msgstr "Sin parámetro de resto"

#
# ¡¡Atención a la utilización de la directiva ~P!!
#
# Bueno, en este caso es perfecta :) No hay ningún problema de ningún
# tipo
#
#: compiler.lsp:13132
msgid " keyword parameter~P: "
msgstr "parámetro~P clave: "

#: compiler.lsp:13144
msgid "Other keywords are allowed."
msgstr "Se permiten otras palabras clave."

#: compiler.lsp:13151
msgid "No keyword parameters"
msgstr "Sin parámetros clave"

#: compiler.lsp:13232
msgid "Cannot disassemble ~S"
msgstr "No se puede desensamblar ~S"

#: defs2.lsp:62
msgid "~S: ~S is not a function"
msgstr "~S: ~S no es una función"

#: defs2.lsp:78
msgid "~S: package name ~S should be a string or a symbol"
msgstr "~S: el nombre del paquete ~S debe ser una cadena de caracteres o un símbolo"

#: defs2.lsp:87
msgid "~S ~A: symbol name ~S should be a string or a symbol"
msgstr "~S ~A: el nombre del símbolo ~S debe ser una cadena de caracteres o un símbolo"

#: defs2.lsp:109
msgid "~S ~A: the symbol ~A must not be specified more than once"
msgstr "~S ~A: el símbolo ~A no debe especificarse más de una vez"

#: defs2.lsp:125 defs2.lsp:135
msgid "~S ~A: the ~S option must not be given more than once"
msgstr "~S ~A: no se debe poner la opción ~S más de una vez"

#: defs2.lsp:181
msgid "~S ~A: unknown option ~S"
msgstr "~S ~A: la opción ~S es desconocida"

#: defs2.lsp:187
msgid "~S ~A: invalid syntax in ~S option: ~S"
msgstr "~S ~A: la sintaxis de la opción ~S es inválida: ~S"

#: defs2.lsp:193
msgid "~S ~A: not a ~S option: ~S"
msgstr "~S ~A: no se trata de una opción ~S: ~S"

#: defs2.lsp:251
msgid "This symbol will be created."
msgstr "Este símbolo será creado."

#: defs2.lsp:254
msgid "~S ~A: There is no symbol ~A::~A ."
msgstr "~S ~A: El símbolo ~A::~A no existe."

#: defs2.lsp:284
msgid "~S: the name of a symbol macro must be a symbol, not ~S"
msgstr "~S: el nombre de un símbolo de macro debe ser un símbolo, no ~S"

#: defs2.lsp:302
msgid "~S: the symbol ~S names a global variable"
msgstr "~S: el símbolo ~S nombra una variable global"

#: defs2.lsp:362
msgid "The object to be destructured should be a list with ~:[at least ~*~S~;~:[from ~S to ~S~;~S~]~] elements, not ~4@*~S."
msgstr "Los objetos a desmontar deben ser una lista ~:[con al menos ~*~S~;de ~:[~S a ~S~;~S~]~] elementos, y no ~4@*~S."

#: defs2.lsp:433
msgid "~S: macro name should be a symbol, not ~S"
msgstr "~S: el nombre de una macro debe ser un símbolo, no ~S"

#: defs2.lsp:470
#, fuzzy
msgid "~S: input stream ~S ends within read macro beginning to ~S"
msgstr "~: el flujo de entrada ~ ha terminado mientras se procesaba una macro de lectura en ~"

#: defs2.lsp:478
#, fuzzy
msgid "~S from ~S: character read should be a string-char: ~S"
msgstr "~ en ~: el carácter leído debe ser un STRING-CHAR: ~"

# Duda: En Common Lisp existen los "Standard Dispatching Macro
# Characters" (Common Lisp, The Language - Second Edition; Guy
# L. Steel). Estos caracteres identifican diferentes estructuras. Por
# ejemplo, son "Dispatch Macro Characters" los siguientes: S, A, G, H,
# etc., por ello, existen en CLisp: #S, #A, #G, #H, etc.
#
# La traducción francesa incluye el término `dispatch'. Sin embargo, yo
# he preferido decir "# macro carácter", estoy convencido de que esto se
# entenderá perfectamente.
#
# De hecho, en la página 530 del estándar de Common Lisp pone:
#
# "# - This is a dispatching macro character."
#
# O sea, `#' es el `dispatching macro character'. Al final del párrafo
# añade:
#
# "See the next section for predefined # macro-character constructions."
#
# Y de hecho, la tabla con todas las combinaciones que se muestra en la
# página 531 se titula: "Standard # Macro Character Syntax". Por lo
# tanto, parece razonable referirse a estas combinaciones como "# macro
# carácter"
#
#: defs2.lsp:496
#, fuzzy
msgid "~S from ~S: After ~S is ~S an undefined dispatch macro character"
msgstr "~ en ~: Después de ~ está ~, que no es un macro carácter secundario"

#: loop.lsp:47
msgid "~S: syntax error after ~A in ~S"
msgstr "~S: error de sintaxis después de ~A en ~S"

#: loop.lsp:259
msgid "~S: missing variable"
msgstr "~S: variable ausente"

#: loop.lsp:272
msgid "~S: After ~S, ~S is interpreted as a type specification"
msgstr "~S: Después de ~S, ~S es interpretado como una especificación de tipo"

#: loop.lsp:550
msgid "~S: ~A clauses should occur before the loop's main body"
msgstr "~S: las claúsulas ~A deben aparecer antes del cuerpo principal del bucle"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lsp:715
msgid "~S: After ~S a plural loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un plural, y no ~A"

#
# Duda: Ni idea de lo que significan estos mensajes, ...
#
#: loop.lsp:724
msgid "~S: After ~S a singular loop keyword is required, not ~A"
msgstr "~S: Después de ~S, es necesario un singular, y no ~A"

#: loop.lsp:875
msgid "~S: questionable iteration direction after ~A"
msgstr "~S: dirección incierta de la iteración después de ~A"

#: loop.lsp:889
msgid "~S: specifying ~A requires FROM or DOWNFROM"
msgstr "~S: especificar ~A requiere FROM o DOWNFROM"

#: loop.lsp:980
msgid "~S: illegal syntax near ~S in ~S"
msgstr "~S: sintaxis inválida cerca de ~S en ~S"

#: loop.lsp:989
msgid "~S: ambiguous result of loop ~S"
msgstr "~S: el resultado del bucle ~S es ambiguo"

#: loop.lsp:1152
msgid "~S is possible only from within ~S"
msgstr "~S sólo es posible desde ~S"

#: loop.lsp:1158
msgid "Use of ~S in FINALLY clauses is deprecated because it can lead to infinite loops."
msgstr "La utilización de ~S en las cláusulas FINALLY está desaconsejada puesto que puede provocar bucles infinitos"

#: loop.lsp:1164
msgid "~S is not possible here"
msgstr "~S es imposible aquí"

#: clos.lsp:167 clos.lsp:192
msgid "~S: argument ~S is not a symbol"
msgstr "~S: el argumento ~S no es un símbolo"

#: clos.lsp:176
msgid "~S: ~S does not name a class"
msgstr "~S: ~S no nombra una clase"

#: clos.lsp:200
msgid "~S: ~S is not a class"
msgstr "~S: ~S no es una clase"

#: clos.lsp:209
msgid "~S: cannot redefine built-in class ~S"
msgstr "~S: no se puede redefinir la clase predefinida ~S"

#: clos.lsp:218
msgid "~S: Redefining the COMMON LISP class ~S"
msgstr "~S: Redefiniendo la clase de COMMON LISP ~S"

#: clos.lsp:375
msgid "instance ~S of class ~S has no slots (wrong metaclass)"
msgstr "la instancia ~S de la clase ~S no tiene ranuras (metaclase errónea)"

#: clos.lsp:398 clos.lsp:451
msgid "~S: not a list of slots: ~S"
msgstr "~S: no es una lista de ranuras: ~S"

#: clos.lsp:408
msgid "~S: invalid slot and variable specification ~S"
msgstr "~S: especificación inválida de ranura y variable: ~S"

#: clos.lsp:416 clos.lsp:466
msgid "~S: variable ~S should be a symbol"
msgstr "~S: la variable ~S debe ser un símbolo"

#: clos.lsp:424
msgid "~S: slot name ~S should be a symbol"
msgstr "~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lsp:459
msgid "~S: invalid slot and accessor specification ~S"
msgstr "~S: especificación inválida de ranura y función de acceso: ~S"

#: clos.lsp:473
msgid "~S: accessor name ~S should be a symbol"
msgstr "~S: el nombre de la función de acceso ~S debe ser un símbolo"

#: clos.lsp:566
msgid "~S: class name ~S should be a symbol"
msgstr "~S: el nombre de la clase ~S debe ser un símbolo"

#: clos.lsp:575
msgid "~S ~S: expecting list of superclasses instead of ~S"
msgstr "~S ~S: se esperaba una lista de superclases en vez de ~S"

#: clos.lsp:583
msgid "~S ~S: superclass name ~S should be a symbol"
msgstr "~S ~S: el nombre de la superclase ~S debe ser un símbolo"

#: clos.lsp:597
msgid "~S ~S: expecting list of slot specifications instead of ~S"
msgstr "~S ~S: se esperaba una lista de especificación de ranuras en vez de ~S"

#: clos.lsp:609
msgid "~S ~S: slot name ~S should be a symbol"
msgstr "~S ~S: el nombre de la ranura ~S debe ser un símbolo"

#: clos.lsp:616
msgid "~S ~S: There may be only one direct slot with the name ~S."
msgstr "~S ~S: Sólo puede haber una ranura directa con el nombre ~S."

#: clos.lsp:633
msgid "~S ~S: slot options for slot ~S don't come in pairs"
msgstr "~S ~S: las opciones de ranura para ~S no aparecen por pares"

#: clos.lsp:646
msgid "~S ~S, slot option for slot ~S: ~S is not a function name"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una función"

#: clos.lsp:658 clos.lsp:686
msgid "~S ~S, slot option for slot ~S: ~S is not a symbol"
msgstr "~S ~S, opción de ranura para ~S: ~S no es un símbolo"

#: clos.lsp:670 clos.lsp:696 clos.lsp:707 clos.lsp:717
msgid "~S ~S, slot option ~S for slot ~S may only be given once"
msgstr "~S ~S, la opción de ranura ~S para ~S solo debe indicarse una vez"

#: clos.lsp:678
msgid "~S ~S, slot option for slot ~S must have the value ~S or ~S, not ~S"
msgstr "~S ~S, la opción de ranura para ~S debe tener el valor ~S o ~S, y no ~S"

#: clos.lsp:724
msgid "~S ~S, slot option for slot ~S: ~S is not a string"
msgstr "~S ~S, opción de ranura para ~S: ~S no es una cadena de caracteres"

#: clos.lsp:733
msgid "~S ~S, slot option for slot ~S: ~S is not a valid slot option"
msgstr "~S ~S, opción de ranura para ~S: ~S no es el nombre de una opción de ranura válida"

#: clos.lsp:786
msgid "~S ~S, option ~S may only be given once"
msgstr "~S ~S, la opción ~S sólo se puede indicar una vez"

#: clos.lsp:797 clos.lsp:830
msgid "~S ~S, option ~S: ~S is not a symbol"
msgstr "~S ~S, opción ~S: ~S no es un símbolo"

#: clos.lsp:810
msgid "~S ~S: option ~S should be written ~S"
msgstr "~S ~S: la opción ~S debe escribirse como ~S"

#: clos.lsp:817
msgid "~S ~S, option ~S: arguments don't come in pairs"
msgstr "~S ~S, opción ~S: los argumentos no aparecen en pares"

#: clos.lsp:837
msgid "~S ~S, option ~S: ~S may only be given once"
msgstr "~S ~S, opción ~S: ~S sólo se puede poner una vez"

#: clos.lsp:859
msgid "~S ~S, option ~S: ~S is not a string"
msgstr "~S ~S, opción ~S: ~S no es una cadena de caracteres"

#: clos.lsp:870
msgid "~S ~S: invalid option ~S"
msgstr "~S ~S: la opción ~S es inválida"

#: clos.lsp:979
msgid "~S: Class ~S is being redefined, instances are obsolete"
msgstr "~S: La clase ~S ha sido redefinida, las instancias son obsoletas"

#: clos.lsp:1063
msgid "~S ~S: superclass ~S should belong to class STANDARD-CLASS"
msgstr "~S ~S: la superclase ~S debe pertenecer a la clase STANDARD-CLASS"

#: clos.lsp:1235
msgid "~S ~S: inconsistent precedence graph, cycle ~S"
msgstr "~S ~S: grafo de precedencia inconsistente, ciclo ~S"

#: clos.lsp:1276
msgid "(class-precedence-list ~S) and (class-precedence-list ~S) are inconsistent"
msgstr "(class-precedence-list ~S) y (class-precedence-list ~S) son inconsistentes"

#: clos.lsp:1434
msgid "~S: superclass ~S should belong to class BUILT-IN-CLASS"
msgstr "~S: la superclase ~S debe pertenecer a la clase BUILT-IN-CLASS"

#: clos.lsp:1478
msgid "~S: metaclass STRUCTURE-CLASS forbids more than one direct superclass"
msgstr "~S: la metaclase STRUCTURE-CLASS prohibe más de una superclase directa"

#: clos.lsp:1485
msgid "~S: superclass ~S should belong to class STRUCTURE-CLASS"
msgstr "~S: la superclase ~S debe pertenecer a la clase STRUCTURE-CLASS"

#: clos.lsp:1527
msgid "~S: metaclass STRUCTURE-CLASS does not support shared slots"
msgstr "~S: la metaclase STRUCTURE-CLASS no mantiene ranuras compartidas"

#: clos.lsp:1802
msgid "~S ~S: missing lambda list"
msgstr "~S ~S: falta la lista lambda"

#: clos.lsp:1816
msgid "STANDARD method combination doesn't allow the method qualifiers to be ~S"
msgstr "La combinación STANDARD de los métodos no permite que los cualificadores de método sean ~S"

#: clos.lsp:1971 clos.lsp:1978
msgid "~S ~S: ~S is invalid within ~S methods"
msgstr "~S ~S: ~S es inválido dentro de los métodos ~S"

#: clos.lsp:2230
msgid "Too few arguments to ~S: ~S"
msgstr "Muy pocos argumentos para ~S: ~S"

#: clos.lsp:2357
msgid "The generic function ~S is being modified, but has already been called."
msgstr "La función genérica ~S está siendo modificada, pero ya ha sido invocada."

#: clos.lsp:2922
msgid "~S in ~S: the new arguments ~S have a different effective method than the old arguments ~S"
msgstr ""

#: clos.lsp:2945
msgid "~S has ~S, but ~S has ~S required parameters"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros obligatorios"

#: clos.lsp:2952
msgid "~S has ~S, but ~S has ~S optional parameters"
msgstr "~S tiene ~S, pero ~S tiene ~S parámetros opcionales"

#: clos.lsp:2959 clos.lsp:2966
msgid "~S has &REST or &KEY, but ~S hasn't."
msgstr "~S tiene parámetros &REST o &KEY, pero ~S no."

#: clos.lsp:2980
msgid "~S doesn't accept the keywords ~S of ~S"
msgstr "~S no acepta las palabras clave ~S de ~S"

#: clos.lsp:3010
msgid "Replacing method ~S in ~S"
msgstr "Reemplazando el método ~S de ~S"

#: clos.lsp:3030
msgid "Removing method ~S in ~S"
msgstr "Borrando el método ~S de ~S"

#: clos.lsp:3059
msgid "~S has no method with qualifiers ~:S and specializers ~S"
msgstr "~S no tiene ningún método con cualificadores ~:S y especializadores ~S"

#: clos.lsp:3092 clos.lsp:3437
msgid "~S doesn't name a generic function"
msgstr "~S no es una función genérica"

#: clos.lsp:3160
msgid "~S ~S: Only ~S declarations are permitted: ~S"
msgstr "~S ~S: Sólo la declaraciones ~S están permitidas: ~S"

#: clos.lsp:3171
msgid "~S ~S: ~S may only be specified once."
msgstr "~S ~S: ~S sólo puede especificarse una vez."

#: clos.lsp:3181
msgid "~S ~S: A string must be specified after ~S : ~S"
msgstr "~S ~S: Debe especificarse una cadena de caracteres después de ~S: ~S"

#: clos.lsp:3188
msgid "~S ~S: Only one ~S string is allowed"
msgstr "~S ~S: Sólo se permite una cadena de caracteres ~S"

#: clos.lsp:3198
msgid "~S ~S: The only valid method combination is ~S : ~S"
msgstr "~S ~S: La única combinación de métodos válida es ~S : ~S"

#: clos.lsp:3208
msgid "~S ~S: The only valid generic function class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de función genérica es ~S : ~S"

#: clos.lsp:3218
msgid "~S ~S: The only valid method class name is ~S : ~S"
msgstr "~S ~S: El único nombre válido de una clase de métodos es ~S : ~S"

#: clos.lsp:3241
msgid "~S ~S: ~S is not one of the required parameters: ~S"
msgstr "~S ~S: ~S no es uno de los parámetros obligatorios: ~S"

#: clos.lsp:3255
msgid "~S ~S: some variable occurs twice in ~S"
msgstr "~S ~S: alguna variable ha aparecido dos veces en ~S"

#: clos.lsp:3262
msgid "~S ~S: ~S is missing some required parameter"
msgstr "~S ~S: ~S necesita algunos parámetros obligatorios"

#: clos.lsp:3293
msgid "~S ~S: No initializations are allowed in a generic function lambda-list: ~S"
msgstr "~S ~S: No están permitidas las inicializaciones en la lista lambda de una función genérica: ~S"

#: clos.lsp:3301
msgid "~S ~S: variable name ~S should be a symbol"
msgstr "~S ~S: el nombre de la variable ~S debe ser un símbolo"

#: clos.lsp:3308
msgid "~S ~S: duplicate variable name ~S"
msgstr "~S ~S: el nombre de la variable ~S está duplicado"

#: clos.lsp:3361
msgid "~S ~S: invalid lambda list portion: ~S"
msgstr "~S ~S: parte de la lista lambda es inválida: ~S"

#: clos.lsp:3414
msgid "Removing all methods of ~S"
msgstr "Borrando todos los métodos de ~S"

#: clos.lsp:3424
msgid "Modifying the parameter profile of ~S"
msgstr "Modificando el perfil de parámetro de ~S"

#: clos.lsp:3484
msgid "~S: ~S is not a generic function specification"
msgstr "~S: ~S no es una especificación de función genérica"

#: clos.lsp:3549
msgid "~S: The name of a class must be a symbol, not ~S"
msgstr "~S: El nombre de una clase debe ser un símbolo, no ~S"

#: clos.lsp:3556
msgid "~S: The name of the built-in class ~S cannot be modified"
msgstr "~S: No es posible modificar el nombre de la clase predefinida ~S"

#: clos.lsp:3567
msgid "~S: When calling ~S with arguments ~S, no method is applicable."
msgstr "~S: No se puede aplicar ningún método al invocar ~S con los argumentos ~S."

#: clos.lsp:3576
msgid "~S: When calling ~S with arguments ~S, no primary method is applicable."
msgstr "~S: No se puede aplicar ningún método primario al invocar ~S con los argumentos ~S"

#: clos.lsp:3588
msgid "~S: When calling ~S with arguments ~S, there is no next method after ~S, and ~S was called."
msgstr "~S: Mientras se invoca ~S con los argumentos ~S, no hay ningún método después de ~S, y ~S fue llamado."

#: clos.lsp:3641
msgid "~S: The class ~S has no slot named ~S"
msgstr "~S: La clase ~S no tiene ninguna ranura llamada ~S"

#: clos.lsp:3651
msgid "~S: The slot ~S of ~S has no value"
msgstr "~S: La ranura ~S de ~S no tiene ningún valor"

# Duda: Lo que he dicho unos pocos mensajes más arriba --> Slot por
# slot, ...
#
# Pues no, ... A partir de la versión 1.4, `slot' es "ranura", tal y
# como se propone en la lista de spanglish.
#
#: clos.lsp:3682
msgid "~%Slots:"
msgstr "~%Ranuras:"

#: clos.lsp:3690
msgid "unbound"
msgstr "sin asociar"

# Duda: Lo de siempre --> slot es `registro', `campo', etc. Sin embargo,
# el término en Common Lisp está tan usado que casi preferiría dejarlo
# así, ..., ¿qué os parece?
#
# Como he visto que en la lista de spanglish proponen "ranura" pues lo
# he cambiado en todo el documento, ... ¿os gusta más? - cll
#
#: clos.lsp:3696
msgid "~%No slots."
msgstr "~%Sin ranuras."

#: conditio.lsp:84
msgid "~S: the name of a condition must be a symbol, not ~S"
msgstr "~S: el nombre de una condición debe ser un símbolo, y no ~S"

# En este mensaje, el término `parent-type' se refiere al segundo
# argumento de la macro `define-condition' que, según el estándar, se
# utiliza como lista de super-tipos del que se obtiene una nueva
# condición.
#
# Por ese motivo, he añadido la expresión "super-tipos" - cll
#
#: conditio.lsp:91
msgid "~S: the parent-type list must be a list of symbols, not ~S"
msgstr "~S: la lista de \"super-tipos\" debe ser una lista de símbolos, y no ~S"

#: conditio.lsp:98
msgid "~S: the slot description list must be a list, not ~S"
msgstr "~S: la lista de descripción de la ranura debe ser una lista, y no ~S"

#: conditio.lsp:154
msgid "~S: type ~S is not a subtype of ~S"
msgstr "~S: el tipo ~S no es un subtipo de ~S"

#: conditio.lsp:171
msgid "~S ~S: superfluous arguments ~S"
msgstr "~S ~S: los argumentos ~S son superfluos"

#: conditio.lsp:190
msgid "~S: the condition argument must be a string, a symbol or a condition, not ~S"
msgstr "~S: el argumento de la condición debe ser una cadena de caracteres, un símbolo o una condición, y no ~S"

#: conditio.lsp:556
msgid "~S: illegal syntax of clause ~S"
msgstr "~S: la sintaxis de la clausula ~S es inválida"

#: conditio.lsp:564
msgid "~S: misplaced ~S clause: ~S"
msgstr "~S: la clausula ~S está mal colocada: ~S"

#: conditio.lsp:572
msgid "~S: too many variables ~S in clause ~S"
msgstr "~S: demasiadas variables ~S en la clausula ~S"

# Duda: ¿y cómo traduzco `restart'?
#
# He decidido dejar `restart' sin traducir, ... :(
#
#: conditio.lsp:787
msgid "~S: ~S is not a valid restart name here. Use ~S instead."
msgstr "~S: ~S no es válido como nombre de `restart' aquí. En su lugar, use ~S."

#: conditio.lsp:810
msgid "~S: invalid restart name ~S"
msgstr "~S: ~S es un nombre inválido de `restart'"

#: conditio.lsp:819
msgid "~S: No restart named ~S is visible."
msgstr "~S: No hay ningún `restart' visible llamado ~S"

#: conditio.lsp:879 conditio.lsp:944
msgid "~S: not a list: ~S"
msgstr "~S: no es una lista: ~S"

#: conditio.lsp:890 conditio.lsp:955
msgid "~S: invalid restart specification ~S"
msgstr "~S: ~S no es una especificación válida de `restart'"

#: conditio.lsp:903 conditio.lsp:997
msgid "~S: unnamed restarts require ~S to be specified: ~S"
msgstr "~S: es necesario especificar ~S en los `restart' sin nombre: ~S"

#: conditio.lsp:980
msgid "~S: missing lambda list in restart specification ~S"
msgstr "~S: falta la lista lambda en la especificación del `restart' ~S"

#: conditio.lsp:1007
msgid "~S: restart cannot be invoked interactively because it is missing a ~S option: ~S"
msgstr "~S: el `restart' no puede invocarse interactivamente porque falta la opción ~S: ~S"

#: conditio.lsp:1408 conditio.lsp:1531
msgid "Return from ~S loop"
msgstr "Retorno del bucle ~S"

#
# En este caso he tenido que traducir `warning' por `advertencia', en
# vez de `atención'. ¿No querreis que diga algo así como "Esto es más
# serio que un toque de atención"? Así parecería que el compilador le va
# a meter una paliza al pobre programador, ... :) - cll
#
#: conditio.lsp:1507
msgid "~S: This is more serious than a warning: ~A"
msgstr "~S: Esto es más serio que una advertencia: ~A"

# Creo que si ~S es un sólo carácter, te cabe en la misma línea :-) sv
#
#: foreign1.lsp:83
msgid "Cannot map string ~S to C since it contains a character ~S"
msgstr "La cadena ~S no puede convertirse a C puesto que contiene el carácter ~S"

#: foreign1.lsp:127
msgid "Incomplete FFI type ~S is not allowed here."
msgstr "El tipo incompleto FFI ~S no está permitido aquí"

#: foreign1.lsp:135
msgid "FFI type should be a symbol, not ~S"
msgstr "Un tipo FFI debe ser un símbolo, no ~S"

# Duda: pues un poco lo de siempre. FFI significa Foreign Function
# Interface y todo el mundo sabe que es el módulo de llamadas a
# funciones escritas en otro lenguaje (lo que yo he traducido como
# llamadas extranjeras). Los programadores avanzados en Lisp (y sólo
# ellos podrían ver un mensaje como este, ...) saben muy bien lo que es
# FFI. ¿Lo dejo así?, ...
#
# Uno de nuestros revisores (César Ballardini) dijo en cierta ocasión:
# "No es necesario explicar la terminología dentro de su propio contexto."
# Es decir: Si finalmente te decides por FFI (que por lo que dices
# parece lo más razonable), pon cuidado de no explicarlo tanto, por ejemplo,
# en el mensaje anterior al anterior a este. sv
#
# Vale, pues entonces se queda como FFI ¡y listo! cll
#
#: foreign1.lsp:141
msgid "Invalid FFI type: ~S"
msgstr "Tipo FFI inválido: ~S"

#: foreign1.lsp:160 foreign1.lsp:227
msgid "Invalid ~S component: ~S"
msgstr "Componente ~S inválida: ~S"

#: foreign1.lsp:338
msgid "Invalid option in ~S: ~S"
msgstr "Opción inválida en ~S: ~S"

#: foreign1.lsp:344
msgid "Only one ~S option is allowed: ~S"
msgstr "Sólo se permite una opción ~S: ~S"

#: foreign1.lsp:363
msgid "Invalid parameter specification in ~S: ~S"
msgstr "Especificación de parámetro inválida en ~S: ~S"

#: foreign1.lsp:426
msgid "The name must be a string, not ~S"
msgstr "El nombre debe ser una cadena, no ~S"

#: foreign1.lsp:433
msgid "The name ~S is not a valid C identifier"
msgstr "El nombre ~S no es un identificador válido en C"

#: foreign1.lsp:695
msgid "illegal foreign data type ~S"
msgstr "el tipo de datos extranjero ~ es inválido"

#: foreign1.lsp:828
msgid "~S: ~S option missing in ~S"
msgstr "~S: falta la opción ~S en ~S"

#: foreign1.lsp:1025
msgid "~S: :OUT argument is not a pointer: ~S"
msgstr "~S: el argumento :OUT no es un puntero: ~S"

#: foreign1.lsp:1091
msgid "~S is only allowed after ~S: ~S"
msgstr "Sólo se puede poner ~S después de ~S: ~S"

#: screen.lsp:228
msgid "Got bad response from ~S: ~S"
msgstr "Se obtuvo una respuesta incorrecta de ~S: ~S"

#: rexx1.lsp:146
msgid "No waiting for ~S possible."
msgstr "No se puede esperar por ~S."

#: affi1.lsp:39
msgid "Basename ~S not a keyword or libraryname ~S not a string"
msgstr "La base ~S no es una palabra clave o el nombre de la biblioteca ~S no es una cadena de caracteres"

#: affi1.lsp:48
msgid "Library redefinition: old ~S, new ~S"
msgstr "La biblioteca llamada ~S ha sido redefinida como ~S"

#: affi1.lsp:60
msgid "Unknown library: ~S"
msgstr "Biblioteca desconocida: ~S"

#: affi1.lsp:89
msgid "Library ~S is not open"
msgstr "La biblioteca ~S no está abierta"

#: affi1.lsp:153
msgid "Unknown function of library ~S: ~S"
msgstr "No se conoce ninguna función en la biblioteca ~S con el nombre ~S"

#: affi1.lsp:181
msgid "Offset must be a fixnum: ~S"
msgstr "El desplazamiento no es del tipo FIXNUM: ~S"

#: affi1.lsp:194
msgid "~&;; redefining foreign library function ~S~%;;  from ~S to ~S~%"
msgstr "~&;; redefiniendo la función ~S de la biblioteca externa~%;;  de ~S a ~S~% "

#: affi1.lsp:215
msgid "Unknown register: ~S"
msgstr "Registro desconocido: ~S"

#: affi1.lsp:229
msgid "Invalid parameter specification ~S in function ~S"
msgstr "La especificación de parámetros ~S de la función ~S es incorrecta"

#: affi1.lsp:243
msgid "Unknown library function: ~S"
msgstr "La función de biblioteca ~S no está definida"

#: affi1.lsp:262
msgid "Bad number of arguments for ~S: ~S"
msgstr "El número de argumentos de ~S es incorrecto: ~S"

#: editor.lsp:985
msgid "cursor up"
msgstr "cursor arriba"

#: editor.lsp:994
msgid "cursor down"
msgstr "cursor abajo"

#: editor.lsp:1003
msgid "cursor left"
msgstr "cursor a la izquierda"

#: editor.lsp:1018
msgid "cursor right"
msgstr "cursor a la derecha"

#: editor.lsp:1033
msgid "cursor to start of line"
msgstr "cursor al principio de línea"

#: editor.lsp:1042
msgid "cursor to end of line"
msgstr "cursor al final de la línea"

#: editor.lsp:1051
msgid "cursor to start of text"
msgstr "cursor al principio del texto"

#: editor.lsp:1059
msgid "cursor to end of text"
msgstr "cursor al final del texto"

#: editor.lsp:1069
msgid "page up"
msgstr "retroceso de página"

#: editor.lsp:1077
msgid "page down"
msgstr "avance de página"

#: editor.lsp:1085
msgid "line up"
msgstr "retroceder una línea"

#: editor.lsp:1093
msgid "line down"
msgstr "avanzar una línea"

#: editor.lsp:1119
msgid "set mark ~D"
msgstr "poner la marca ~D"

#: editor.lsp:1134
msgid "cursor to mark ~D"
msgstr "mover el cursor a la marca ~D"

#: editor.lsp:1199
msgid "delete character at cursor"
msgstr "borrar el carácter bajo el cursor"

#: editor.lsp:1224
msgid "combine two lines"
msgstr "juntar dos líneas"

#: editor.lsp:1256
msgid "delete character at cursor, across lines"
msgstr "borrar el carácter bajo el cursor, a través de varias líneas"

#: editor.lsp:1263
msgid "delete character before cursor"
msgstr "borrar el carácter antes del cursor"

#: editor.lsp:1272
msgid "delete character before cursor, across lines"
msgstr "borrar el carácter antes del cursor, a través de varias líneas"

#: editor.lsp:1315
msgid "delete line"
msgstr "borrar una línea"

#: editor.lsp:1326
msgid "delete part of line left to the cursor"
msgstr "borrar la línea hasta donde está el cursor"

#: editor.lsp:1335
msgid "delete up to end of line"
msgstr "borrar hasta el final de la línea"

#: editor.lsp:1369
msgid "begin new line at cursor"
msgstr "comenzar una nueva línea en la posición del cursor"

#: editor.lsp:1496
msgid "cursor to start of block"
msgstr "mover el cursor al comienzo del bloque"

#: editor.lsp:1508
msgid "cursor to end of block"
msgstr "mover el cursor al final del bloque"

#: editor.lsp:1521
msgid "set block start"
msgstr "establecer el comienzo de un bloque"

#: editor.lsp:1546
msgid "set block end"
msgstr "establecer el final de un bloque"

#: editor.lsp:1569
msgid "remove block marks"
msgstr "desechar las marcas del bloque"

#: editor.lsp:1623
msgid "delete block"
msgstr "borrar un bloque"

#: editor.lsp:1639
msgid "move block to cursor position"
msgstr "mover el bloque a la posición del cursor"

#: editor.lsp:1667
msgid "copy block to cursor position"
msgstr "copiar un bloque a la posición del cursor"

#: editor.lsp:1684
msgid "copy block into cut-and-paste buffer"
msgstr "copiar un bloque en el buffer de cortar-y-pegar"

#: editor.lsp:1697
msgid "yank block into cut-and-paste buffer"
msgstr "insertar un bloque en el buffer de cortar-y-pegar"

#: editor.lsp:1717
msgid "insert cut-and-paste buffer contents"
msgstr "inserta los contenidos del buffer cortar-y-pegar"

#: editor.lsp:1849
msgid " Key bindings "
msgstr " Asociaciones de teclado "

#: editor.lsp:1858
msgid "                           K E Y   B I N D I N G S"
msgstr "                 A S O C I A C I O N E S   D E   T E C L A D O"

#: editor.lsp:1964
msgid " File to load: "
msgstr " Lectura del fichero: "

#: editor.lsp:2069
msgid " Save as: "
msgstr " Salvar como: "

#: editor.lsp:2250
msgid "evaluate block contents"
msgstr "evaluar los contenidos del bloque"

#: editor.lsp:2272
msgid "skip whitespace right"
msgstr "ignorar los espacios en blanco a la derecha"

#: editor.lsp:2289
msgid "~S from ~S: |# is legal only after #|"
msgstr "~ en ~: |# es legal solo después de #|"

#: editor.lsp:2325
msgid "mark next Lisp object"
msgstr "marcar el siguiente objeto Lisp"

#
# Duda: `surrounding' por `circundante'
#
# ¿ Qué os parece ?
#
#: editor.lsp:2393
msgid "mark surrounding top level form"
msgstr "marcar la forma circundante"

#
# Duda: `surrounding' por `circundante'
#
# ¿ Qué os parece ?
#
#: editor.lsp:2400
msgid "evaluate surrounding top level form"
msgstr "evaluar la forma circundante"

#: editor.lsp:2441
msgid "insert spaces up to next tab stop"
msgstr "insertar espacios hasta la siguiente marca de tabulación"

#: editor.lsp:2454
msgid "search for a string"
msgstr "buscar una cadena de caracteres"

#: editor.lsp:2458
msgid " Search: "
msgstr " Buscar: "

#: editor.lsp:2467
msgid "continue searching"
msgstr "continuar la búsqueda"

#: editor.lsp:2495 editor.lsp:2693 editor.lsp:2781
msgid "show window ~D"
msgstr "mostrar la ventana ~D"

#: editor.lsp:2501 editor.lsp:2787
msgid "hide window ~D"
msgstr "ocultar la ventana ~D"

#: editor.lsp:2518 editor.lsp:2710 editor.lsp:2866
msgid "show help window (this text)"
msgstr "muestra la ventana de ayuda (este texto) "

#: editor.lsp:2523 editor.lsp:2714 editor.lsp:2812
msgid "show error window"
msgstr "mostrar la ventana de error"

#: editor.lsp:2527 editor.lsp:2718 editor.lsp:2840
msgid "show trace window"
msgstr "mostrar la ventana de rastreo"

#: editor.lsp:2542 editor.lsp:2723 editor.lsp:2831
msgid "delete current window"
msgstr "borrar la ventana actual"

#: editor.lsp:2546 editor.lsp:2727 editor.lsp:2847
msgid "load file"
msgstr "cargar el fichero \""

#: editor.lsp:2550 editor.lsp:2836
msgid "store to file"
msgstr "almacenar en el fichero"

#: editor.lsp:2554 editor.lsp:2731 editor.lsp:2805
msgid "store to new file"
msgstr "almacenar en un fichero nuevo"

#: editor.lsp:2559 editor.lsp:2736 editor.lsp:2857
msgid "quit editor"
msgstr "salir del editor"

#: editor.lsp:2852
msgid "hide top window"
msgstr "ocultar la ventana superior"

#~ msgid "~: cannot create a window stream"
#~ msgstr "~: no se pudo crear un WINDOW-STREAM"

#
# "~: No existe un capturador (CATCH) para la etiqueta ~" - lsg
#
# ¡Perfecto! - cll
#
#~ msgid "~: There is no CATCHer for tag ~"
#~ msgstr "~: No existe un capturador (CATCH) para la etiqueta ~"

#~ msgid "device possibly full"
#~ msgstr "el disco está posiblemente lleno"

#, fuzzy
#~ msgid "~: argument ~ is not a STDWIN:WINDOW"
#~ msgstr "~: el argumento ~ no es un símbolo"

#, fuzzy
#~ msgid "~: argument ~ does not name a cursor type"
#~ msgstr "~: El ~ argumento ~ no es una matriz"

#, fuzzy
#~ msgid "~: argument ~ is not a string-char"
#~ msgstr "~: el argumento ~ no es un string"

#~ msgid "~: STDWIN limits the number of active menus"
#~ msgstr "~: STDWIN limita el número de menús activos"

#, fuzzy
#~ msgid "~: argument ~ is not a STDWIN:MENU"
#~ msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#, fuzzy
#~ msgid "~: argument ~ is not a STDWIN:MENU-ITEM"
#~ msgstr "~: el argumento ~ no es un SOCKET-STREAM"

#
# Cambiado `comando' por `orden', que parece ser muchísimo mejor - cll
#
#, fuzzy
#~ msgid ""
#~ "\n"
#~ "Help   = this command list\n"
#~ "Abort  = abort to the next recent input loop\n"
#~ "Unwind = abort to the next recent input loop\n"
#~ "Mode-1 = inspect all the stack elements\n"
#~ "Mode-2 = inspect all the frames\n"
#~ "Mode-3 = inspect only lexical frames\n"
#~ "Mode-4 = inspect only EVAL and APPLY frames (default)\n"
#~ "Mode-5 = inspect only APPLY frames\n"
#~ "Where  = inspect this frame\n"
#~ "Up     = go up one frame, inspect it\n"
#~ "Top    = go to top frame, inspect it\n"
#~ "Down   = go down one frame, inspect it"
#~ msgstr ""
#~ "\n"
#~ "Help   = esta lista de órdenes\n"
#~ "Abort  = volver al bucle de entrada más reciente\n"
#~ "Unwind = volver al bucle de entrada más reciente\n"
#~ "Mode-1 = inspeccionar todos los elementos de la pila\n"
#~ "Mode-2 = inspeccionar todos los marcos\n"
#~ "Mode-3 = inspeccionar únicamente los marcos léxicos\n"
#~ "Mode-4 = inspeccionar sólo los marcos de los tipos EVAL y APPLY (por\n"
#~ "         defecto)\n"
#~ "Mode-5 = inspeccionar sólo los marcos de tipo APPLY\n"
#~ "Where  = inspeccionar el marco actual\n"
#~ "Up     = ascender un marco, e inspeccionarlo\n"
#~ "Top    = ir al primer marco, e inspeccionarlo\n"
#~ "Down   = descender un marco e inspeccionarlo\n"
#~ "Bottom = ir al último marco (el más reciente) e inspeccionarlo\n"
#~ "Backtrace-1 = mostrar todos los elementos de la pila\n"
#~ "Backtrace-2 = mostrar todos los marcos\n"
#~ "Backtrace-3 = mostrar todos los marcos léxicos\n"
#~ "Backtrace-4 = mostrar todos los marcos de los tipos EVAL y APPLY\n"
#~ "Backtrace-5 = mostrar todos los marcos del tipo APPLY\n"
#~ "Backtrace   = mostrar la pila en el modo actual\n"
#~ "Break+ = establecer un punto de ruptura en un marco de tipo EVAL\n"
#~ "Break- = desactivar un punto de ruptura en un marco de tipo EVAL\n"
#~ "Redo   = re-evaluar la forma en un marco EVAL\n"
#~ "Return = abandonar un marco EVAL con los valores de vuelta indicados"

#, fuzzy
#~ msgid " ."
#~ msgstr "."

#~ msgid " ?"
#~ msgstr " ?"

# ¿Se podría poner PAQUETE? sv
#
# Pues sí, por supuesto. Lo que pasa es que estoy tan acostumbrado a ver el
# PACKAGE, ... :) cll
#
#~ msgid " from #<PACKAGE "
#~ msgstr " de #<PAQUETE "

# Duda: Ooops, alemán?!?
#
#~ msgid " inkonsistent!!"
#~ msgstr " ¡¡ inconsistente !!"

# Duda: Pues como está en alemán, y no se alemán, se queda en alemán, ...
#
#~ msgid " markiert!!"
#~ msgstr " markiert!!"

#, fuzzy
#~ msgid " only one value."
#~ msgstr "sin valores"

#, fuzzy
#~ msgid " should be accessible in "
#~ msgstr "¿ Qué símbolo debe ser accesible en ~S ?"

#~ msgid "Bad protocol option"
#~ msgstr "Opción de protocolo incorrecta"

#, fuzzy
#~ msgid "Can C manipulate the SP stack pointer?"
#~ msgstr "~: ~ no es un puntero de pila"

#~ msgid "Cannot remap immutable objects read-only."
#~ msgstr "No pueden volverse a transformar objetos inmutables de sólo lectura."

#~ msgid "Cannot remap immutable objects read/write."
#~ msgstr "No pueden volverse a transformar objetos inmutables de lectura/escritura."

#, fuzzy
#~ msgid "Condition of type ~S."
#~ msgstr "condición de parada: "

#~ msgid "It has been reset to 10."
#~ msgstr "Ha sido inicializado a 10."

#~ msgid "It is reset to ~."
#~ msgstr "Está inicializado a ~."

#~ msgid "Mach exc_server didn't succeed."
#~ msgstr "La llamada 'Mach exc_server' ha fallado."

#~ msgid "Mach msg_receive didn't succeed."
#~ msgstr "La llamada 'Mach msg_receive' ha fallado."

# Normalmente las citas las ponemos `así', no 'así'. sv
#
# ¡Santo Dios! Esto sí que no lo sabía, ... En fin, esta corrección lo
# haré al final del todo. Cuando haya acabado con la traducción me creo
# una macro en Emacs y le hago que busque todas las comillas así y las
# corrija, ... cll
#
#~ msgid "Mach msg_send didn't succeed."
#~ msgstr "La llamada 'Mach msg_send' ha fallado."

#~ msgid "Mach msg_send to old_exception_port didn't succeed."
#~ msgstr "La llamada 'Mach msg_send' al 'old_exception_port' ha fallado."

#~ msgid "Mach port_allocate fails."
#~ msgstr "La llamada 'Mach port_allocate' ha fallado."

#~ msgid "Mach task_get_exception_port fails."
#~ msgstr "La llamada 'Mach task_get_exception_port' ha fallado."

#~ msgid "Mach task_set_exception_port fails."
#~ msgstr "La llamada 'Mach task_set_exception_port' ha fallado."

#, fuzzy
#~ msgid "Mount device busy"
#~ msgstr "Dispositivo ocupado"

# Sugerencia: no está operativa. sv
#
# ¡Sí, señor! así es, de hecho, como debe decirse, ... cll
#
#, fuzzy
#~ msgid "Networking error"
#~ msgstr "La red no está operativa"

#~ msgid "Not owner"
#~ msgstr "No es el propietario."

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#, fuzzy
#~ msgid "OS error during load of init file `'"
#~ msgstr "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"

#, fuzzy
#~ msgid "OS error during load of init file."
#~ msgstr "error del sistema operativo durante la carga del fichero de inicialización\n"

# Duda: Más alemán, ...
#~ msgid "Objekt"
#~ msgstr "Objekt"

# Duda: ¡alemán!
#
#~ msgid "Page bei Adresse 0x"
#~ msgstr "Page bei Adresse 0x"

#~ msgid "Please send the authors of the program"
#~ msgstr "Por favor, envíe a los autores del programa"

# Duda: Aunque Bruno Haible me ha asegurado que la etiqueta
# sys_errlist[ENOLCK] del glibc.po en español contiene la traduccion que
# yo debiera usar, me he decidido por las indicaciones de Santiago Vila
# en su respuesta a mi mail y he puesto, simplemente: "No quedan
# registros de bloqueo disponibles"
#
#, fuzzy
#~ msgid "Protocol not available"
#~ msgstr "No quedan registros de bloqueo disponibles"

# Voy a ser un poco puntilloso: desconexión implica que ya se había
# conseguido la conexión.  Sin embargo, connection abort puede querer
# decir que se ha interrumpido el "intento" de conexión. Por tanto, mi
# sugerencia es: "El software ha provocado la interrupción de la
# conexión", que en mi opinion tiene la misma ambigüedad que el
# inglés. - lsg
#
# Vale, si, me gusta a saco - cll
#
#, fuzzy
#~ msgid "Remote peer released connection"
#~ msgstr "El software ha provocado la interrupción de la conexión"

# La traducción de este mensaje ha sido tomada de libc-1.98.es.po
# (traducción realizada por Enrique Melero).
#
#~ msgid "Too many references: can't splice"
#~ msgstr "Demasiadas referencias: no se pueden solapar"

# Esta también está muy consensuada. sv
#
# ¡Cierto! Y además, lo sabía, ..., pero cuando lo puse estaría pensando
# en las musarañas, ... cll
#
#~ msgid "Usage:  "
#~ msgstr "Modo de empleo:  "

#, fuzzy
#~ msgid "[end]cannot close"
#~ msgstr "No se puede cerrar %s ."

#, fuzzy
#~ msgid "[end]cannot delete"
#~ msgstr "No se puede borrar %s ."

#~ msgid "[end]cannot fill file"
#~ msgstr "."

#, fuzzy
#~ msgid "[end]cannot make file long enough"
#~ msgstr "No es posible agrandar %s lo suficiente."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#, fuzzy
#~ msgid "[end]cannot map memory to address 0x"
#~ msgstr "No se puede asignar la memoria a la dirección 0x%x ."

#, fuzzy
#~ msgid "[end]cannot map shared memory to address 0x"
#~ msgstr "No se puede asignar la memoria compartida a la direccion 0x%x."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#, fuzzy
#~ msgid "[end]cannot map to address 0x"
#~ msgstr "No se puede asignar la memoria a la dirección 0x%x ."

#, fuzzy
#~ msgid "[end]cannot open"
#~ msgstr "No se puede abrir %s."

#~ msgid "[end]out of disk space"
#~ msgstr "."

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#, fuzzy
#~ msgid "[end]requires package"
#~ msgstr "el módulo `%s' necesita el paquete %s.\n"

#~ msgid "[end]segfault cannot be cured"
#~ msgstr "."

#~ msgid "a description how you produced this error!"
#~ msgstr "una descripción de como produjo este error!"

# Esto no me cuadra.
# El hecho de haber versión para Amiga y el hecho de ser internacional son
# cosas independientes.
# ¿Por qué el msgid no dice "Amiga versión by Jörg Höhle"?
#~ msgid "amiga banner"
#~ msgstr "                    versión para Amiga: Jörg Höhle                     "

#, fuzzy
#~ msgid "code after ~S contains a dotted list, ending with ~S"
#~ msgstr "el código después de MACROLET contiene una lista punteada que termina con ~S"

#, fuzzy
#~ msgid "ctrl-c user break"
#~ msgstr "Ctrl-C: Interrupción del usuario"

#, fuzzy
#~ msgid "device full"
#~ msgstr "el disco está lleno"

#~ msgid "dos banner"
#~ msgstr "                    versión para DOS de Jürgen Weber y Bruno Haible "

#~ msgid "handle_fault error1 !"
#~ msgstr "handle_fault error1 !"

#~ msgid "handle_fault error2 ! address = 0x"
#~ msgstr "handle_fault error2 ! dirección = 0x"

#~ msgid "handle_fault error3 !"
#~ msgstr "handle_fault error3 !"

#~ msgid "handle_fault error4 ! mprotect(0x"
#~ msgstr "handle_fault error5 ! mprotect(0x"

#~ msgid "handle_fault error5 ! mprotect(0x"
#~ msgstr "handle_fault error6 ! protección = "

#~ msgid "handle_fault error6 ! protection = "
#~ msgstr "handle_fault error6 ! protección = "

#, fuzzy
#~ msgid "internal error in file ~, line ~"
#~ msgstr "~: error interno durante la construcción de ~"

#~ msgid "module"
#~ msgstr "módulo"

# Duda: ¡Increíble diferencia entre la etiqueta y el texto! :) (sin
# ánimo de crítica a Bruno y Marcus, por supuestísimo).
#
# En realidad, el texto es:
#
# "Recompile your operating system with SYSV IPC support."
#
# ..., que es lo que está traducido a continuación, ...
#
#~ msgid "need IPC support"
#~ msgstr "Recompile su sistema operativo con SYSV IPC."

#~ msgid "only"
#~ msgstr "solo"

#~ msgid "out of disk space"
#~ msgstr "** AVISO: ** no hay espacio libre suficiente en el disco para "

#, fuzzy
#~ msgid "out of memory"
#~ msgstr "No hay memoria suficiente"

#, fuzzy
#~ msgid "out of virtual memory"
#~ msgstr "No hay memoria suficiente"

#~ msgid "processor big endian?"
#~ msgstr "procesador BIG-ENDIAN?"

#~ msgid "restart with less memory"
#~ msgstr "Por favor, reinicialice LISP con menos memoria (opción -m)."

#, fuzzy
#~ msgid "segfault cannot be cured"
#~ msgstr "La constante ~S no puede ligarse."

#, fuzzy
#~ msgid "symbol "
#~ msgstr "~%El símbolo "

# ¿¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#, fuzzy
#~ msgid "unknown signature of a fsubr"
#~ msgstr "Tipo de argumento desconocido para SUBR\n"

#~ msgid "which symbol with name "
#~ msgstr "¿Qué símbolo con el nombre "

#~ msgid "~%Please input *jmpbuf-size*: "
#~ msgstr "~%Por favor introduzca *jmpbuf-size*: "

#~ msgid "~S ~S: the argument list for the BOA contructor ~S must not contain ~S: ~S"
#~ msgstr "~ ~S: la lista de argumentos para el constructor BOA ~S no debe contener ~S: ~S"
